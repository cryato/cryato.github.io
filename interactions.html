<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Interactions Viewer</title>
  <style>
    :root { --bg: #0f172a; --panel: #111827; --muted: #94a3b8; --text: #e5e7eb; --primary: #22d3ee; --accent: #8b5cf6; }
    html, body { height: 100%; }
    body { margin: 0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica Neue, Arial; background: linear-gradient(180deg, #0b1022 0%, #0f172a 100%); color: var(--text); }
    header { display: flex; align-items: center; justify-content: space-between; padding: 12px 16px; border-bottom: 1px solid #1f2937; position: sticky; top: 0; background: rgba(17,24,39,0.6); backdrop-filter: blur(8px); z-index: 10; }
    header h1 { font-size: 16px; margin: 0; }
    .toolbar { display: flex; gap: 8px; align-items: center; }
    input[type="text"], input[type="date"] { background: rgba(17,24,39,0.6); border: 1px solid #1f2937; color: var(--text); padding: 8px 10px; border-radius: 8px; outline: none; font-size: 13px; }
    .btn { appearance: none; border: 1px solid #283449; background: linear-gradient(180deg, #0b1224 0%, #0a1222 100%); color: #e5e7eb; border-radius: 8px; padding: 8px 12px; font-size: 13px; cursor: pointer; }
    .container { display: grid; grid-template-columns: 360px 1fr; gap: 16px; padding: 16px; }
    .panel { background: rgba(17,24,39,0.65); border: 1px solid #1f2937; border-radius: 12px; }
    .left { padding: 12px; }
    .field { display: grid; grid-template-columns: 120px 1fr; align-items: center; gap: 8px; margin: 8px 0; }
    .label { color: var(--muted); font-size: 12px; }
    .list { height: calc(100vh - 120px); overflow: auto; padding: 12px; }
    .run { border: 1px solid #1f2937; background: rgba(2,6,23,0.55); border-radius: 10px; padding: 10px; margin: 8px 0; }
    .meta { color: var(--muted); font-size: 12px; margin-bottom: 6px; display: flex; gap: 8px; flex-wrap: wrap; }
    .steps { margin-top: 10px; padding-left: 6px; border-left: 2px solid #334155; }
    .step { font-size: 12px; color: #cbd5e1; margin: 6px 0; }
    a { color: #93c5fd; }
    .empty { color: var(--muted); padding: 16px; }

    /* Single interaction view */
    .single { display: grid; grid-template-columns: 1fr; gap: 16px; padding: 16px; }
    .column { background: rgba(17,24,39,0.65); border: 1px solid #1f2937; border-radius: 12px; padding: 12px; min-height: calc(100vh - 130px); overflow: auto; }
    .flow-head { display: flex; align-items: center; justify-content: space-between; gap: 8px; margin-bottom: 8px; }
    .flow-title { font-size: 16px; font-weight: 600; }
    .steps-view .step { border: 1px solid #1f2937; background: rgba(2,6,23,0.55); border-radius: 10px; padding: 10px; margin: 8px 0; }
    .dimmed { opacity: 0.5; }
    .badge { font-size: 11px; padding: 2px 6px; border-radius: 999px; border: 1px solid #1f2937; background: rgba(15,23,42,0.6); color: #b3e1ff; margin-right: 8px; }
    .right-messages .msg { border: 1px solid #1f2937; background: rgba(2,6,23,0.55); border-radius: 10px; padding: 10px; margin: 8px 0; }
    .right-messages .meta { color: var(--muted); font-size: 12px; margin-bottom: 6px; display: flex; gap: 8px; flex-wrap: wrap; }

    /* Dark inputs for editable fields (match editor.html) */
    .steps-view input[type="text"], .steps-view textarea {
      width: 100%; box-sizing: border-box; background: rgba(17,24,39,0.6); border: 1px solid #1f2937; color: var(--text); padding: 10px 12px; border-radius: 10px; outline: none; font-size: 13px;
    }
    .steps-view textarea { min-height: 60px; resize: vertical; }

    /* Synced step/log grid for single view */
    .steps-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; align-items: stretch; }
    .steps-grid .cell { min-width: 0; }
    .steps-grid .cell.right { display: flex; flex-direction: column; justify-content: center; }
    .steps-grid .cell.right .msg { border: 1px solid #1f2937; background: rgba(2,6,23,0.55); border-radius: 10px; padding: 10px; margin: 8px 0; }
    .steps-grid .cell.right .meta { color: var(--muted); font-size: 12px; margin-bottom: 6px; display: flex; gap: 8px; flex-wrap: wrap; }
  </style>
</head>
<body>
  <header>
    <h1>Interactions</h1>
    <div class="toolbar">
      <button id="btnReload" class="btn">Reload</button>
      <a id="lnkConversations" class="btn" href="#">Conversations</a>
    </div>
  </header>

  <div id="viewList" class="container" style="display:none;">
    <div class="panel left">
      <div class="field">
        <div class="label">Request ID</div>
        <input id="inpRequestId" type="text" placeholder="request_id (optional)" />
      </div>
      <div class="field">
        <div class="label">Customer ID</div>
        <input id="inpUserId" type="text" placeholder="user_id (optional)" />
      </div>
      <div class="field">
        <div class="label">Start</div>
        <input id="inpStart" type="date" />
      </div>
      <div class="field">
        <div class="label">End</div>
        <input id="inpEnd" type="date" />
      </div>
      <div class="field">
        <div></div>
        <button id="btnApply" class="btn">Apply</button>
      </div>
      <div style="margin-top:12px; color: var(--muted); font-size: 12px;"></div>
    </div>
    <div class="panel">
      <div id="list" class="list"></div>
    </div>
  </div>

  <div id="viewSingle" class="single" style="display:none;">
    <div class="column">
      <div class="flow-head">
        <div class="flow-title" id="flowTitle">Flow</div>
        <div style="display:flex; gap:8px; align-items:center;">
          <button id="btnPublish" class="btn">Publish</button>
          <a id="btnOpenEditor" class="btn" href="editor" target="_blank">Open in Editor</a>
        </div>
      </div>
      <div id="flowSteps" class="steps-view"></div>
    </div>
    <div class="column right-messages">
      <div class="flow-head">
        <div class="flow-title">Interaction Log</div>
      </div>
      <div id="singleMessages"></div>
    </div>
  </div>

  <script type="module">
    import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.12.5/firebase-app.js';
    import { getAuth, signInAnonymously, onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/10.12.5/firebase-auth.js';
    import { getFirestore, collection, query, where, orderBy, limit, startAfter, Timestamp, getDocs, doc, getDoc } from 'https://www.gstatic.com/firebasejs/10.12.5/firebase-firestore.js';

    function readCookie(name) {
      const match = document.cookie.match(new RegExp('(?:^|; )' + name.replace(/([.$?*|{}()\[\]\\\/\+^])/g, '\\$1') + '=([^;]*)'));
      return match ? decodeURIComponent(match[1]) : '';
    }
    function getConfig() {
      const u = new URL(location.href);
      const p = (k) => u.searchParams.get(k) || '';
      return {
        apiKey: p('apiKey') || readCookie('apiKey') || '',
        authDomain: p('authDomain') || readCookie('authDomain') || '',
        projectId: p('projectId') || readCookie('projectId') || ''
      };
    }
    function buildUrlWithAuth(path, extraParams) {
      const params = new URLSearchParams();
      // Only include context-specific extras; do NOT carry auth params anymore
      Object.entries(extraParams || {}).forEach(([k, v]) => {
        if (v != null && String(v).length > 0) params.set(k, String(v));
      });
      const qs = params.toString();
      return qs ? `${path}?${qs}` : path;
    }


    const cfg = getConfig();
    const app = initializeApp({ apiKey: cfg.apiKey, authDomain: cfg.authDomain, projectId: cfg.projectId });
    const auth = getAuth(app);
    const db = getFirestore(app);

    // Minimal OAuth token state reused from Editor (read-only)
    let oauth = { accessToken: '', tokenExpiresAt: 0 };

    const els = {
      inpRequestId: document.getElementById('inpRequestId'),
      inpUserId: document.getElementById('inpUserId'),
      inpStart: document.getElementById('inpStart'),
      inpEnd: document.getElementById('inpEnd'),
      btnApply: document.getElementById('btnApply'),
      btnReload: document.getElementById('btnReload'),
      list: document.getElementById('list'),
      viewList: document.getElementById('viewList'),
      viewSingle: document.getElementById('viewSingle'),
      flowTitle: document.getElementById('flowTitle'),
      flowSteps: document.getElementById('flowSteps'),
      singleMessages: document.getElementById('singleMessages'),
      btnPublish: document.getElementById('btnPublish'),
      btnOpenEditor: document.getElementById('btnOpenEditor')
    };

    // Caches
    const conversationsCache = new Map(); // key: chatId_messageId -> Promise(data|null)
    const requestMessagesCache = new Map(); // key: requestId -> Promise<Map(message_id -> data)>

    function formatTimeHM(input) {
      if (!input) return '';
      const d = (input && typeof input.toDate === 'function') ? input.toDate() : (input instanceof Date ? input : new Date(input));
      if (!Number.isFinite(d.getTime())) return '';
      const hh = String(d.getHours()).padStart(2, '0');
      const mm = String(d.getMinutes()).padStart(2, '0');
      return `${hh}:${mm}`;
    }

    async function fetchConversationMessage(chatId, messageId) {
      if (!chatId || messageId == null) return null;
      const key = `${chatId}_${messageId}`;
      if (conversationsCache.has(key)) return conversationsCache.get(key);
      const p = (async () => {
        try {
          const ref = doc(db, 'conversations', key);
          const snap = await getDoc(ref);
          return snap.exists() ? snap.data() : null;
        } catch (_) {
          return null;
        }
      })();
      conversationsCache.set(key, p);
      return p;
    }

    async function fetchMessagesForRequestMap(chatId, requestId) {
      if (!requestId) return new Map();
      if (requestMessagesCache.has(requestId)) return requestMessagesCache.get(requestId);
      const p = (async () => {
        try {
          const colRef = collection(db, 'conversations');
          const q = query(colRef, where('request_id', '==', requestId), where('chat_id', '==', coerce(chatId)));
          const snap = await getDocs(q);
          const map = new Map();
          snap.forEach((doc) => {
            const d = doc.data();
            if (d && d.message_id != null) map.set(String(d.message_id), d);
          });
          return map;
        } catch (_) {
          return new Map();
        }
      })();
      requestMessagesCache.set(requestId, p);
      return p;
    }

    const url = new URL(location.href);
    const initialRequestId = url.searchParams.get('request_id') || '';
    const initialUserId = url.searchParams.get('user_id') || '';
    if (initialRequestId) els.inpRequestId.value = initialRequestId;
    if (initialUserId) els.inpUserId.value = initialUserId;

    // default last 7 days
    const today = new Date();
    const startDefault = new Date(today.getTime() - 6 * 24 * 60 * 60 * 1000);
    const toDateInput = (d) => d.toISOString().slice(0, 10);
    els.inpStart.value = url.searchParams.get('start') || toDateInput(startDefault);
    els.inpEnd.value = url.searchParams.get('end') || toDateInput(today);

    let paging = { last: null, done: false, pageSize: 30 };

    function coerce(val) {
      const n = Number(val);
      return Number.isFinite(n) ? n : val;
    }

    function renderEmpty() {
      els.list.innerHTML = '<div class="empty">No runs</div>';
    }

    // ---------- Flow Single View Helpers ----------
    let flowDoc = null;
    const flowOverrides = new Map(); // key -> def (in-memory edits)

    function getCfg() {
      try {
        const stored = JSON.parse(localStorage.getItem('gcs_config') || '{}');
        const bucket = (stored.bucket || '').trim();
        const object = 'flows/';
        return { bucket, object };
      } catch (_) {
        return { bucket: '', object: 'flows/' };
      }
    }

    function gcsDownloadUrl(bucket, objectPath) {
      return `https://storage.googleapis.com/storage/v1/b/${encodeURIComponent(bucket)}/o/${encodeURIComponent(objectPath)}?alt=media`;
    }
    function gcsUploadUrl(bucket, objectPath) {
      return `https://storage.googleapis.com/upload/storage/v1/b/${encodeURIComponent(bucket)}/o?uploadType=media&name=${encodeURIComponent(objectPath)}`;
    }

    function formatUtcNowForFlow() {
      const d = new Date();
      const pad = (n) => String(n).padStart(2, '0');
      const yyyy = d.getUTCFullYear();
      const mm = pad(d.getUTCMonth() + 1);
      const dd = pad(d.getUTCDate());
      const HH = pad(d.getUTCHours());
      const MM = pad(d.getUTCMinutes());
      return `${yyyy}-${mm}-${dd}T${HH}_${MM}Z`;
    }

    function formatBackupName(key, timestampUtc) {
      return `flows/backups/${key}_${timestampUtc}.json`;
    }

    function loadStoredTokenOnly() {
      try {
        const stored = JSON.parse(localStorage.getItem('gcs_token') || '{}');
        const { accessToken, tokenExpiresAt } = stored;
        if (accessToken && Number.isFinite(tokenExpiresAt)) {
          oauth.accessToken = accessToken;
          oauth.tokenExpiresAt = tokenExpiresAt;
        }
      } catch (_) {}
    }

    function hasValidToken() {
      return !!(oauth.accessToken && Date.now() < oauth.tokenExpiresAt - 5000);
    }

    function setCookie(name, value, days) {
      try {
        const d = new Date();
        d.setTime(d.getTime() + (days*24*60*60*1000));
        const expires = `expires=${d.toUTCString()}`;
        document.cookie = `${encodeURIComponent(name)}=${encodeURIComponent(String(value))}; ${expires}; path=/; SameSite=Lax`;
      } catch (_) {}
    }

    async function ensureFirebaseCookiesFromBucket() {
      try {
        const { bucket } = getCfg();
        if (!bucket || !hasValidToken()) return;
        const url = gcsDownloadUrl(bucket, 'firebase_config.json');
        const res = await fetch(url, { headers: { Authorization: `Bearer ${oauth.accessToken}` }, cache: 'no-store' });
        if (!res.ok) return;
        const json = await res.json();
        if (json && typeof json === 'object') {
          if (json.projectId) setCookie('projectId', json.projectId, 365);
          if (json.apiKey) setCookie('apiKey', json.apiKey, 365);
          if (json.authDomain) setCookie('authDomain', json.authDomain, 365);
        }
      } catch (_) {}
    }

    async function loadSingleFlow(key) {
      // Prefer Cloud single file, fallback to site-local candidates, then legacy combined
      loadStoredTokenOnly();
      const { bucket } = getCfg();
      if (bucket && hasValidToken()) {
        try {
          const res = await fetch(gcsDownloadUrl(bucket, `flows/${key}.json`), { headers: { Authorization: `Bearer ${oauth.accessToken}` }, cache: 'no-store' });
          if (res.ok) {
            const json = await res.json();
            let def = null;
            if (json && json.flows && json.flows[key]) def = json.flows[key];
            else if (json && json[key]) def = json[key];
            else def = json;
            flowDoc = { flows: { [key]: def || {} } };
            ensureFirebaseCookiesFromBucket().catch(() => {});
            return true;
          }
        } catch (_) {}
      }

      const candidates = [];
      const cur = new URL(location.href);
      candidates.push('flows/' + key + '.json');
      candidates.push('../flows/' + key + '.json');
      candidates.push('../../flows/' + key + '.json');
      candidates.push('/flows/' + key + '.json');
      for (const rel of candidates) {
        try {
          const url = new URL(rel, cur);
          const res = await fetch(url.toString(), { cache: 'no-store' });
          if (res.ok) {
            const json = await res.json();
            let def = null;
            if (json && json.flows && json.flows[key]) def = json.flows[key];
            else if (json && json[key]) def = json[key];
            else def = json;
            flowDoc = { flows: { [key]: def || {} } };
            return true;
          }
        } catch (_) {}
      }

      // Fallback to combined
      try {
        const res = await fetch('flows/flow.json', { cache: 'no-store' });
        if (res.ok) {
          const json = await res.json();
          const def = json && json.flows ? json.flows[key] : null;
          flowDoc = { flows: def ? { [key]: def } : {} };
          return !!def;
        }
      } catch (_) {}
      flowDoc = { flows: {} };
      return false;
    }

    function buildExecutedIndicesFromLogs(steps) {
      const set = new Set();
      steps.forEach((s) => {
        if (s && s.type === 'message' && Number.isFinite(s.step_index)) set.add(Number(s.step_index));
      });
      return set;
    }

    function buildGotoUsageIndexes(flowDef, stepsLogs) {
      const used = new Set();
      const loggedLabels = new Set(stepsLogs.filter((s) => s && s.type === 'goto' && s.label).map((s) => String(s.label)));
      const steps = Array.isArray(flowDef.steps) ? flowDef.steps : [];
      steps.forEach((st, idx) => {
        if (st && st.goto && loggedLabels.has(String(st.goto))) used.add(idx);
      });
      return used;
    }

    function buildStepLeftElement(st, idx, executed, gotoUsed, editable) {
      const wrap = document.createElement('div');
      wrap.className = 'step';
      const head = document.createElement('div');
      head.style.display = 'flex'; head.style.alignItems = 'center'; head.style.marginBottom = '6px';
      const badge = document.createElement('span');
      badge.className = 'badge';
      const type = st.ask ? 'ask' : (st.say ? 'say' : (st.wait ? 'wait' : (st.goto ? 'goto' : (st.label ? 'label' : (st.script ? 'script' : 'step')))));
      badge.textContent = type.toUpperCase();
      const idxEl = document.createElement('span');
      idxEl.style.color = '#94a3b8'; idxEl.style.fontSize = '12px'; idxEl.style.marginLeft = '8px';
      idxEl.textContent = '#' + (idx + 1);
      const spacer = document.createElement('div'); spacer.style.flex = '1 1 auto';
      head.appendChild(badge);
      head.appendChild(idxEl);
      head.appendChild(spacer);
      // Optional step name (ASK/SAY only)
      try {
        const hasName = (typeof st.name === 'string' && st.name.trim().length > 0);
        const isAskSay = (st.ask != null || st.say != null);
        if (isAskSay && hasName) {
          const nameEl = document.createElement('span');
          nameEl.style.color = '#e2e8f0';
          nameEl.style.fontSize = '12px';
          nameEl.style.marginLeft = '8px';
          nameEl.textContent = st.name.trim();
          head.appendChild(nameEl);
        }
      } catch (_) {}
      head.appendChild(buildFiltersEditor(st, editable));
      wrap.appendChild(head);

      // Append editors for all step types (hide step_id; edit filters via modal)
      appendEditorsForStep(st, wrap, editable);

      // Dimming logic
      const hasLaterExec = (i) => Array.from(executed).some((n) => n > i);
      let dim = false;
      if (st.goto) {
        if (!gotoUsed.has(idx) && hasLaterExec(idx)) dim = true; // goto was skipped due to filters
      }
      if ((st.ask || st.say) && !executed.has(idx)) {
        // step did not produce a message in logs → dim as unused
        dim = true;
      }
      if (dim) wrap.classList.add('dimmed');
      return wrap;
    }

    // ---- Shared editors for all step types (single interaction view) ----
    function safeParseJson(text) { try { return JSON.parse(text); } catch (_) { return null; } }

    function appendEditorsForStep(step, container, editable) {
      // ASK
      if (step.ask != null) {
        // name
        const f0 = document.createElement('div'); f0.className = 'field';
        const l0 = document.createElement('div'); l0.className = 'label'; l0.textContent = 'name';
        const i0 = document.createElement('input'); i0.type = 'text'; i0.value = String(step.name || ''); i0.disabled = !editable; if (editable) i0.addEventListener('input', (e) => { const v = e.target.value; if (v) step.name = v; else delete step.name; });
        f0.appendChild(l0); f0.appendChild(i0); container.appendChild(f0);
        const field = document.createElement('div'); field.className = 'field';
        const label = document.createElement('div'); label.className = 'label'; label.textContent = 'ask';
        const ta = document.createElement('textarea'); ta.value = String(step.ask || ''); ta.disabled = !editable; if (editable) ta.addEventListener('input', (e) => { step.ask = e.target.value; });
        field.appendChild(label); field.appendChild(ta); container.appendChild(field);
        const f2 = document.createElement('div'); f2.className = 'field';
        const l2 = document.createElement('div'); l2.className = 'label'; l2.textContent = 'saveAs';
        const i2 = document.createElement('input'); i2.type = 'text'; i2.value = String(step.saveAs || ''); i2.disabled = !editable; if (editable) i2.addEventListener('input', (e) => { const v = e.target.value; if (v) step.saveAs = v; else delete step.saveAs; });
        f2.appendChild(l2); f2.appendChild(i2); container.appendChild(f2);
        // keyboard
        const f3 = document.createElement('div'); f3.className = 'field';
        const l3 = document.createElement('div'); l3.className = 'label'; l3.textContent = 'keyboard';
        const taKb = document.createElement('textarea'); taKb.value = Array.isArray(step.keyboard) ? step.keyboard.join('\n') : ''; taKb.disabled = !editable; if (editable) taKb.addEventListener('input', (e) => { const lines = String(e.target.value || '').split(/\r?\n/).map((s) => s.trim()).filter((s) => s.length > 0); if (lines.length > 0) step.keyboard = lines; else delete step.keyboard; });
        f3.appendChild(l3); f3.appendChild(taKb); container.appendChild(f3);
        // verification
        const f4 = document.createElement('div'); f4.className = 'field';
        const l4 = document.createElement('div'); l4.className = 'label'; l4.textContent = 'verification';
        const verSel = document.createElement('select'); ['','strict'].forEach((v) => { const o = document.createElement('option'); o.value = v; o.textContent = v || '(none)'; verSel.appendChild(o); }); verSel.value = typeof step.verification === 'string' ? step.verification : ''; verSel.style.background = 'rgba(17,24,39,0.6)'; verSel.style.border = '1px solid #1f2937'; verSel.style.color = '#e5e7eb'; verSel.style.borderRadius = '8px'; verSel.style.padding = '4px 6px'; verSel.disabled = !editable; if (editable) verSel.addEventListener('change', () => { const v = verSel.value; if (v) step.verification = v; else delete step.verification; });
        f4.appendChild(l4); f4.appendChild(verSel); container.appendChild(f4);
        return;
      }

      // SAY
      if (step.say != null) {
        // name
        const f0 = document.createElement('div'); f0.className = 'field';
        const l0 = document.createElement('div'); l0.className = 'label'; l0.textContent = 'name';
        const i0 = document.createElement('input'); i0.type = 'text'; i0.value = String(step.name || ''); i0.disabled = !editable; if (editable) i0.addEventListener('input', (e) => { const v = e.target.value; if (v) step.name = v; else delete step.name; });
        f0.appendChild(l0); f0.appendChild(i0); container.appendChild(f0);
        const field = document.createElement('div'); field.className = 'field';
        const label = document.createElement('div'); label.className = 'label'; label.textContent = 'say';
        const ta = document.createElement('textarea'); ta.value = String(step.say || ''); ta.disabled = !editable; if (editable) ta.addEventListener('input', (e) => { step.say = e.target.value; });
        field.appendChild(label); field.appendChild(ta); container.appendChild(field);
        return;
      }

      // WAIT
      if (step.wait != null) {
        const field = document.createElement('div'); field.className = 'field';
        const label = document.createElement('div'); label.className = 'label'; label.textContent = 'seconds';
        const input = document.createElement('input'); input.type = 'number'; input.min = '0'; input.value = String((step.wait && step.wait.seconds) || 0); input.disabled = !editable; if (editable) input.addEventListener('input', () => { const n = Number(input.value); if (!step.wait || typeof step.wait !== 'object') step.wait = {}; step.wait.seconds = Number.isFinite(n) && n >= 0 ? n : 0; });
        field.appendChild(label); field.appendChild(input); container.appendChild(field);
        return;
      }

      // LABEL
      if (step.label != null) {
        const field = document.createElement('div'); field.className = 'field';
        const label = document.createElement('div'); label.className = 'label'; label.textContent = 'label';
        const input = document.createElement('input'); input.type = 'text'; input.value = String(step.label || ''); input.disabled = !editable; if (editable) input.addEventListener('input', (e) => { step.label = e.target.value; });
        field.appendChild(label); field.appendChild(input); container.appendChild(field);
        return;
      }

      // GOTO
      if (step.goto != null) {
        const field = document.createElement('div'); field.className = 'field';
        const label = document.createElement('div'); label.className = 'label'; label.textContent = 'goto';
        const input = document.createElement('input'); input.type = 'text'; input.value = String(step.goto || ''); input.disabled = !editable; if (editable) input.addEventListener('input', (e) => { step.goto = e.target.value; });
        field.appendChild(label); field.appendChild(input); container.appendChild(field);
        return;
      }

      // TRIGGER
      if (step.trigger != null) {
        const field = document.createElement('div'); field.className = 'field';
        const label = document.createElement('div'); label.className = 'label'; label.textContent = 'trigger';
        const input = document.createElement('input'); input.type = 'text'; input.value = String(step.trigger || ''); input.disabled = !editable; if (editable) input.addEventListener('input', (e) => { step.trigger = e.target.value; });
        field.appendChild(label); field.appendChild(input); container.appendChild(field);
        return;
      }

      // SET ATTRIBUTES
      if (step.set_attributes != null) {
        const field = document.createElement('div'); field.className = 'field';
        const label = document.createElement('div'); label.className = 'label'; label.textContent = 'attributes (JSON)';
        const ta = document.createElement('textarea'); ta.value = JSON.stringify(step.set_attributes || {}, null, 2); ta.disabled = !editable; if (editable) ta.addEventListener('blur', () => { const obj = safeParseJson(ta.value); if (obj && typeof obj === 'object') step.set_attributes = obj; });
        field.appendChild(label); field.appendChild(ta); container.appendChild(field);
        return;
      }

      // WEB REQUEST
      if (step.web_request != null) {
        const req = step.web_request || {};
        // url
        const f1 = document.createElement('div'); f1.className = 'field'; const l1 = document.createElement('div'); l1.className = 'label'; l1.textContent = 'url'; const i1 = document.createElement('input'); i1.type = 'text'; i1.value = String(req.url || ''); i1.disabled = !editable; if (editable) i1.addEventListener('input', (e) => { req.url = e.target.value; }); f1.appendChild(l1); f1.appendChild(i1); container.appendChild(f1);
        // method
        const f2 = document.createElement('div'); f2.className = 'field'; const l2 = document.createElement('div'); l2.className = 'label'; l2.textContent = 'method'; const sel = document.createElement('select'); ['GET','POST','PUT','PATCH','DELETE'].forEach((m) => { const o = document.createElement('option'); o.value = m; o.textContent = m; sel.appendChild(o); }); sel.value = req.method || 'GET'; sel.style.background = 'rgba(17,24,39,0.6)'; sel.style.border = '1px solid #1f2937'; sel.style.color = '#e5e7eb'; sel.style.borderRadius = '8px'; sel.style.padding = '4px 6px'; sel.disabled = !editable; if (editable) sel.addEventListener('change', () => { req.method = sel.value; }); f2.appendChild(l2); f2.appendChild(sel); container.appendChild(f2);
        // body JSON
        const f3 = document.createElement('div'); f3.className = 'field'; const l3 = document.createElement('div'); l3.className = 'label'; l3.textContent = 'body JSON'; const ta = document.createElement('textarea'); ta.value = req.body ? JSON.stringify(req.body, null, 2) : ''; ta.disabled = !editable; if (editable) ta.addEventListener('blur', () => { const obj = safeParseJson(ta.value); if (obj != null) req.body = obj; else delete req.body; }); f3.appendChild(l3); f3.appendChild(ta); container.appendChild(f3);
        // saveAs
        const f4 = document.createElement('div'); f4.className = 'field'; const l4 = document.createElement('div'); l4.className = 'label'; l4.textContent = 'saveAs'; const i4 = document.createElement('input'); i4.type = 'text'; i4.value = String(req.saveAs || ''); i4.disabled = !editable; if (editable) i4.addEventListener('input', (e) => { const v = e.target.value; if (v) req.saveAs = v; else delete req.saveAs; }); f4.appendChild(l4); f4.appendChild(i4); container.appendChild(f4);
        step.web_request = req;
        return;
      }

      // SCRIPT
      if (step.script != null) {
        const spec = step.script || {};
        const f1 = document.createElement('div'); f1.className = 'field'; const l1 = document.createElement('div'); l1.className = 'label'; l1.textContent = 'file'; const i1 = document.createElement('input'); i1.type = 'text'; i1.value = String(spec.file || ''); i1.disabled = !editable; if (editable) i1.addEventListener('input', (e) => { spec.file = e.target.value; }); f1.appendChild(l1); f1.appendChild(i1); container.appendChild(f1);
        const f2 = document.createElement('div'); f2.className = 'field'; const l2 = document.createElement('div'); l2.className = 'label'; l2.textContent = 'timeoutMs'; const i2 = document.createElement('input'); i2.type = 'number'; i2.min = '0'; i2.value = String(spec.timeoutMs || ''); i2.disabled = !editable; if (editable) i2.addEventListener('input', () => { const n = Number(i2.value); if (Number.isFinite(n) && n > 0) spec.timeoutMs = n; else delete spec.timeoutMs; }); f2.appendChild(l2); f2.appendChild(i2); container.appendChild(f2);
        step.script = spec;
        return;
      }

      // SHEETS ADD ROW
      if (step.sheets_add_row != null) {
        const cfg = step.sheets_add_row || {};
        const f1 = document.createElement('div'); f1.className = 'field'; const l1 = document.createElement('div'); l1.className = 'label'; l1.textContent = 'config (JSON)'; const ta = document.createElement('textarea'); ta.value = JSON.stringify(cfg, null, 2); ta.disabled = !editable; if (editable) ta.addEventListener('blur', () => { const obj = safeParseJson(ta.value); if (obj && typeof obj === 'object') step.sheets_add_row = obj; }); f1.appendChild(l1); f1.appendChild(ta); container.appendChild(f1);
        const f2 = document.createElement('div'); f2.className = 'field'; const l2 = document.createElement('div'); l2.className = 'label'; l2.textContent = 'saveAs'; const i2 = document.createElement('input'); i2.type = 'text'; i2.value = String((cfg && cfg.saveAs) || ''); i2.disabled = !editable; if (editable) i2.addEventListener('input', (e) => { const v = e.target.value; const obj = step.sheets_add_row || {}; if (v) obj.saveAs = v; else delete obj.saveAs; step.sheets_add_row = obj; }); f2.appendChild(l2); f2.appendChild(i2); container.appendChild(f2);
        return;
      }

      // SHEETS FIND ROW
      if (step.sheets_find_row != null) {
        const cfg = step.sheets_find_row || {};
        const f1 = document.createElement('div'); f1.className = 'field'; const l1 = document.createElement('div'); l1.className = 'label'; l1.textContent = 'config (JSON)'; const ta = document.createElement('textarea'); ta.value = JSON.stringify(cfg, null, 2); ta.disabled = !editable; if (editable) ta.addEventListener('blur', () => { const obj = safeParseJson(ta.value); if (obj && typeof obj === 'object') step.sheets_find_row = obj; }); f1.appendChild(l1); f1.appendChild(ta); container.appendChild(f1);
        const f2 = document.createElement('div'); f2.className = 'field'; const l2 = document.createElement('div'); l2.className = 'label'; l2.textContent = 'saveAs'; const i2 = document.createElement('input'); i2.type = 'text'; i2.value = String((cfg && cfg.saveAs) || ''); i2.disabled = !editable; if (editable) i2.addEventListener('input', (e) => { const v = e.target.value; const obj = step.sheets_find_row || {}; if (v) obj.saveAs = v; else delete obj.saveAs; step.sheets_find_row = obj; }); f2.appendChild(l2); f2.appendChild(i2); container.appendChild(f2);
        return;
      }

      // SHEETS GET ROW
      if (step.sheets_get_row != null) {
        const cfg = step.sheets_get_row || {};
        const f1 = document.createElement('div'); f1.className = 'field'; const l1 = document.createElement('div'); l1.className = 'label'; l1.textContent = 'config (JSON)'; const ta = document.createElement('textarea'); ta.value = JSON.stringify(cfg, null, 2); ta.disabled = !editable; if (editable) ta.addEventListener('blur', () => { const obj = safeParseJson(ta.value); if (obj && typeof obj === 'object') step.sheets_get_row = obj; }); f1.appendChild(l1); f1.appendChild(ta); container.appendChild(f1);
        const f2 = document.createElement('div'); f2.className = 'field'; const l2 = document.createElement('div'); l2.className = 'label'; l2.textContent = 'saveAs'; const i2 = document.createElement('input'); i2.type = 'text'; i2.value = String((cfg && cfg.saveAs) || ''); i2.disabled = !editable; if (editable) i2.addEventListener('input', (e) => { const v = e.target.value; const obj = step.sheets_get_row || {}; if (v) obj.saveAs = v; else delete obj.saveAs; step.sheets_get_row = obj; }); f2.appendChild(l2); f2.appendChild(i2); container.appendChild(f2);
        return;
      }

      // Fallback: details without step_id/filters
      const details = Object.assign({}, step);
      try { delete details.step_id; delete details.filters; } catch (_) {}
      const ro = document.createElement('div'); ro.className = 'field';
      const l = document.createElement('div'); l.className = 'label'; l.textContent = 'details';
      const v = document.createElement('div'); v.textContent = JSON.stringify(details, null, 2);
      ro.appendChild(l); ro.appendChild(v); container.appendChild(ro);
    }

    // ---- Nested filters: parser, serializer, summary, and modal editor ----
    function filtersToNode(filters) {
      if (filters == null) return null;
      const t = typeof filters;
      if (t === 'string') return { type: 'cond', text: String(filters) };
      if (Array.isArray(filters)) {
        const children = filters.map((f) => filtersToNode(f)).filter(Boolean);
        return { type: 'group', op: 'OR', children };
      }
      if (t === 'object') {
        const andArr = Array.isArray(filters.and) ? filters.and : [];
        const children = andArr.map((f) => filtersToNode(f)).filter(Boolean);
        return { type: 'group', op: 'AND', children };
      }
      return null;
    }

    function normalizeNode(node) {
      if (!node) return null;
      if (node.type === 'cond') {
        const txt = String(node.text || '').trim();
        return txt ? { type: 'cond', text: txt } : null;
      }
      if (node.type === 'group') {
        const op = node.op === 'AND' ? 'AND' : 'OR';
        const children = (node.children || []).map(normalizeNode).filter(Boolean);
        const flat = [];
        children.forEach((c) => {
          if (c && c.type === 'group' && c.op === op) flat.push(...(c.children || [])); else flat.push(c);
        });
        if (flat.length === 0) return null;
        if (flat.length === 1) return flat[0];
        return { type: 'group', op, children: flat };
      }
      return null;
    }

    function nodeToFilters(node) {
      const n = normalizeNode(node);
      if (!n) return undefined;
      if (n.type === 'cond') return n.text;
      if (n.type === 'group') {
        const parts = (n.children || []).map(nodeToFilters).filter((x) => x != null);
        if (n.op === 'AND') return { and: parts };
        return parts;
      }
      return undefined;
    }

    function summarizeNode(node) {
      const n = normalizeNode(node);
      if (!n) return '(no filters)';
      if (n.type === 'cond') return n.text;
      const op = n.op;
      const parts = (n.children || []).map((c) => {
        if (c.type === 'cond') return c.text;
        const inner = summarizeNode(c);
        return '(' + inner + ')';
      });
      return parts.join(op === 'AND' ? ' AND ' : ' OR ');
    }

    function buildFiltersEditor(step, editable) {
      const wrap = document.createElement('div');
      wrap.style.display = 'flex'; wrap.style.alignItems = 'center'; wrap.style.gap = '8px';
      function getNode() { return filtersToNode(step.filters); }
      const summary = document.createElement('div'); summary.style.fontSize = '12px'; summary.style.color = '#cbd5e1'; summary.style.maxWidth = '380px'; summary.style.whiteSpace = 'nowrap'; summary.style.overflow = 'hidden'; summary.style.textOverflow = 'ellipsis'; summary.textContent = summarizeNode(getNode());
      const btn = document.createElement('button'); btn.className = 'btn'; btn.textContent = 'Edit filters'; btn.disabled = !editable; btn.addEventListener('click', () => openFiltersModal(step, summary, editable));
      wrap.appendChild(summary); wrap.appendChild(btn); return wrap;
    }

    function openFiltersModal(step, summaryEl, editable) {
      const overlay = document.createElement('div'); overlay.style.position = 'fixed'; overlay.style.inset = '0'; overlay.style.background = 'rgba(0,0,0,0.5)'; overlay.style.zIndex = '1000';
      const dialog = document.createElement('div'); dialog.className = 'panel'; dialog.style.position = 'absolute'; dialog.style.top = '10%'; dialog.style.left = '50%'; dialog.style.transform = 'translateX(-50%)'; dialog.style.width = 'min(860px, 92vw)'; dialog.style.maxHeight = '80vh'; dialog.style.overflow = 'auto'; dialog.style.padding = '12px';
      const header = document.createElement('div'); header.className = 'flow-header';
      const title = document.createElement('div'); title.className = 'flow-title'; title.textContent = 'Edit Filters';
      const actions = document.createElement('div'); actions.className = 'toolbar'; const btnClose = document.createElement('button'); btnClose.className = 'btn'; btnClose.textContent = 'Close'; actions.appendChild(btnClose); header.appendChild(title); header.appendChild(actions);
      const body = document.createElement('div'); body.className = 'steps';
      let node = filtersToNode(step.filters) || { type: 'group', op: 'AND', children: [] };

      function buildNodeEditor(n) {
        if (!n || n.type === 'cond') {
          const line = document.createElement('div'); line.className = 'field';
          const l = document.createElement('div'); l.className = 'label'; l.textContent = 'condition';
          const ta = document.createElement('textarea'); ta.value = String((n && n.text) || ''); ta.disabled = !editable; if (editable) ta.addEventListener('input', (e) => { if (n) n.text = e.target.value; });
          line.appendChild(l); line.appendChild(ta); return line;
        }
        const box = document.createElement('div'); box.className = 'step';
        const head = document.createElement('div'); head.style.display = 'flex'; head.style.alignItems = 'center'; head.style.gap = '8px'; head.style.marginBottom = '8px';
        const opLabel = document.createElement('div'); opLabel.className = 'label'; opLabel.textContent = 'Operator';
        const opSel = document.createElement('select'); ['AND','OR'].forEach((k) => { const o = document.createElement('option'); o.value = k; o.textContent = k; opSel.appendChild(o); }); opSel.value = n.op === 'OR' ? 'OR' : 'AND'; opSel.style.background = 'rgba(17,24,39,0.6)'; opSel.style.border = '1px solid #1f2937'; opSel.style.color = '#e5e7eb'; opSel.style.borderRadius = '8px'; opSel.style.padding = '4px 6px'; opSel.disabled = !editable; if (editable) opSel.addEventListener('change', () => { n.op = opSel.value; });
        head.appendChild(opLabel); head.appendChild(opSel); box.appendChild(head);
        const childWrap = document.createElement('div'); childWrap.style.display = 'grid'; childWrap.style.gap = '8px';
        function renderChildren() {
          childWrap.innerHTML = '';
          (n.children || []).forEach((c, idx) => {
            const row = document.createElement('div'); row.className = 'field';
            const controls = document.createElement('div'); controls.className = 'label';
            const btnUp = document.createElement('button'); btnUp.className = 'btn'; btnUp.textContent = '↑'; btnUp.style.marginRight = '4px'; btnUp.disabled = idx === 0 || !editable;
            const btnDown = document.createElement('button'); btnDown.className = 'btn'; btnDown.textContent = '↓'; btnDown.style.marginRight = '4px'; btnDown.disabled = idx >= (n.children.length - 1) || !editable;
            const btnDel = document.createElement('button'); btnDel.className = 'btn'; btnDel.textContent = 'Delete'; btnDel.disabled = !editable;
            if (editable) { btnUp.addEventListener('click', () => { const t = n.children[idx-1]; n.children[idx-1] = n.children[idx]; n.children[idx] = t; renderChildren(); }); btnDown.addEventListener('click', () => { const t = n.children[idx+1]; n.children[idx+1] = n.children[idx]; n.children[idx] = t; renderChildren(); }); btnDel.addEventListener('click', () => { n.children.splice(idx, 1); renderChildren(); }); }
            controls.appendChild(btnUp); controls.appendChild(btnDown); controls.appendChild(btnDel);
            const editor = buildNodeEditor(c);
            row.appendChild(controls); row.appendChild(editor);
            childWrap.appendChild(row);
          });
        }
        const addRow = document.createElement('div'); addRow.style.display = 'flex'; addRow.style.gap = '8px'; addRow.style.marginTop = '8px';
        const btnAddCond = document.createElement('button'); btnAddCond.className = 'btn'; btnAddCond.textContent = 'Add condition'; btnAddCond.disabled = !editable;
        const btnAddGroup = document.createElement('button'); btnAddGroup.className = 'btn'; btnAddGroup.textContent = 'Add subgroup'; btnAddGroup.disabled = !editable;
        if (editable) { btnAddCond.addEventListener('click', () => { n.children = n.children || []; n.children.push({ type: 'cond', text: '' }); renderChildren(); }); btnAddGroup.addEventListener('click', () => { n.children = n.children || []; n.children.push({ type: 'group', op: 'AND', children: [] }); renderChildren(); }); }
        addRow.appendChild(btnAddCond); addRow.appendChild(btnAddGroup);
        renderChildren(); box.appendChild(childWrap); box.appendChild(addRow); return box;
      }

      const editorEl = buildNodeEditor(node);
      const footer = document.createElement('div'); footer.className = 'footer';
      const hint = document.createElement('div'); hint.className = 'hint'; hint.textContent = 'Variables must be written as {{variable}}.';
      const buttons = document.createElement('div'); const btnClear = document.createElement('button'); btnClear.className = 'btn'; btnClear.textContent = 'Clear'; const btnSave = document.createElement('button'); btnSave.className = 'btn primary'; btnSave.textContent = 'Save'; buttons.appendChild(btnClear); buttons.appendChild(btnSave); footer.appendChild(hint); footer.appendChild(buttons);
      btnClose.addEventListener('click', () => overlay.remove());
      btnClear.addEventListener('click', () => { node = { type: 'group', op: 'AND', children: [] }; const repl = buildNodeEditor(node); editorEl.replaceWith(repl); body.insertBefore(repl, footer); });
      btnSave.addEventListener('click', () => { step.filters = nodeToFilters(node); if (summaryEl) summaryEl.textContent = summarizeNode(filtersToNode(step.filters)); overlay.remove(); });
      dialog.appendChild(header); dialog.appendChild(body); body.appendChild(editorEl); dialog.appendChild(footer); overlay.appendChild(dialog); document.body.appendChild(overlay);
    }

    function formatTimeHM2(d) {
      if (!d) return '';
      const hh = String(d.getHours()).padStart(2, '0');
      const mm = String(d.getMinutes()).padStart(2, '0');
      return `${hh}:${mm}`;
    }

    async function renderSingleInteraction(snap, opts = {}) {
      els.viewList.style.display = 'none';
      els.viewSingle.style.display = '';
      const d = snap.data();
      if (!opts.reuseLoaded) {
        await loadSingleFlow(d.flow_key);
      }
      // Apply in-memory overrides (e.g., added steps) if any
      if (flowOverrides.has(d.flow_key)) {
        const defOverride = flowOverrides.get(d.flow_key);
        if (flowDoc && flowDoc.flows) flowDoc.flows[d.flow_key] = defOverride;
      }
      // Capture latest (current) flow's updated_at for comparison
      let latestDef = flowDoc && flowDoc.flows ? flowDoc.flows[d.flow_key] : null;
      const latestUpdatedAt = (latestDef && typeof latestDef.updated_at === 'string') ? latestDef.updated_at : '';
      // If a specific version is logged, try to load that backup first
      let flow = null;
      const desiredVersion = (d && typeof d.flow_version === 'string') ? d.flow_version : '';
      if (desiredVersion) {
        try {
          const { bucket } = getCfg();
          const key = d.flow_key;
          if (bucket && key) {
            const objectName = `flows/backups/${key}_${desiredVersion}.json`;
            loadStoredTokenOnly();
            if (hasValidToken()) {
              const res = await fetch(gcsDownloadUrl(bucket, objectName), { headers: { Authorization: `Bearer ${oauth.accessToken}` }, cache: 'no-store' });
              if (res.ok) {
                const json = await res.json();
                let def = null;
                if (json && json.flows && json.flows[key]) def = json.flows[key]; else if (json && json[key]) def = json[key]; else def = json;
                if (def && typeof def === 'object') {
                  flowDoc = { flows: { [key]: def } };
                }
              }
            }
          }
        } catch (_) {}
      }
      flow = flowDoc && flowDoc.flows ? flowDoc.flows[d.flow_key] : null;
      const stepsLogs = Array.isArray(d.steps) ? d.steps : [];
      // Ensure link goes to the editor with flow param
      els.btnOpenEditor.href = buildUrlWithAuth('editor', { flow: d.flow_key });

      // If flow not found, show a note
      if (!flow) {
        els.flowTitle.textContent = `${d.flow_key} (not found in flow.json)`;
      }

      // Right/messages: switch to synced grid rows under left panel; hide old right column
      els.singleMessages.innerHTML = '';
      const rightCol = document.querySelector('.right-messages');
      if (rightCol) rightCol.style.display = 'none';
      const convMap = await fetchMessagesForRequestMap(d.chat_id, d.request_id).catch(() => new Map());

      function toDate(val) {
        if (!val) return null;
        if (typeof val.toDate === 'function') return val.toDate();
        return new Date(val);
      }

      function getWhen(s) {
        if (!s) return null;
        if (s.type === 'message') return toDate(s.date);
        return toDate(s.date);
      }

      // Build groups: -1 for trigger (step_index == null), 0..N-1 for steps
      const groups = new Map();
      const pushToGroup = (idx, entry) => {
        const key = Number.isFinite(idx) ? idx : -1;
        if (!groups.has(key)) groups.set(key, []);
        groups.get(key).push(entry);
      };

      (stepsLogs || []).forEach((s) => {
        const idx = Number.isFinite(s.step_index) ? s.step_index : -1;
        pushToGroup(idx, s);
      });

      // Helper to render one entry line inside a step group
      function renderEntry(s) {
        const line = document.createElement('div'); line.className = 'msg';
        const when = getWhen(s);
        const meta = document.createElement('div'); meta.className = 'meta';
        if (s.type === 'message') {
          const msg = convMap.get(String(s.message_id));
          meta.textContent = `${formatTimeHM2(when)} · ${s.from} · step #${s.step_index}`;
          const body = document.createElement('div');
          body.textContent = msg && typeof msg.contents === 'string' ? msg.contents : `(message_id=${s.message_id})`;
          line.appendChild(meta); line.appendChild(body);
        } else if (s.type === 'goto') {
          const idx = Number.isFinite(s.step_index) ? ` · step #${s.step_index}` : '';
          meta.textContent = `${formatTimeHM2(when)} · GOTO → ${s.label}${idx}`;
          line.appendChild(meta);
        } else if (s.type === 'version_switch') {
          const idx = Number.isFinite(s.step_index) ? ` · step #${s.step_index}` : '';
          const a = document.createElement('a');
          a.href = buildUrlWithAuth('interactions', { request_id: s.new_request_id });
          a.textContent = s.new_request_id;
          meta.textContent = `${formatTimeHM2(when)} · version_switch → `;
          meta.appendChild(a);
          const v = document.createElement('div'); v.textContent = `from ${s.from_version || '(?)'} to ${s.to_version || '(?)'}${idx}`;
          line.appendChild(meta); line.appendChild(v);
        } else if (s.type === 'trigger') {
          const idx = Number.isFinite(s.step_index) ? ` · step #${s.step_index}` : '';
          meta.textContent = `${formatTimeHM2(when)} · trigger → ${s.triggered_flow_key} child=${s.child_request_id}${idx}`;
          line.appendChild(meta);
        } else if (s.type === 'set_attributes') {
          const updates = s.updates && typeof s.updates === 'object' ? s.updates : {};
          const pairs = Object.entries(updates).map(([k, v]) => `${k} = ${String(v)}`);
          meta.textContent = `${formatTimeHM2(when)} · set_attributes`;
          const body = document.createElement('div'); body.textContent = pairs.join(', ');
          line.appendChild(meta); line.appendChild(body);
        } else {
          meta.textContent = `${formatTimeHM2(when)} · ${s.type || 'action'}`;
          const body = document.createElement('div'); body.textContent = JSON.stringify(s);
          line.appendChild(meta); line.appendChild(body);
        }
        return line;
      }

      // Build synced rows grid inside left panel
      els.flowSteps.innerHTML = '';
      // Version header with description and date + ability to edit description
      const header = document.createElement('div'); header.className = 'step';
      const rowTop = document.createElement('div'); rowTop.style.display = 'flex'; rowTop.style.alignItems = 'center'; rowTop.style.justifyContent = 'space-between';
      const leftMeta = document.createElement('div');
      const versionTs = (flow && typeof flow.updated_at === 'string') ? flow.updated_at : '';
      const isCurrent = (desiredVersion && desiredVersion.length > 0) ? (desiredVersion === latestUpdatedAt) : false;
      leftMeta.textContent = `${(versionTs || '').replace('T', ' ').replace('_', ':').replace('Z', ' UTC')}${isCurrent ? ' · current' : ''}`;
      const rightEdit = document.createElement('div');
      // If the new run references a previous interaction via trigger.previous_request_id, show link
      if (stepsLogs && stepsLogs.length > 0) {
        const firstTrig = stepsLogs.find((s) => s && s.type === 'trigger' && typeof s.previous_request_id === 'string' && s.previous_request_id);
        if (firstTrig) {
          const prev = document.createElement('a'); prev.className = 'btn'; prev.textContent = 'Previous interaction'; prev.href = buildUrlWithAuth('interactions', { request_id: firstTrig.previous_request_id });
          rightEdit.appendChild(prev);
        }
      }
      const descWrap = document.createElement('div'); descWrap.className = 'field'; descWrap.style.marginTop = '8px';
      const descLabel = document.createElement('div'); descLabel.className = 'label'; descLabel.textContent = 'Description';
      const descInput = document.createElement('input'); descInput.type = 'text'; descInput.value = String((flow && flow.description) || ''); descInput.disabled = !isCurrent; if (isCurrent) descInput.addEventListener('input', (e) => { if (flow) flow.description = e.target.value; });
      descWrap.appendChild(descLabel); descWrap.appendChild(descInput);
      rowTop.appendChild(leftMeta); rowTop.appendChild(rightEdit);
      header.appendChild(rowTop); header.appendChild(descWrap);
      els.flowSteps.appendChild(header);
      const grid = document.createElement('div'); grid.className = 'steps-grid';

      const stepDefs = (flow && Array.isArray(flow.steps)) ? flow.steps : [];
      const executed = buildExecutedIndicesFromLogs(stepsLogs);
      const gotoUsed = flow ? buildGotoUsageIndexes(flow, stepsLogs) : new Set();

      // Row 0: Flow trigger (left label + right logs)
      const triggerGroup = (groups.get(-1) || []).slice().sort((a, b) => (getWhen(a) || 0) - (getWhen(b) || 0));
      const triggerLeft = document.createElement('div'); triggerLeft.className = 'cell left';
      const triggerBadge = document.createElement('span'); triggerBadge.className = 'badge'; triggerBadge.textContent = 'TRIGGER';
      triggerLeft.appendChild(triggerBadge);
      const triggerRight = document.createElement('div'); triggerRight.className = 'cell right';
      if (triggerGroup.length === 0) {
        const empty = document.createElement('div'); empty.style.color = '#94a3b8'; empty.textContent = '(no logs)';
        triggerRight.appendChild(empty);
      } else {
        triggerGroup.forEach((s) => triggerRight.appendChild(renderEntry(s)));
      }
      grid.appendChild(triggerLeft);
      grid.appendChild(triggerRight);

      // Single interaction view does not allow adding steps

      // Rows for each step
      for (let i = 0; i < stepDefs.length; i++) {
        const st = stepDefs[i] || {};
        const leftCell = document.createElement('div'); leftCell.className = 'cell left';
        leftCell.appendChild(buildStepLeftElement(st, i, executed, gotoUsed, isCurrent));

        const rightCell = document.createElement('div'); rightCell.className = 'cell right';
        const entries = (groups.get(i) || []).slice().sort((a, b) => (getWhen(a) || 0) - (getWhen(b) || 0));
        if (entries.length === 0) {
          const empty = document.createElement('div'); empty.style.color = '#94a3b8'; empty.textContent = '(no logs)';
          rightCell.appendChild(empty);
        } else {
          entries.forEach((s) => rightCell.appendChild(renderEntry(s)));
        }
        grid.appendChild(leftCell);
        grid.appendChild(rightCell);

        // Single interaction view does not allow adding steps
      }

      els.flowSteps.appendChild(grid);

      // Publish button: upload current single flow file to Cloud with backup
      const btnPublish = document.getElementById('btnPublish');
      if (btnPublish && !btnPublish.dataset.boundPublish) {
        btnPublish.dataset.boundPublish = '1';
        btnPublish.addEventListener('click', async () => {
          try {
            if (!flowDoc || !flow) return;
            loadStoredTokenOnly();
            const prev = btnPublish.textContent;
            btnPublish.textContent = 'Saving…'; btnPublish.disabled = true;
            if (!hasValidToken()) throw new Error('Missing or expired token');
            const { bucket } = getCfg();
            if (!bucket) throw new Error('Missing bucket');
            const token = oauth.accessToken;
            const key = d.flow_key;
            const mainPath = `flows/${key}.json`;

            // 1) Read current file and back it up if present, using its own updated_at
            let currentText = null;
            let previousUpdatedAt = '';
            try {
              const getRes = await fetch(gcsDownloadUrl(bucket, mainPath), { headers: { Authorization: `Bearer ${token}` }, cache: 'no-store' });
              if (getRes.ok) currentText = await getRes.text();
            } catch (_) {}
            if (currentText != null) {
              try {
                try {
                  const json = JSON.parse(currentText);
                  let prevDef = null;
                  if (json && json.flows && json.flows[key]) prevDef = json.flows[key];
                  else if (json && json[key]) prevDef = json[key];
                  else prevDef = json;
                  if (prevDef && typeof prevDef.updated_at === 'string') previousUpdatedAt = prevDef.updated_at;
                } catch (_) {}
                const tsForBackup = previousUpdatedAt || formatUtcNowForFlow();
                const backupName = formatBackupName(key, tsForBackup);
                const upBackup = await fetch(gcsUploadUrl(bucket, backupName), {
                  method: 'POST',
                  headers: { 'Authorization': `Bearer ${token}`, 'Content-Type': 'application/json' },
                  body: currentText
                });
                if (!upBackup.ok) console.warn('Backup upload failed');
              } catch (_) {}
            }

            // 2) Upload new content (single-flow def)
            const url = gcsUploadUrl(bucket, mainPath);
            const newTimestampUtc = formatUtcNowForFlow();
            try { flow.updated_at = newTimestampUtc; } catch (_) {}
            // Ensure each step has a unique 8-char step_id before saving
            try {
              const existing = new Set();
              function genId() {
                const alphabet = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
                let out = '';
                for (let i = 0; i < 8; i++) out += alphabet.charAt(Math.floor(Math.random() * alphabet.length));
                return out;
              }
              if (flow && Array.isArray(flow.steps)) {
                flow.steps.forEach((s) => { if (s && typeof s.step_id === 'string' && s.step_id.length > 0) existing.add(s.step_id); });
                flow.steps.forEach((s) => {
                  if (!s || (typeof s.step_id === 'string' && s.step_id.length > 0)) return;
                  let id = '';
                  do { id = genId(); } while (existing.has(id));
                  s.step_id = id;
                  existing.add(id);
                });
              }
            } catch (_) {}
            // Allow editing description before publish: if the left panel UI allowed edits, they are already in 'flow'
            const body = JSON.stringify(flow, null, 2);
            const res = await fetch(url, {
              method: 'POST',
              headers: {
                'Authorization': `Bearer ${token}`,
                'Content-Type': 'application/json; charset=utf-8'
              },
              body
            });
            const ok = res.ok;
            // 3) Update versions file within flows prefix (flows/versions.txt)
            if (ok) {
              try {
                const versionsPath = 'flows/versions.txt';
                let existing = '';
                try {
                  const resV = await fetch(gcsDownloadUrl(bucket, versionsPath), { headers: { Authorization: `Bearer ${token}` }, cache: 'no-store' });
                  if (resV.ok) existing = await resV.text();
                } catch (_) {}
                const map = {};
                String(existing || '')
                  .split(/\r?\n/)
                  .map((l) => l.trim())
                  .filter((l) => l && !l.startsWith('#') && !l.startsWith('//'))
                  .forEach((line) => {
                    const idx = line.indexOf('=');
                    if (idx <= 0) return;
                    const k = line.slice(0, idx).trim();
                    const v = line.slice(idx + 1).trim();
                    if (k) map[k] = v;
                  });
                map[key] = newTimestampUtc;
                const bodyV = Object.entries(map).map(([k, v]) => `${k}=${v}`).join('\n') + '\n';
                await fetch(gcsUploadUrl(bucket, versionsPath), {
                  method: 'POST',
                  headers: { 'Authorization': `Bearer ${token}`, 'Content-Type': 'text/plain; charset=utf-8' },
                  body: bodyV
                });
              } catch (_) {}
            }
            btnPublish.textContent = ok ? 'Published ✓' : 'Publish failed';
            setTimeout(() => { btnPublish.textContent = prev; btnPublish.disabled = false; }, 1400);
          } catch (err) {
            console.error('Publish error:', err);
            const prev = btnPublish.textContent;
            btnPublish.textContent = 'Publish failed';
            setTimeout(() => { btnPublish.textContent = prev; btnPublish.disabled = false; }, 1400);
          }
        });
      }
    }

    function renderRuns(docs, { prepend } = { prepend: false }) {
      const frag = document.createDocumentFragment();
      docs.forEach((doc) => {
        const d = doc.data();
        const div = document.createElement('div');
        div.className = 'run';
        const trigAt = d.flow_trigger && d.flow_trigger.triggered_at ? (typeof d.flow_trigger.triggered_at.toDate === 'function' ? d.flow_trigger.triggered_at.toDate() : new Date(d.flow_trigger.triggered_at)) : null;
        const meta = document.createElement('div');
        meta.className = 'meta';
        const reqLink = `<a href="${buildUrlWithAuth('interactions', { request_id: d.request_id })}">${d.request_id}</a>`;
        const chatLink = `<a href="${buildUrlWithAuth('conversations', { user_id: d.chat_id })}">${d.chat_id}</a>`;
        meta.innerHTML = `${trigAt ? trigAt.toLocaleString() : ''} · request: ${reqLink} · user: ${chatLink} · flow: ${d.flow_key}`;

        div.appendChild(meta);

        // expandable details (lazy-loaded)
        const details = document.createElement('div');
        details.className = 'steps';
        details.style.display = 'none';
        div.appendChild(details);

        function buildDetailsOnce() {
          if (details.dataset.loaded === '1') return;
          details.dataset.loaded = '1';
          const steps = Array.isArray(d.steps) ? d.steps : [];
          if (steps.length === 0) return;
          // placeholder lines first
          const lines = steps.map((s) => {
            const line = document.createElement('div');
            line.className = 'step';
            if (s.type === 'message') {
              const when = s && s.date && typeof s.date.toDate === 'function' ? s.date.toDate() : (s && s.date ? new Date(s.date) : null);
              const time = formatTimeHM(when);
              const fromLabel = s.from === 'user' ? 'User' : 'Bot';
              line.textContent = `${time} ${fromLabel}: …`;
              line.dataset.msgId = String(s.message_id);
              line.dataset.from = fromLabel;
            } else if (s.type === 'set_attributes') {
              const when = s && s.date && typeof s.date.toDate === 'function' ? s.date.toDate() : (s && s.date ? new Date(s.date) : null);
              const time = formatTimeHM(when);
              const updates = s.updates && typeof s.updates === 'object' ? s.updates : {};
              const pairs = Object.entries(updates).map(([k, v]) => `${k} = ${String(v)}`);
              line.textContent = `${time} set_attributes: ${pairs.join(', ')}`.trim();
            } else if (s.type === 'trigger') {
              const when = s && s.date && typeof s.date.toDate === 'function' ? s.date.toDate() : (s && s.date ? new Date(s.date) : null);
              const time = formatTimeHM(when);
              const idx = Number.isFinite(s.step_index) ? ` · step #${s.step_index}` : '';
              line.textContent = `${time} trigger -> ${s.triggered_flow_key} child=${s.child_request_id}${idx}`.trim();
            } else if (s.type === 'trigger') {
              const when = s && s.date && typeof s.date.toDate === 'function' ? s.date.toDate() : (s && s.date ? new Date(s.date) : null);
              const time = formatTimeHM(when);
              const idx = Number.isFinite(s.step_index) ? ` · step #${s.step_index}` : '';
              line.textContent = `${time} trigger -> ${s.triggered_flow_key} child=${s.child_request_id}${idx}`.trim();
            } else if (s.type === 'goto') {
              const when = s && s.date && typeof s.date.toDate === 'function' ? s.date.toDate() : (s && s.date ? new Date(s.date) : null);
              const time = formatTimeHM(when);
              const idx = Number.isFinite(s.step_index) ? ` · step #${s.step_index}` : '';
              line.textContent = `${time} goto -> ${s.label}${idx}`.trim();
            } else {
              line.textContent = JSON.stringify(s);
            }
            return line;
          });
          lines.forEach((ln) => details.appendChild(ln));
          // enrich message lines in batch per request
          fetchMessagesForRequestMap(d.chat_id, d.request_id).then((map) => {
            lines.forEach((ln) => {
              const id = ln.dataset.msgId;
              if (!id) return;
              const msg = map.get(String(id));
              const t = formatTimeHM(msg && msg.date);
              const fromLabel = ln.dataset.from || '';
              const content = msg && typeof msg.contents === 'string' ? msg.contents : `(message_id=${id})`;
              ln.textContent = `${t || ''} ${fromLabel}: ${content}`.trim();
            });
          }).catch(() => {
            // fallback to single fetches
            lines.forEach((ln) => {
              const id = ln.dataset.msgId;
              const fromLabel = ln.dataset.from || '';
              if (!id) return;
              fetchConversationMessage(d.chat_id, id).then((msg) => {
                const t = formatTimeHM(msg && msg.date);
                const content = msg && typeof msg.contents === 'string' ? msg.contents : `(message_id=${id})`;
                ln.textContent = `${t || ''} ${fromLabel}: ${content}`.trim();
              }).catch(() => {});
            });
          });
        }

        // toggle expand/collapse on click, ignore anchor clicks
        div.addEventListener('click', (ev) => {
          if (ev.target && ev.target.closest && ev.target.closest('a')) return;
          const isShown = details.style.display !== 'none';
          if (isShown) {
            details.style.display = 'none';
          } else {
            buildDetailsOnce();
            details.style.display = '';
          }
        });

        frag.appendChild(div);
      });

      if (prepend) {
        const prevHeight = els.list.scrollHeight;
        els.list.insertBefore(frag, els.list.firstChild);
        const newHeight = els.list.scrollHeight;
        els.list.scrollTop += (newHeight - prevHeight);
      } else {
        els.list.innerHTML = '';
        els.list.appendChild(frag);
        // jump to bottom so newest is visible
        els.list.scrollTop = els.list.scrollHeight;
      }
    }

    function buildRunsQuery({ requestId, userId, startDate, endDate }) {
      const col = collection(db, 'interactions');
      const constraints = [];
      if (requestId) constraints.push(where('request_id', '==', requestId));
      if (userId) constraints.push(where('chat_id', '==', coerce(userId)));
      // order by trigger time desc and filter using Date objects (timestamp fields)
      constraints.push(orderBy('flow_trigger.triggered_at', 'desc'));
      if (startDate) constraints.push(where('flow_trigger.triggered_at', '>=', startDate));
      if (endDate) {
        const end = new Date(endDate.getTime());
        end.setHours(23,59,59,999);
        constraints.push(where('flow_trigger.triggered_at', '<=', end));
      }
      constraints.push(limit(paging.pageSize));
      if (paging.last) constraints.push(startAfter(paging.last));
      return query(col, ...constraints);
    }

    async function loadInitial() {
      const requestId = els.inpRequestId.value.trim();
      const userId = els.inpUserId.value.trim();
      paging = { last: null, done: false, pageSize: 30 };
      const s = els.inpStart.value ? new Date(els.inpStart.value) : null;
      const e = els.inpEnd.value ? new Date(els.inpEnd.value) : null;

      if (requestId) {
        // load a single doc view
        const docRef = doc(db, 'interactions', requestId);
        const snap = await getDoc(docRef);
        if (!snap.exists()) { renderEmpty(); return; }
        els.viewList.style.display = 'none';
        await renderSingleInteraction(snap);
        return;
      }

      const q = buildRunsQuery({ requestId, userId, startDate: s, endDate: e });
      const snap = await getDocs(q);
      if (snap.empty) { renderEmpty(); return; }
      const docsDesc = snap.docs;
      paging.last = docsDesc[docsDesc.length - 1];
      const docsAsc = docsDesc.slice().reverse();
      els.viewSingle.style.display = 'none';
      els.viewList.style.display = '';
      renderRuns(docsAsc, { prepend: false });
    }

    async function loadMore() {
      if (paging.done) return;
      const requestId = els.inpRequestId.value.trim();
      if (requestId) { paging.done = true; return; }
      const userId = els.inpUserId.value.trim();
      const s = els.inpStart.value ? new Date(els.inpStart.value) : null;
      const e = els.inpEnd.value ? new Date(els.inpEnd.value) : null;
      const q = buildRunsQuery({ requestId, userId, startDate: s, endDate: e });
      const snap = await getDocs(q);
      if (snap.empty) { paging.done = true; return; }
      const docsDesc = snap.docs;
      paging.last = docsDesc[docsDesc.length - 1];
      const docsAsc = docsDesc.slice().reverse();
      renderRuns(docsAsc, { prepend: true });
    }

    els.list.addEventListener('scroll', () => {
      // Load older runs when the user scrolls near the top
      if (els.list.scrollTop < 80) {
        loadMore();
      }
    });

    els.btnApply.addEventListener('click', () => {
      const u = new URL(location.href);
      const rid = els.inpRequestId.value.trim();
      const uid = els.inpUserId.value.trim();
      const s = els.inpStart.value.trim();
      const e = els.inpEnd.value.trim();
      if (rid) u.searchParams.set('request_id', rid); else u.searchParams.delete('request_id');
      if (uid) u.searchParams.set('user_id', uid); else u.searchParams.delete('user_id');
      if (s) u.searchParams.set('start', s); else u.searchParams.delete('start');
      if (e) u.searchParams.set('end', e); else u.searchParams.delete('end');
      history.replaceState(null, '', u.toString());
      loadInitial();
    });
    document.getElementById('btnReload').addEventListener('click', loadInitial);

    // update header link with auth params
    (function updateHeaderLinks(){
      const l = document.getElementById('lnkConversations');
      if (l) l.href = buildUrlWithAuth('conversations', {});
    })();

    onAuthStateChanged(auth, async (user) => {
      if (!user) await signInAnonymously(auth);
      await loadInitial();
    });
  </script>
</body>
</html>


