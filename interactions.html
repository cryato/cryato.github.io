<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Interactions Viewer</title>
  <style>
    :root { --bg: #0f172a; --panel: #111827; --muted: #94a3b8; --text: #e5e7eb; --primary: #22d3ee; --accent: #8b5cf6; }
    html, body { height: 100%; }
    body { margin: 0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica Neue, Arial; background: linear-gradient(180deg, #0b1022 0%, #0f172a 100%); color: var(--text); }
    header { display: flex; align-items: center; justify-content: space-between; padding: 12px 16px; border-bottom: 1px solid #1f2937; position: sticky; top: 0; background: rgba(17,24,39,0.6); backdrop-filter: blur(8px); z-index: 10; }
    header h1 { font-size: 16px; margin: 0; }
    .toolbar { display: flex; gap: 8px; align-items: center; }
    input[type="text"], input[type="date"] { background: rgba(17,24,39,0.6); border: 1px solid #1f2937; color: var(--text); padding: 8px 10px; border-radius: 8px; outline: none; font-size: 13px; }
    .btn { appearance: none; border: 1px solid #283449; background: linear-gradient(180deg, #0b1224 0%, #0a1222 100%); color: #e5e7eb; border-radius: 8px; padding: 8px 12px; font-size: 13px; cursor: pointer; }
    .container { display: grid; grid-template-columns: 360px 1fr; gap: 16px; padding: 16px; }
    .panel { background: rgba(17,24,39,0.65); border: 1px solid #1f2937; border-radius: 12px; }
    .left { padding: 12px; }
    .field { display: grid; grid-template-columns: 120px 1fr; align-items: center; gap: 8px; margin: 8px 0; }
    .label { color: var(--muted); font-size: 12px; }
    .list { height: calc(100vh - 120px); overflow: auto; padding: 12px; }
    .run { border: 1px solid #1f2937; background: rgba(2,6,23,0.55); border-radius: 10px; padding: 10px; margin: 8px 0; }
    .meta { color: var(--muted); font-size: 12px; margin-bottom: 6px; display: flex; gap: 8px; flex-wrap: wrap; }
    .steps { margin-top: 10px; padding-left: 6px; border-left: 2px solid #334155; }
    .step { font-size: 12px; color: #cbd5e1; margin: 6px 0; }
    a { color: #93c5fd; }
    .empty { color: var(--muted); padding: 16px; }
  </style>
</head>
<body>
  <header>
    <h1>Interactions</h1>
    <div class="toolbar">
      <button id="btnReload" class="btn">Reload</button>
      <a id="lnkConversations" class="btn" href="#">Conversations</a>
    </div>
  </header>

  <div class="container">
    <div class="panel left">
      <div class="field">
        <div class="label">Request ID</div>
        <input id="inpRequestId" type="text" placeholder="request_id (optional)" />
      </div>
      <div class="field">
        <div class="label">Customer ID</div>
        <input id="inpUserId" type="text" placeholder="user_id (optional)" />
      </div>
      <div class="field">
        <div class="label">Start</div>
        <input id="inpStart" type="date" />
      </div>
      <div class="field">
        <div class="label">End</div>
        <input id="inpEnd" type="date" />
      </div>
      <div class="field">
        <div></div>
        <button id="btnApply" class="btn">Apply</button>
      </div>
      <div style="margin-top:12px; color: var(--muted); font-size: 12px;"></div>
    </div>
    <div class="panel">
      <div id="list" class="list"></div>
    </div>
  </div>

  <script type="module">
    import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.12.5/firebase-app.js';
    import { getAuth, signInAnonymously, onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/10.12.5/firebase-auth.js';
    import { getFirestore, collection, query, where, orderBy, limit, startAfter, Timestamp, getDocs, doc, getDoc } from 'https://www.gstatic.com/firebasejs/10.12.5/firebase-firestore.js';

    function readCookie(name) {
      const match = document.cookie.match(new RegExp('(?:^|; )' + name.replace(/([.$?*|{}()\[\]\\\/\+^])/g, '\\$1') + '=([^;]*)'));
      return match ? decodeURIComponent(match[1]) : '';
    }
    function getConfig() {
      const u = new URL(location.href);
      const p = (k) => u.searchParams.get(k) || '';
      return {
        apiKey: p('apiKey') || readCookie('apiKey') || '',
        authDomain: p('authDomain') || readCookie('authDomain') || '',
        projectId: p('projectId') || readCookie('projectId') || ''
      };
    }
    function buildUrlWithAuth(path, extraParams) {
      const params = new URLSearchParams();
      // Only include context-specific extras; do NOT carry auth params anymore
      Object.entries(extraParams || {}).forEach(([k, v]) => {
        if (v != null && String(v).length > 0) params.set(k, String(v));
      });
      const qs = params.toString();
      return qs ? `${path}?${qs}` : path;
    }


    const cfg = getConfig();
    const app = initializeApp({ apiKey: cfg.apiKey, authDomain: cfg.authDomain, projectId: cfg.projectId });
    const auth = getAuth(app);
    const db = getFirestore(app);

    const els = {
      inpRequestId: document.getElementById('inpRequestId'),
      inpUserId: document.getElementById('inpUserId'),
      inpStart: document.getElementById('inpStart'),
      inpEnd: document.getElementById('inpEnd'),
      btnApply: document.getElementById('btnApply'),
      btnReload: document.getElementById('btnReload'),
      list: document.getElementById('list')
    };

    // Caches
    const conversationsCache = new Map(); // key: chatId_messageId -> Promise(data|null)
    const requestMessagesCache = new Map(); // key: requestId -> Promise<Map(message_id -> data)>

    function formatTimeHM(input) {
      if (!input) return '';
      const d = (input && typeof input.toDate === 'function') ? input.toDate() : (input instanceof Date ? input : new Date(input));
      if (!Number.isFinite(d.getTime())) return '';
      const hh = String(d.getHours()).padStart(2, '0');
      const mm = String(d.getMinutes()).padStart(2, '0');
      return `${hh}:${mm}`;
    }

    async function fetchConversationMessage(chatId, messageId) {
      if (!chatId || messageId == null) return null;
      const key = `${chatId}_${messageId}`;
      if (conversationsCache.has(key)) return conversationsCache.get(key);
      const p = (async () => {
        try {
          const ref = doc(db, 'conversations', key);
          const snap = await getDoc(ref);
          return snap.exists() ? snap.data() : null;
        } catch (_) {
          return null;
        }
      })();
      conversationsCache.set(key, p);
      return p;
    }

    async function fetchMessagesForRequestMap(chatId, requestId) {
      if (!requestId) return new Map();
      if (requestMessagesCache.has(requestId)) return requestMessagesCache.get(requestId);
      const p = (async () => {
        try {
          const colRef = collection(db, 'conversations');
          const q = query(colRef, where('request_id', '==', requestId), where('chat_id', '==', coerce(chatId)));
          const snap = await getDocs(q);
          const map = new Map();
          snap.forEach((doc) => {
            const d = doc.data();
            if (d && d.message_id != null) map.set(String(d.message_id), d);
          });
          return map;
        } catch (_) {
          return new Map();
        }
      })();
      requestMessagesCache.set(requestId, p);
      return p;
    }

    const url = new URL(location.href);
    const initialRequestId = url.searchParams.get('request_id') || '';
    const initialUserId = url.searchParams.get('user_id') || '';
    if (initialRequestId) els.inpRequestId.value = initialRequestId;
    if (initialUserId) els.inpUserId.value = initialUserId;

    // default last 7 days
    const today = new Date();
    const startDefault = new Date(today.getTime() - 6 * 24 * 60 * 60 * 1000);
    const toDateInput = (d) => d.toISOString().slice(0, 10);
    els.inpStart.value = url.searchParams.get('start') || toDateInput(startDefault);
    els.inpEnd.value = url.searchParams.get('end') || toDateInput(today);

    let paging = { last: null, done: false, pageSize: 30 };

    function coerce(val) {
      const n = Number(val);
      return Number.isFinite(n) ? n : val;
    }

    function renderEmpty() {
      els.list.innerHTML = '<div class="empty">No runs</div>';
    }

    function renderRuns(docs, { prepend } = { prepend: false }) {
      const frag = document.createDocumentFragment();
      docs.forEach((doc) => {
        const d = doc.data();
        const div = document.createElement('div');
        div.className = 'run';
        const trigAt = d.flow_trigger && d.flow_trigger.triggered_at ? new Date(d.flow_trigger.triggered_at) : null;
        const meta = document.createElement('div');
        meta.className = 'meta';
        const reqLink = `<a href="${buildUrlWithAuth('interactions', { request_id: d.request_id })}">${d.request_id}</a>`;
        const chatLink = `<a href="${buildUrlWithAuth('conversations', { user_id: d.chat_id })}">${d.chat_id}</a>`;
        meta.innerHTML = `${trigAt ? trigAt.toLocaleString() : ''} · request: ${reqLink} · user: ${chatLink} · flow: ${d.flow_key}`;

        div.appendChild(meta);

        // expandable details (lazy-loaded)
        const details = document.createElement('div');
        details.className = 'steps';
        details.style.display = 'none';
        div.appendChild(details);

        function buildDetailsOnce() {
          if (details.dataset.loaded === '1') return;
          details.dataset.loaded = '1';
          const steps = Array.isArray(d.steps) ? d.steps : [];
          if (steps.length === 0) return;
          // placeholder lines first
          const lines = steps.map((s) => {
            const line = document.createElement('div');
            line.className = 'step';
            if (s.type === 'message') {
              const when = s && s.date && typeof s.date.toDate === 'function' ? s.date.toDate() : (s && s.date ? new Date(s.date) : null);
              const time = formatTimeHM(when);
              const fromLabel = s.from === 'user' ? 'User' : 'Bot';
              line.textContent = `${time} ${fromLabel}: …`;
              line.dataset.msgId = String(s.message_id);
              line.dataset.from = fromLabel;
            } else if (s.type === 'set_attributes') {
              const when = s && s.at ? new Date(s.at) : null;
              const time = formatTimeHM(when);
              const updates = s.updates && typeof s.updates === 'object' ? s.updates : {};
              const pairs = Object.entries(updates).map(([k, v]) => `${k} = ${String(v)}`);
              line.textContent = `${time} set_attributes: ${pairs.join(', ')}`.trim();
            } else if (s.type === 'trigger') {
              line.textContent = `trigger -> ${s.triggered_flow_key} child=${s.child_request_id}`;
            } else if (s.type === 'goto') {
              const when = s && s.at ? new Date(s.at) : null;
              const time = formatTimeHM(when);
              line.textContent = `${time} goto -> ${s.label}`.trim();
            } else {
              line.textContent = JSON.stringify(s);
            }
            return line;
          });
          lines.forEach((ln) => details.appendChild(ln));
          // enrich message lines in batch per request
          fetchMessagesForRequestMap(d.chat_id, d.request_id).then((map) => {
            lines.forEach((ln) => {
              const id = ln.dataset.msgId;
              if (!id) return;
              const msg = map.get(String(id));
              const t = formatTimeHM(msg && msg.date);
              const fromLabel = ln.dataset.from || '';
              const content = msg && typeof msg.contents === 'string' ? msg.contents : `(message_id=${id})`;
              ln.textContent = `${t || ''} ${fromLabel}: ${content}`.trim();
            });
          }).catch(() => {
            // fallback to single fetches
            lines.forEach((ln) => {
              const id = ln.dataset.msgId;
              const fromLabel = ln.dataset.from || '';
              if (!id) return;
              fetchConversationMessage(d.chat_id, id).then((msg) => {
                const t = formatTimeHM(msg && msg.date);
                const content = msg && typeof msg.contents === 'string' ? msg.contents : `(message_id=${id})`;
                ln.textContent = `${t || ''} ${fromLabel}: ${content}`.trim();
              }).catch(() => {});
            });
          });
        }

        // toggle expand/collapse on click, ignore anchor clicks
        div.addEventListener('click', (ev) => {
          if (ev.target && ev.target.closest && ev.target.closest('a')) return;
          const isShown = details.style.display !== 'none';
          if (isShown) {
            details.style.display = 'none';
          } else {
            buildDetailsOnce();
            details.style.display = '';
          }
        });

        frag.appendChild(div);
      });

      if (prepend) {
        const prevHeight = els.list.scrollHeight;
        els.list.insertBefore(frag, els.list.firstChild);
        const newHeight = els.list.scrollHeight;
        els.list.scrollTop += (newHeight - prevHeight);
      } else {
        els.list.innerHTML = '';
        els.list.appendChild(frag);
        // jump to bottom so newest is visible
        els.list.scrollTop = els.list.scrollHeight;
      }
    }

    function buildRunsQuery({ requestId, userId, startDate, endDate }) {
      const col = collection(db, 'interactions');
      const constraints = [];
      if (requestId) constraints.push(where('request_id', '==', requestId));
      if (userId) constraints.push(where('chat_id', '==', coerce(userId)));
      // order by trigger time desc if filtering by date; otherwise order by request_id desc fallback
      constraints.push(orderBy('flow_trigger.triggered_at', 'desc'));
      if (startDate) constraints.push(where('flow_trigger.triggered_at', '>=', startDate.toISOString()));
      if (endDate) {
        const end = new Date(endDate.getTime());
        end.setHours(23,59,59,999);
        constraints.push(where('flow_trigger.triggered_at', '<=', end.toISOString()));
      }
      constraints.push(limit(paging.pageSize));
      if (paging.last) constraints.push(startAfter(paging.last));
      return query(col, ...constraints);
    }

    async function loadInitial() {
      const requestId = els.inpRequestId.value.trim();
      const userId = els.inpUserId.value.trim();
      paging = { last: null, done: false, pageSize: 30 };
      const s = els.inpStart.value ? new Date(els.inpStart.value) : null;
      const e = els.inpEnd.value ? new Date(els.inpEnd.value) : null;

      if (requestId) {
        // load a single doc view
        const docRef = doc(db, 'interactions', requestId);
        const snap = await getDoc(docRef);
        if (!snap.exists()) { renderEmpty(); return; }
        renderRuns([snap], { prepend: false });
        return;
      }

      const q = buildRunsQuery({ requestId, userId, startDate: s, endDate: e });
      const snap = await getDocs(q);
      if (snap.empty) { renderEmpty(); return; }
      const docsDesc = snap.docs;
      paging.last = docsDesc[docsDesc.length - 1];
      const docsAsc = docsDesc.slice().reverse();
      renderRuns(docsAsc, { prepend: false });
    }

    async function loadMore() {
      if (paging.done) return;
      const requestId = els.inpRequestId.value.trim();
      if (requestId) { paging.done = true; return; }
      const userId = els.inpUserId.value.trim();
      const s = els.inpStart.value ? new Date(els.inpStart.value) : null;
      const e = els.inpEnd.value ? new Date(els.inpEnd.value) : null;
      const q = buildRunsQuery({ requestId, userId, startDate: s, endDate: e });
      const snap = await getDocs(q);
      if (snap.empty) { paging.done = true; return; }
      const docsDesc = snap.docs;
      paging.last = docsDesc[docsDesc.length - 1];
      const docsAsc = docsDesc.slice().reverse();
      renderRuns(docsAsc, { prepend: true });
    }

    els.list.addEventListener('scroll', () => {
      // Load older runs when the user scrolls near the top
      if (els.list.scrollTop < 80) {
        loadMore();
      }
    });

    els.btnApply.addEventListener('click', () => {
      const u = new URL(location.href);
      const rid = els.inpRequestId.value.trim();
      const uid = els.inpUserId.value.trim();
      const s = els.inpStart.value.trim();
      const e = els.inpEnd.value.trim();
      if (rid) u.searchParams.set('request_id', rid); else u.searchParams.delete('request_id');
      if (uid) u.searchParams.set('user_id', uid); else u.searchParams.delete('user_id');
      if (s) u.searchParams.set('start', s); else u.searchParams.delete('start');
      if (e) u.searchParams.set('end', e); else u.searchParams.delete('end');
      history.replaceState(null, '', u.toString());
      loadInitial();
    });
    document.getElementById('btnReload').addEventListener('click', loadInitial);

    // update header link with auth params
    (function updateHeaderLinks(){
      const l = document.getElementById('lnkConversations');
      if (l) l.href = buildUrlWithAuth('conversations', {});
    })();

    onAuthStateChanged(auth, async (user) => {
      if (!user) await signInAnonymously(auth);
      await loadInitial();
    });
  </script>
</body>
</html>


