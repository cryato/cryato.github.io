<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Interactions Viewer</title>
  <style>
    :root { --bg: #0f172a; --panel: #111827; --muted: #94a3b8; --text: #e5e7eb; --primary: #22d3ee; --accent: #8b5cf6; }
    html, body { height: 100%; }
    body { margin: 0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica Neue, Arial; background: linear-gradient(180deg, #0b1022 0%, #0f172a 100%); color: var(--text); }
    header { display: flex; align-items: center; justify-content: space-between; padding: 12px 16px; border-bottom: 1px solid #1f2937; position: sticky; top: 0; background: rgba(17,24,39,0.6); backdrop-filter: blur(8px); z-index: 10; }
    header h1 { font-size: 16px; margin: 0; }
    .toolbar { display: flex; gap: 8px; align-items: center; }
    input[type="text"], input[type="date"] { background: rgba(17,24,39,0.6); border: 1px solid #1f2937; color: var(--text); padding: 8px 10px; border-radius: 8px; outline: none; font-size: 13px; }
    .btn { appearance: none; border: 1px solid #283449; background: linear-gradient(180deg, #0b1224 0%, #0a1222 100%); color: #e5e7eb; border-radius: 8px; padding: 8px 12px; font-size: 13px; cursor: pointer; }
    .container { display: grid; grid-template-columns: 360px 1fr; gap: 16px; padding: 16px; }
    .panel { background: rgba(17,24,39,0.65); border: 1px solid #1f2937; border-radius: 12px; }
    .left { padding: 12px; }
    .field { display: grid; grid-template-columns: 120px 1fr; align-items: center; gap: 8px; margin: 8px 0; }
    .label { color: var(--muted); font-size: 12px; }
    .list { height: calc(100vh - 120px); overflow: auto; padding: 12px; }
    .run { border: 1px solid #1f2937; background: rgba(2,6,23,0.55); border-radius: 10px; padding: 10px; margin: 8px 0; }
    .meta { color: var(--muted); font-size: 12px; margin-bottom: 6px; display: flex; gap: 8px; flex-wrap: wrap; }
    .steps { margin-top: 10px; padding-left: 6px; border-left: 2px solid #334155; }
    .step { font-size: 12px; color: #cbd5e1; margin: 6px 0; }
    a { color: #93c5fd; }
    .empty { color: var(--muted); padding: 16px; }

    /* Single interaction view */
    .single { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; padding: 16px; }
    .column { background: rgba(17,24,39,0.65); border: 1px solid #1f2937; border-radius: 12px; padding: 12px; min-height: calc(100vh - 130px); overflow: auto; }
    .flow-head { display: flex; align-items: center; justify-content: space-between; gap: 8px; margin-bottom: 8px; }
    .flow-title { font-size: 16px; font-weight: 600; }
    .btn { appearance: none; border: 1px solid #283449; background: linear-gradient(180deg, #0b1224 0%, #0a1222 100%); color: #e5e7eb; border-radius: 8px; padding: 8px 12px; font-size: 13px; cursor: pointer; }
    .steps-view .step { border: 1px solid #1f2937; background: rgba(2,6,23,0.55); border-radius: 10px; padding: 10px; margin: 8px 0; }
    .dimmed { opacity: 0.5; }
    .badge { font-size: 11px; padding: 2px 6px; border-radius: 999px; border: 1px solid #1f2937; background: rgba(15,23,42,0.6); color: #b3e1ff; margin-right: 8px; }
    .right-messages .msg { border: 1px solid #1f2937; background: rgba(2,6,23,0.55); border-radius: 10px; padding: 10px; margin: 8px 0; }
    .right-messages .meta { color: var(--muted); font-size: 12px; margin-bottom: 6px; display: flex; gap: 8px; flex-wrap: wrap; }
  </style>
</head>
<body>
  <header>
    <h1>Interactions</h1>
    <div class="toolbar">
      <button id="btnReload" class="btn">Reload</button>
      <a id="lnkConversations" class="btn" href="#">Conversations</a>
    </div>
  </header>

  <div id="viewList" class="container" style="display:none;">
    <div class="panel left">
      <div class="field">
        <div class="label">Request ID</div>
        <input id="inpRequestId" type="text" placeholder="request_id (optional)" />
      </div>
      <div class="field">
        <div class="label">Customer ID</div>
        <input id="inpUserId" type="text" placeholder="user_id (optional)" />
      </div>
      <div class="field">
        <div class="label">Start</div>
        <input id="inpStart" type="date" />
      </div>
      <div class="field">
        <div class="label">End</div>
        <input id="inpEnd" type="date" />
      </div>
      <div class="field">
        <div></div>
        <button id="btnApply" class="btn">Apply</button>
      </div>
      <div style="margin-top:12px; color: var(--muted); font-size: 12px;"></div>
    </div>
    <div class="panel">
      <div id="list" class="list"></div>
    </div>
  </div>

  <div id="viewSingle" class="single" style="display:none;">
    <div class="column">
      <div class="flow-head">
        <div class="flow-title" id="flowTitle">Flow</div>
        <div style="display:flex; gap:8px; align-items:center;">
          <button id="btnPublish" class="btn">Publish</button>
          <a id="btnOpenEditor" class="btn" href="editor" target="_blank">Open in Editor</a>
        </div>
      </div>
      <div id="flowSteps" class="steps-view"></div>
    </div>
    <div class="column right-messages">
      <div class="flow-head">
        <div class="flow-title">Interaction Log</div>
      </div>
      <div id="singleMessages"></div>
    </div>
  </div>

  <script type="module">
    import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.12.5/firebase-app.js';
    import { getAuth, signInAnonymously, onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/10.12.5/firebase-auth.js';
    import { getFirestore, collection, query, where, orderBy, limit, startAfter, Timestamp, getDocs, doc, getDoc } from 'https://www.gstatic.com/firebasejs/10.12.5/firebase-firestore.js';

    function readCookie(name) {
      const match = document.cookie.match(new RegExp('(?:^|; )' + name.replace(/([.$?*|{}()\[\]\\\/\+^])/g, '\\$1') + '=([^;]*)'));
      return match ? decodeURIComponent(match[1]) : '';
    }
    function getConfig() {
      const u = new URL(location.href);
      const p = (k) => u.searchParams.get(k) || '';
      return {
        apiKey: p('apiKey') || readCookie('apiKey') || '',
        authDomain: p('authDomain') || readCookie('authDomain') || '',
        projectId: p('projectId') || readCookie('projectId') || ''
      };
    }
    function buildUrlWithAuth(path, extraParams) {
      const params = new URLSearchParams();
      // Only include context-specific extras; do NOT carry auth params anymore
      Object.entries(extraParams || {}).forEach(([k, v]) => {
        if (v != null && String(v).length > 0) params.set(k, String(v));
      });
      const qs = params.toString();
      return qs ? `${path}?${qs}` : path;
    }


    const cfg = getConfig();
    const app = initializeApp({ apiKey: cfg.apiKey, authDomain: cfg.authDomain, projectId: cfg.projectId });
    const auth = getAuth(app);
    const db = getFirestore(app);

    const els = {
      inpRequestId: document.getElementById('inpRequestId'),
      inpUserId: document.getElementById('inpUserId'),
      inpStart: document.getElementById('inpStart'),
      inpEnd: document.getElementById('inpEnd'),
      btnApply: document.getElementById('btnApply'),
      btnReload: document.getElementById('btnReload'),
      list: document.getElementById('list'),
      viewList: document.getElementById('viewList'),
      viewSingle: document.getElementById('viewSingle'),
      flowTitle: document.getElementById('flowTitle'),
      flowSteps: document.getElementById('flowSteps'),
      singleMessages: document.getElementById('singleMessages'),
      btnPublish: document.getElementById('btnPublish'),
      btnOpenEditor: document.getElementById('btnOpenEditor')
    };

    // Caches
    const conversationsCache = new Map(); // key: chatId_messageId -> Promise(data|null)
    const requestMessagesCache = new Map(); // key: requestId -> Promise<Map(message_id -> data)>

    function formatTimeHM(input) {
      if (!input) return '';
      const d = (input && typeof input.toDate === 'function') ? input.toDate() : (input instanceof Date ? input : new Date(input));
      if (!Number.isFinite(d.getTime())) return '';
      const hh = String(d.getHours()).padStart(2, '0');
      const mm = String(d.getMinutes()).padStart(2, '0');
      return `${hh}:${mm}`;
    }

    async function fetchConversationMessage(chatId, messageId) {
      if (!chatId || messageId == null) return null;
      const key = `${chatId}_${messageId}`;
      if (conversationsCache.has(key)) return conversationsCache.get(key);
      const p = (async () => {
        try {
          const ref = doc(db, 'conversations', key);
          const snap = await getDoc(ref);
          return snap.exists() ? snap.data() : null;
        } catch (_) {
          return null;
        }
      })();
      conversationsCache.set(key, p);
      return p;
    }

    async function fetchMessagesForRequestMap(chatId, requestId) {
      if (!requestId) return new Map();
      if (requestMessagesCache.has(requestId)) return requestMessagesCache.get(requestId);
      const p = (async () => {
        try {
          const colRef = collection(db, 'conversations');
          const q = query(colRef, where('request_id', '==', requestId), where('chat_id', '==', coerce(chatId)));
          const snap = await getDocs(q);
          const map = new Map();
          snap.forEach((doc) => {
            const d = doc.data();
            if (d && d.message_id != null) map.set(String(d.message_id), d);
          });
          return map;
        } catch (_) {
          return new Map();
        }
      })();
      requestMessagesCache.set(requestId, p);
      return p;
    }

    const url = new URL(location.href);
    const initialRequestId = url.searchParams.get('request_id') || '';
    const initialUserId = url.searchParams.get('user_id') || '';
    if (initialRequestId) els.inpRequestId.value = initialRequestId;
    if (initialUserId) els.inpUserId.value = initialUserId;

    // default last 7 days
    const today = new Date();
    const startDefault = new Date(today.getTime() - 6 * 24 * 60 * 60 * 1000);
    const toDateInput = (d) => d.toISOString().slice(0, 10);
    els.inpStart.value = url.searchParams.get('start') || toDateInput(startDefault);
    els.inpEnd.value = url.searchParams.get('end') || toDateInput(today);

    let paging = { last: null, done: false, pageSize: 30 };

    function coerce(val) {
      const n = Number(val);
      return Number.isFinite(n) ? n : val;
    }

    function renderEmpty() {
      els.list.innerHTML = '<div class="empty">No runs</div>';
    }

    function renderRuns(docs, { prepend } = { prepend: false }) {
      const frag = document.createDocumentFragment();
      docs.forEach((doc) => {
        const d = doc.data();
        const div = document.createElement('div');
        div.className = 'run';
        const trigAt = d.flow_trigger && d.flow_trigger.triggered_at ? new Date(d.flow_trigger.triggered_at) : null;
        const meta = document.createElement('div');
        meta.className = 'meta';
        const reqLink = `<a href="${buildUrlWithAuth('interactions', { request_id: d.request_id })}">${d.request_id}</a>`;
        const chatLink = `<a href="${buildUrlWithAuth('conversations', { user_id: d.chat_id })}">${d.chat_id}</a>`;
        meta.innerHTML = `${trigAt ? trigAt.toLocaleString() : ''} · request: ${reqLink} · user: ${chatLink} · flow: ${d.flow_key}`;

        div.appendChild(meta);

        // expandable details (lazy-loaded)
        const details = document.createElement('div');
        details.className = 'steps';
        details.style.display = 'none';
        div.appendChild(details);

        function buildDetailsOnce() {
          if (details.dataset.loaded === '1') return;
          details.dataset.loaded = '1';
          const steps = Array.isArray(d.steps) ? d.steps : [];
          if (steps.length === 0) return;
          // placeholder lines first
          const lines = steps.map((s) => {
            const line = document.createElement('div');
            line.className = 'step';
            if (s.type === 'message') {
              const when = s && s.date && typeof s.date.toDate === 'function' ? s.date.toDate() : (s && s.date ? new Date(s.date) : null);
              const time = formatTimeHM(when);
              const fromLabel = s.from === 'user' ? 'User' : 'Bot';
              line.textContent = `${time} ${fromLabel}: …`;
              line.dataset.msgId = String(s.message_id);
              line.dataset.from = fromLabel;
            } else if (s.type === 'set_attributes') {
              const when = s && s.at ? new Date(s.at) : null;
              const time = formatTimeHM(when);
              const updates = s.updates && typeof s.updates === 'object' ? s.updates : {};
              const pairs = Object.entries(updates).map(([k, v]) => `${k} = ${String(v)}`);
              line.textContent = `${time} set_attributes: ${pairs.join(', ')}`.trim();
            } else if (s.type === 'trigger') {
              line.textContent = `trigger -> ${s.triggered_flow_key} child=${s.child_request_id}`;
            } else if (s.type === 'goto') {
              const when = s && s.at ? new Date(s.at) : null;
              const time = formatTimeHM(when);
              line.textContent = `${time} goto -> ${s.label}`.trim();
            } else {
              line.textContent = JSON.stringify(s);
            }
            return line;
          });
          lines.forEach((ln) => details.appendChild(ln));
          // enrich message lines in batch per request
          fetchMessagesForRequestMap(d.chat_id, d.request_id).then((map) => {
            lines.forEach((ln) => {
              const id = ln.dataset.msgId;
              if (!id) return;
              const msg = map.get(String(id));
              const t = formatTimeHM(msg && msg.date);
              const fromLabel = ln.dataset.from || '';
              const content = msg && typeof msg.contents === 'string' ? msg.contents : `(message_id=${id})`;
              ln.textContent = `${t || ''} ${fromLabel}: ${content}`.trim();
            });
          }).catch(() => {
            // fallback to single fetches
            lines.forEach((ln) => {
              const id = ln.dataset.msgId;
              const fromLabel = ln.dataset.from || '';
              if (!id) return;
              fetchConversationMessage(d.chat_id, id).then((msg) => {
                const t = formatTimeHM(msg && msg.date);
                const content = msg && typeof msg.contents === 'string' ? msg.contents : `(message_id=${id})`;
                ln.textContent = `${t || ''} ${fromLabel}: ${content}`.trim();
              }).catch(() => {});
            });
          });
        }

        // toggle expand/collapse on click, ignore anchor clicks
        div.addEventListener('click', (ev) => {
          if (ev.target && ev.target.closest && ev.target.closest('a')) return;
          const isShown = details.style.display !== 'none';
          if (isShown) {
            details.style.display = 'none';
          } else {
            buildDetailsOnce();
            details.style.display = '';
          }
        });

        frag.appendChild(div);
      });

      if (prepend) {
        const prevHeight = els.list.scrollHeight;
        els.list.insertBefore(frag, els.list.firstChild);
        const newHeight = els.list.scrollHeight;
        els.list.scrollTop += (newHeight - prevHeight);
      } else {
        els.list.innerHTML = '';
        els.list.appendChild(frag);
        // jump to bottom so newest is visible
        els.list.scrollTop = els.list.scrollHeight;
      }
    }

    function buildRunsQuery({ requestId, userId, startDate, endDate }) {
      const col = collection(db, 'interactions');
      const constraints = [];
      if (requestId) constraints.push(where('request_id', '==', requestId));
      if (userId) constraints.push(where('chat_id', '==', coerce(userId)));
      // order by trigger time desc if filtering by date; otherwise order by request_id desc fallback
      constraints.push(orderBy('flow_trigger.triggered_at', 'desc'));
      if (startDate) constraints.push(where('flow_trigger.triggered_at', '>=', startDate.toISOString()));
      if (endDate) {
        const end = new Date(endDate.getTime());
        end.setHours(23,59,59,999);
        constraints.push(where('flow_trigger.triggered_at', '<=', end.toISOString()));
      }
      constraints.push(limit(paging.pageSize));
      if (paging.last) constraints.push(startAfter(paging.last));
      return query(col, ...constraints);
    }

    async function loadInitial() {
      const requestId = els.inpRequestId.value.trim();
      const userId = els.inpUserId.value.trim();
      paging = { last: null, done: false, pageSize: 30 };
      const s = els.inpStart.value ? new Date(els.inpStart.value) : null;
      const e = els.inpEnd.value ? new Date(els.inpEnd.value) : null;

      if (requestId) {
        // load a single doc view
        const docRef = doc(db, 'interactions', requestId);
        const snap = await getDoc(docRef);
        if (!snap.exists()) { renderEmpty(); return; }
        await renderSingleInteraction(snap);
        return;
      }

      const q = buildRunsQuery({ requestId, userId, startDate: s, endDate: e });
      const snap = await getDocs(q);
      if (snap.empty) { renderEmpty(); return; }
      const docsDesc = snap.docs;
      paging.last = docsDesc[docsDesc.length - 1];
      const docsAsc = docsDesc.slice().reverse();
      renderRuns(docsAsc, { prepend: false });
    }

    async function loadMore() {
      if (paging.done) return;
      const requestId = els.inpRequestId.value.trim();
      if (requestId) { paging.done = true; return; }
      const userId = els.inpUserId.value.trim();
      const s = els.inpStart.value ? new Date(els.inpStart.value) : null;
      const e = els.inpEnd.value ? new Date(els.inpEnd.value) : null;
      const q = buildRunsQuery({ requestId, userId, startDate: s, endDate: e });
      const snap = await getDocs(q);
      if (snap.empty) { paging.done = true; return; }
      const docsDesc = snap.docs;
      paging.last = docsDesc[docsDesc.length - 1];
      const docsAsc = docsDesc.slice().reverse();
      renderRuns(docsAsc, { prepend: true });
    }

    els.list.addEventListener('scroll', () => {
      // Load older runs when the user scrolls near the top
      if (els.list.scrollTop < 80) {
        loadMore();
      }
    });

    els.btnApply.addEventListener('click', () => {
      const u = new URL(location.href);
      const rid = els.inpRequestId.value.trim();
      const uid = els.inpUserId.value.trim();
      const s = els.inpStart.value.trim();
      const e = els.inpEnd.value.trim();
      if (rid) u.searchParams.set('request_id', rid); else u.searchParams.delete('request_id');
      if (uid) u.searchParams.set('user_id', uid); else u.searchParams.delete('user_id');
      if (s) u.searchParams.set('start', s); else u.searchParams.delete('start');
      if (e) u.searchParams.set('end', e); else u.searchParams.delete('end');
      history.replaceState(null, '', u.toString());
      loadInitial();
    });
    document.getElementById('btnReload').addEventListener('click', loadInitial);

    // update header link with auth params
    (function updateHeaderLinks(){
      const l = document.getElementById('lnkConversations');
      if (l) l.href = buildUrlWithAuth('conversations', {});
    })();

    onAuthStateChanged(auth, async (user) => {
      if (!user) await signInAnonymously(auth);
      await loadInitial();
    });

    // ---------- Single Interaction Rendering ----------
    let flowDoc = null;

    async function loadFlowJson() {
      try {
        // Try from same origin (editor-compatible). If hosted elsewhere, ensure path correct.
        const res = await fetch(buildUrlWithAuth('flow.json', {}), { cache: 'no-store' });
        if (!res.ok) {
          // fallback to relative path
          const res2 = await fetch('flow.json', { cache: 'no-store' });
          if (!res2.ok) throw new Error('Failed to load flow.json');
          flowDoc = await res2.json();
        } else {
          flowDoc = await res.json();
        }
      } catch (_) {
        flowDoc = { flows: {} };
      }
    }

    function buildExecutedIndicesFromLogs(steps) {
      const set = new Set();
      steps.forEach((s) => {
        if (s && s.type === 'message' && Number.isFinite(s.step_index)) set.add(Number(s.step_index));
      });
      return set;
    }

    function buildGotoUsageIndexes(flowDef, stepsLogs) {
      const used = new Set();
      const loggedLabels = new Set(stepsLogs.filter((s) => s && s.type === 'goto' && s.label).map((s) => String(s.label)));
      const steps = Array.isArray(flowDef.steps) ? flowDef.steps : [];
      steps.forEach((st, idx) => {
        if (st && st.goto && loggedLabels.has(String(st.goto))) used.add(idx);
      });
      return used;
    }

    function renderFlowWithDimming(flowKey, flowDef, stepsLogs) {
      els.flowTitle.textContent = `${flowKey}${flowDef && flowDef.trigger ? ' · ' + flowDef.trigger : ''}`;
      els.flowSteps.innerHTML = '';
      const steps = Array.isArray(flowDef.steps) ? flowDef.steps : [];
      const executed = buildExecutedIndicesFromLogs(stepsLogs);
      const gotoUsed = buildGotoUsageIndexes(flowDef, stepsLogs);
      const hasLaterExec = (i) => Array.from(executed).some((n) => n > i);

      steps.forEach((st, idx) => {
        const wrap = document.createElement('div');
        wrap.className = 'step';
        const head = document.createElement('div');
        head.style.display = 'flex'; head.style.alignItems = 'center'; head.style.marginBottom = '6px';
        const badge = document.createElement('span');
        badge.className = 'badge';
        const type = st.ask ? 'ask' : (st.say ? 'say' : (st.wait ? 'wait' : (st.goto ? 'goto' : (st.label ? 'label' : (st.script ? 'script' : 'step')))));
        badge.textContent = type.toUpperCase();
        const idxEl = document.createElement('span');
        idxEl.style.color = '#94a3b8'; idxEl.style.fontSize = '12px'; idxEl.style.marginLeft = '8px';
        idxEl.textContent = '#' + (idx + 1);
        head.appendChild(badge);
        head.appendChild(idxEl);
        wrap.appendChild(head);

        // Editable ask/say
        if (st.ask != null) {
          const field = document.createElement('div'); field.className = 'field';
          const label = document.createElement('div'); label.className = 'label'; label.textContent = 'ask';
          const ta = document.createElement('textarea'); ta.value = String(st.ask || ''); ta.addEventListener('input', (e) => { st.ask = e.target.value; });
          field.appendChild(label); field.appendChild(ta); wrap.appendChild(field);
          if (st.saveAs != null) {
            const f2 = document.createElement('div'); f2.className = 'field';
            const l2 = document.createElement('div'); l2.className = 'label'; l2.textContent = 'saveAs';
            const i2 = document.createElement('input'); i2.type = 'text'; i2.value = String(st.saveAs || ''); i2.addEventListener('input', (e) => { st.saveAs = e.target.value; });
            f2.appendChild(l2); f2.appendChild(i2); wrap.appendChild(f2);
          }
        } else if (st.say != null) {
          const field = document.createElement('div'); field.className = 'field';
          const label = document.createElement('div'); label.className = 'label'; label.textContent = 'say';
          const ta = document.createElement('textarea'); ta.value = String(st.say || ''); ta.addEventListener('input', (e) => { st.say = e.target.value; });
          field.appendChild(label); field.appendChild(ta); wrap.appendChild(field);
        } else {
          const ro = document.createElement('div'); ro.className = 'field';
          const l = document.createElement('div'); l.className = 'label'; l.textContent = 'details';
          const v = document.createElement('div'); v.textContent = JSON.stringify(st);
          ro.appendChild(l); ro.appendChild(v); wrap.appendChild(ro);
        }

        // Dimming logic
        let dim = false;
        if (st.goto) {
          if (!gotoUsed.has(idx) && hasLaterExec(idx)) dim = true; // goto was skipped due to filters
        }
        if ((st.ask || st.say) && !executed.has(idx)) {
          // step did not produce a message in logs → dim as unused
          dim = true;
        }
        if (dim) wrap.classList.add('dimmed');

        els.flowSteps.appendChild(wrap);
      });
    }

    function formatTimeHM2(d) {
      if (!d) return '';
      const hh = String(d.getHours()).padStart(2, '0');
      const mm = String(d.getMinutes()).padStart(2, '0');
      return `${hh}:${mm}`;
    }

    async function renderSingleInteraction(snap) {
      els.viewList.style.display = 'none';
      els.viewSingle.style.display = '';
      const d = snap.data();
      await loadFlowJson();
      const flow = flowDoc && flowDoc.flows ? flowDoc.flows[d.flow_key] : null;
      const stepsLogs = Array.isArray(d.steps) ? d.steps : [];
      if (flow) renderFlowWithDimming(d.flow_key, flow, stepsLogs);
      els.btnOpenEditor.href = buildUrlWithAuth('editor', {});

      // Right side: render messages and gotos
      els.singleMessages.innerHTML = '';
      // Messages
      const msgsWrap = document.createDocumentFragment();
      const convMap = await fetchMessagesForRequestMap(d.chat_id, d.request_id).catch(() => new Map());
      for (const s of stepsLogs) {
        if (s.type === 'message') {
          const line = document.createElement('div'); line.className = 'msg';
          const when = s && s.date && typeof s.date.toDate === 'function' ? s.date.toDate() : (s && s.date ? new Date(s.date) : null);
          const meta = document.createElement('div'); meta.className = 'meta';
          const msg = convMap.get(String(s.message_id));
          meta.textContent = `${formatTimeHM2(when)} · ${s.from} · step #${s.step_index}`;
          const body = document.createElement('div');
          body.textContent = msg && typeof msg.contents === 'string' ? msg.contents : `(message_id=${s.message_id})`;
          line.appendChild(meta); line.appendChild(body); msgsWrap.appendChild(line);
        } else if (s.type === 'goto') {
          const line = document.createElement('div'); line.className = 'msg';
          const when = s && s.at ? new Date(s.at) : null;
          const meta = document.createElement('div'); meta.className = 'meta';
          meta.textContent = `${formatTimeHM2(when)} · GOTO → ${s.label}`;
          line.appendChild(meta); els.singleMessages.appendChild(line);
        }
      }
      els.singleMessages.appendChild(msgsWrap);

      // Publish button (open Editor flow for full features)
      els.btnPublish.addEventListener('click', () => {
        // Minimal: download edited flow.json; users can publish via Editor
        try {
          if (!flowDoc) return;
          const json = JSON.stringify(flowDoc, null, 2);
          const blob = new Blob([json], { type: 'application/json' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url; a.download = 'flow.json';
          document.body.appendChild(a); a.click();
          setTimeout(() => { URL.revokeObjectURL(url); a.remove(); }, 0);
        } catch (_) {}
      }, { once: true });
    }
  </script>
</body>
</html>


