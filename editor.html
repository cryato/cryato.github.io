<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Flow Text Editor</title>
  <style>
    :root { --bg: #0f172a; --panel: #111827; --muted: #94a3b8; --text: #e5e7eb; --primary: #22d3ee; --accent: #8b5cf6; }
    html, body { height: 100%; }
    body { margin: 0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica Neue, Arial, "Apple Color Emoji", "Segoe UI Emoji"; background: linear-gradient(180deg, #0b1022 0%, #0f172a 100%); color: var(--text); padding-top: 64px; }
    header { display: flex; align-items: center; justify-content: space-between; padding: 16px 20px; border-bottom: 1px solid #1f2937; backdrop-filter: blur(8px); position: fixed; top: 0; left: 0; right: 0; background: rgba(17,24,39,0.6); z-index: 1000; }
    header h1 { margin: 0; font-size: 16px; font-weight: 600; letter-spacing: 0.3px; }
    .container { display: grid; grid-template-columns: 280px 1fr; gap: 16px; padding: 16px; align-items: start; }
    .panel { background: rgba(17,24,39,0.65); border: 1px solid #1f2937; border-radius: 12px; box-shadow: 0 10px 30px rgba(0,0,0,0.35), inset 0 1px 0 rgba(255,255,255,0.03); }
    .flows { padding: 8px; }
    .flow-item { display: flex; align-items: center; gap: 8px; padding: 10px 12px; margin: 8px; border-radius: 10px; cursor: pointer; border: 1px solid transparent; color: #cbd5e1; }
    .flow-item:hover { background: rgba(148,163,184,0.08); border-color: rgba(148,163,184,0.15); }
    .flow-item.active { background: rgba(139,92,246,0.12); border-color: rgba(139,92,246,0.35); color: #e9d5ff; }
    .flow-key { font-weight: 600; font-size: 13px; }
    .flow-trigger { font-size: 12px; color: var(--muted); }

    .steps { padding: 16px; }
    .flow-header { display: flex; align-items: center; justify-content: space-between; gap: 12px; margin-bottom: 16px; padding: 8px 4px; }
    .flow-title { font-size: 18px; font-weight: 700; letter-spacing: 0.2px; }
    .flow-desc { color: var(--muted); font-size: 13px; }

    .step { padding: 14px; margin: 12px 0; border-radius: 12px; border: 1px solid #1f2937; background: rgba(2,6,23,0.55); }
    .step-head { display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px; }
    .badge { font-size: 11px; padding: 3px 8px; border-radius: 999px; border: 1px solid #1f2937; background: rgba(15,23,42,0.6); color: #b3e1ff; }

    .field { display: grid; grid-template-columns: 140px 1fr; gap: 12px; align-items: start; margin: 10px 0; }
    .label { color: var(--muted); font-size: 12px; padding-top: 7px; }
    input[type="text"], textarea { width: 100%; box-sizing: border-box; background: rgba(17,24,39,0.6); border: 1px solid #1f2937; color: var(--text); padding: 10px 12px; border-radius: 10px; outline: none; font-size: 13px; }
    textarea { min-height: 60px; resize: vertical; }

    .toolbar { display: flex; gap: 8px; }
    .btn { appearance: none; border: 1px solid #283449; background: linear-gradient(180deg, #0b1224 0%, #0a1222 100%); color: #e5e7eb; border-radius: 10px; padding: 10px 14px; font-size: 13px; cursor: pointer; box-shadow: 0 6px 16px rgba(0,0,0,0.25), inset 0 1px 0 rgba(255,255,255,0.04); transition: transform 120ms ease, border-color 120ms ease, background 120ms ease; }
    .btn:hover { transform: translateY(-1px); border-color: #334155; }
    .btn.primary { border-color: rgba(34,211,238,0.6); background: linear-gradient(180deg, rgba(34,211,238,0.18) 0%, rgba(34,211,238,0.10) 100%); color: #cffafe; }
    .btn.accent { border-color: rgba(139,92,246,0.6); background: linear-gradient(180deg, rgba(139,92,246,0.18) 0%, rgba(139,92,246,0.10) 100%); color: #ede9fe; }

    .empty { padding: 40px; text-align: center; color: var(--muted); }
    .footer { padding: 12px 16px; display: flex; justify-content: space-between; align-items: center; border-top: 1px solid #1f2937; }
    .hint { color: var(--muted); font-size: 12px; }
    .code { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; background: rgba(2,6,23,0.6); border: 1px solid #1f2937; padding: 2px 6px; border-radius: 6px; }
    /* Drag & drop handles and selection */
    .grab-handle { display: flex; flex-direction: column; gap: 3px; cursor: grab; padding-right: 10px; padding-left: 2px; }
    .grab-handle span { display: block; width: 14px; height: 2px; background: #64748b; border-radius: 2px; }
    .step:hover .grab-handle span { background: #94a3b8; }
    .step.selected { border-color: rgba(139,92,246,0.65); background: rgba(139,92,246,0.10); box-shadow: 0 0 0 1px rgba(139,92,246,0.15) inset; }
    .step.selected .grab-handle span { background: #c084fc; }
    .step.deleted { opacity: 0.6; filter: grayscale(0.2); }
    .badge.warn { color: #fecaca; border-color: #7f1d1d; background: rgba(127,29,29,0.25); }
    .insert-row.drop-active .btn { border-color: rgba(34,211,238,0.9); background: linear-gradient(180deg, rgba(34,211,238,0.28) 0%, rgba(34,211,238,0.16) 100%); color: #e0f2fe; }
    .insert-row.drop-active div[style*="height: 1px"] { background: #22d3ee !important; }
  </style>
</head>
<body>
  <header>
    <h1>Supportable Flow Editor</h1>
    <div class="toolbar">
      <a id="lnkConversations" class="btn" href="conversations">Conversations</a>
      <a id="lnkInteractions" class="btn" href="interactions">Interactions</a>
      <button id="btnSignOutHeader" class="btn">Sign out</button>
      <button id="btnNewFlow" class="btn primary">New flow</button>
      <button id="btnBrowseVersions" class="btn">Browse versions</button>
      <button id="btnDeleteFlow" class="btn">Delete flow</button>
      <button id="btnPublish" class="btn accent">Publish</button>
    </div>
  </header>
  <div class="container">
    <div class="panel">
      <div class="flows" id="flows"></div>
    </div>
    <div class="panel">
      <div class="steps" id="steps">
        <div class="empty">Select a flow to edit ask/say texts.</div>
      </div>
      <div class="footer">
        <div class="hint">Variables must be written as <span class="code">{{variable}}</span>.</div>
        <div class="hint">Only <span class="code">ask</span> and <span class="code">say</span> are editable.</div>
      </div>
    </div>
  </div>

  <!-- Versions panel -->
  <div id="versionsPanel" class="panel" style="display:none; margin: 16px; padding: 12px;">
    <div class="steps">
      <div class="flow-header">
        <div class="flow-title">Versions</div>
        <div class="toolbar">
          <button id="btnCloseVersions" class="btn">Close</button>
        </div>
      </div>
      <div id="versionsList" class="steps"></div>
      <div style="display:flex; gap:8px; align-items:center; margin-top:8px;">
        <button id="btnLoadMoreVersions" class="btn">Load more</button>
        <div id="versionsHint" class="hint"></div>
      </div>
    </div>
  </div>

  <input type="file" id="fileInput" accept="application/json" style="display:none" />

  <!-- Cloud Storage config panel (client-only; no secrets stored besides OAuth client ID) -->
  <div id="gcsPanel" class="panel" style="margin: 16px; padding: 12px;">
    <div class="steps">
      <div class="flow-header">
        <div class="flow-title">Google Cloud Storage</div>
        <div class="toolbar">
          <button id="btnAuth" class="btn">Sign in</button>
          <button id="btnSignOut" class="btn">Sign out</button>
        </div>
      </div>
      <div class="hint" id="authStatus" style="margin-top:8px;">Not signed in</div>
    </div>
  </div>

  <script>
  // Google Identity Services
  // Loaded via script tag injected below. Uses OAuth 2.0 token model for GCS JSON API.
  const els = {
    flows: document.getElementById('flows'),
    steps: document.getElementById('steps'),
    btnPublish: document.getElementById('btnPublish'),
    btnSignOutHeader: document.getElementById('btnSignOutHeader'),
    btnNewFlow: document.getElementById('btnNewFlow'),
    btnBrowseVersions: document.getElementById('btnBrowseVersions'),
    btnDeleteFlow: document.getElementById('btnDeleteFlow'),
    fileInput: document.getElementById('fileInput'),
    // Cloud panel
    btnAuth: document.getElementById('btnAuth'),
    btnSignOut: document.getElementById('btnSignOut'),
    authStatus: document.getElementById('authStatus'),
    gcsPanel: document.getElementById('gcsPanel'),
    versionsPanel: document.getElementById('versionsPanel'),
    versionsList: document.getElementById('versionsList'),
    btnLoadMoreVersions: document.getElementById('btnLoadMoreVersions'),
    btnCloseVersions: document.getElementById('btnCloseVersions'),
    versionsHint: document.getElementById('versionsHint'),
  };

  let flowDoc = null; // { flows: { key: def } }
  let currentFlowKey = null;
  let oauth = { clientId: '', accessToken: '', tokenExpiresAt: 0, scope: 'https://www.googleapis.com/auth/devstorage.read_write', tokenClient: null };
  let gsiLoaded = false;
  let versionsPaging = { key: '', names: [], index: 0, pageSize: 5, busy: false };
  let flowKeys = [];
  let triggersMap = new Map(); // key -> trigger (best-effort)
  // Selection and drag state
  const selectedSteps = new Set();
  let lastSelectedIndex = -1;
  let isDraggingSteps = false;
  let openContextMenuEl = null;
  // Track pending deletions locally before save
  const deletedStepsSet = new Set();

  // Load config from localStorage or URL params (client_id, bucket).
  function loadConfig() {
    const url = new URL(window.location.href);
    const params = Object.fromEntries(url.searchParams.entries());
    const stored = JSON.parse(localStorage.getItem('gcs_config') || '{}');
    const clientId = params.client_id || stored.clientId || '';
    const bucket = params.bucket || stored.bucket || '';
    const object = 'flows/'; // prefix for per-flow files
    oauth.clientId = clientId;
    // Persist silently so future loads work without showing fields
    localStorage.setItem('gcs_config', JSON.stringify({ clientId, bucket, object }));
    updateAuthStatus();
  }

  function updateAuthStatus() {
    const isAuthed = oauth.accessToken && Date.now() < oauth.tokenExpiresAt;
    els.authStatus.textContent = isAuthed ? 'Signed in' : 'Not signed in';
    if (els.gcsPanel) {
      els.gcsPanel.style.display = isAuthed ? 'none' : '';
    }
  }

  function ensureGsiScript() {
    return new Promise((resolve) => {
      if (gsiLoaded) return resolve();
      const s = document.createElement('script');
      s.src = 'https://accounts.google.com/gsi/client';
      s.async = true; s.defer = true;
      s.onload = () => { gsiLoaded = true; resolve(); };
      document.head.appendChild(s);
    });
  }

  async function getAccessToken(force = false) {
    if (!oauth.clientId) throw new Error('Missing OAuth Client ID');
    const stillValid = oauth.accessToken && Date.now() < oauth.tokenExpiresAt - 5000;
    if (stillValid && !force) return oauth.accessToken;
    await ensureGsiScript();
    return new Promise((resolve, reject) => {
      try {
        if (!oauth.tokenClient) {
          oauth.tokenClient = google.accounts.oauth2.initTokenClient({
            client_id: oauth.clientId,
            scope: oauth.scope,
            callback: (resp) => {
              if (resp && resp.access_token) {
                oauth.accessToken = resp.access_token;
                // expires_in seconds
                const expires = Number(resp.expires_in || 0);
                oauth.tokenExpiresAt = Date.now() + Math.max(0, expires - 10) * 1000;
                // Remember window: 1 year
                const oneYearMs = 365 * 24 * 60 * 60 * 1000;
                const rememberUntil = Date.now() + oneYearMs;
                localStorage.setItem('gcs_token', JSON.stringify({
                  accessToken: oauth.accessToken,
                  tokenExpiresAt: oauth.tokenExpiresAt,
                  rememberUntil
                }));
                updateAuthStatus();
                // Set Firebase cookies from firebase_config.json in the bucket for other pages
                ensureFirebaseCookiesFromBucket().catch(() => {});
                // After successful sign-in, clean URL if it has params
                if (force && window.location.search && window.location.search.length > 1) {
                  const clean = window.location.origin + window.location.pathname;
                  // Use replace to avoid back button pollution
                  window.location.replace(clean);
                  return; // stop further execution; reload will happen
                }
                resolve(oauth.accessToken);
              } else {
                reject(new Error('No access token'));
              }
            }
          });
        }
        oauth.tokenClient.requestAccessToken({ prompt: force ? 'consent' : 'none' });
      } catch (e) {
        reject(e);
      }
    });
  }

  function signOut() {
    const sure = confirm('Sign out? You will need to sign in again to Publish.');
    if (!sure) return;
    oauth.accessToken = '';
    oauth.tokenExpiresAt = 0;
    try { localStorage.removeItem('gcs_token'); } catch (_) {}
    updateAuthStatus();
  }

  function getCfg() {
    try {
      const stored = JSON.parse(localStorage.getItem('gcs_config') || '{}');
      const bucket = (stored.bucket || '').trim();
      const object = 'flows/';
      return { bucket, object };
    } catch (_) {
      return { bucket: '', object: 'flows/' };
    }
  }

  function gcsDownloadUrl(bucket, objectPath) {
    return `https://storage.googleapis.com/storage/v1/b/${encodeURIComponent(bucket)}/o/${encodeURIComponent(objectPath)}?alt=media`;
  }

  function gcsUploadUrl(bucket, objectPath) {
    return `https://storage.googleapis.com/upload/storage/v1/b/${encodeURIComponent(bucket)}/o?uploadType=media&name=${encodeURIComponent(objectPath)}`;
  }

  function gcsListUrl(bucket, prefix) {
    const base = `https://storage.googleapis.com/storage/v1/b/${encodeURIComponent(bucket)}/o`;
    const params = new URLSearchParams();
    params.set('prefix', prefix.replace(/^\/*/, ''));
    params.set('fields', 'items(name),nextPageToken');
    return `${base}?${params.toString()}`;
  }

  function gcsDeleteUrl(bucket, objectPath) {
    return `https://storage.googleapis.com/storage/v1/b/${encodeURIComponent(bucket)}/o/${encodeURIComponent(objectPath)}`;
  }

  // ---- Scripts helpers ----
  function scriptFileName(flowKey, stepId) {
    return `script_${flowKey}_${stepId}.js`;
  }
  function scriptObjectPath(flowKey, stepId) {
    return `scripts/${scriptFileName(flowKey, stepId)}`;
  }
  function scriptBackupObjectPath(flowKey, stepId, timestampUtc) {
    return `scripts/backups/script_${flowKey}_${stepId}_${timestampUtc}.js`;
  }
  function toScriptObjectPathFromSpec(spec) {
    const s = String(spec || '').trim();
    return s.includes('/') ? s : `scripts/${s}`;
  }
  async function fetchScriptCodeFromBucket(objectPath) {
    try {
      const { bucket } = getCfg();
      if (!bucket || !hasValidToken()) return '';
      const res = await fetch(gcsDownloadUrl(bucket, objectPath), { headers: { Authorization: `Bearer ${oauth.accessToken}` }, cache: 'no-store' });
      if (!res.ok) return '';
      return await res.text();
    } catch (_) {
      return '';
    }
  }
  async function fetchScriptCodeForVersion(flowKey, stepId, fileSpec, versionTs) {
    // Try backup for the version first; then fall back to current script object path
    try {
      const backupPath = (versionTs && stepId)
        ? scriptBackupObjectPath(flowKey, stepId, versionTs)
        : '';
      if (backupPath) {
        const txt = await fetchScriptCodeFromBucket(backupPath);
        if (txt && txt.length > 0) return txt;
      }
    } catch (_) {}
    try {
      const objectPath = fileSpec ? toScriptObjectPathFromSpec(fileSpec) : (stepId ? scriptObjectPath(flowKey, stepId) : '');
      if (!objectPath) return '';
      return await fetchScriptCodeFromBucket(objectPath);
    } catch (_) {
      return '';
    }
  }
  async function hydrateScriptCodesForFlow(def, flowKey) {
    try {
      if (!def || !Array.isArray(def.steps)) return;
      for (const st of def.steps) {
        if (!st || st.script == null) continue;
        const spec = st.script;
        const fileSpec = (spec && typeof spec === 'object' && spec.file) ? spec.file : '';
        const stepId = (st && typeof st.step_id === 'string' && st.step_id) ? st.step_id : '';
        const objectPath = fileSpec ? toScriptObjectPathFromSpec(fileSpec) : (stepId ? scriptObjectPath(flowKey, stepId) : '');
        if (!objectPath) continue;
        const code = await fetchScriptCodeFromBucket(objectPath);
        if (typeof st.script !== 'object' || st.script == null) st.script = {};
        st.script.code = code;
        if (!st.script.file) st.script.file = fileSpec || scriptFileName(flowKey, stepId);
      }
    } catch (_) {}
  }
  async function hydrateScriptCodesForFlowWithVersion(def, flowKey, versionTs) {
    try {
      if (!def || !Array.isArray(def.steps)) return;
      for (const st of def.steps) {
        if (!st || st.script == null) continue;
        const spec = st.script;
        const fileSpec = (spec && typeof spec === 'object' && spec.file) ? spec.file : '';
        const stepId = (st && typeof st.step_id === 'string' && st.step_id) ? st.step_id : '';
        const code = await fetchScriptCodeForVersion(flowKey, stepId, fileSpec, versionTs);
        if (typeof st.script !== 'object' || st.script == null) st.script = {};
        st.script.code = code;
        if (!st.script.file) st.script.file = fileSpec || scriptFileName(flowKey, stepId);
      }
    } catch (_) {}
  }

  function stripInlineScriptCodesForFlow(def) {
    try {
      if (!def || !Array.isArray(def.steps)) return;
      for (const st of def.steps) {
        if (!st || st.script == null) continue;
        if (typeof st.script === 'object' && st.script.code != null) {
          try { delete st.script.code; } catch (_) {}
        }
      }
    } catch (_) {}
  }

  function formatUtcNowForFlow() {
    const d = new Date();
    const pad = (n) => String(n).padStart(2, '0');
    const yyyy = d.getUTCFullYear();
    const mm = pad(d.getUTCMonth() + 1);
    const dd = pad(d.getUTCDate());
    const HH = pad(d.getUTCHours());
    const MM = pad(d.getUTCMinutes());
    return `${yyyy}-${mm}-${dd}T${HH}_${MM}Z`;
  }

  function formatBackupName(key, timestampUtc) {
    const safeKey = String(key || 'flow');
    const ts = String(timestampUtc || '');
    return `flows/backups/${safeKey}_${ts}.json`;
  }

  function extractTimestampFromBackupName(name) {
    const m = String(name).match(/\/([^\/]+)_([0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}_[0-9]{2}Z)\.json$/);
    return m ? m[2] : '';
  }

  function extractDescriptionFromName(name) {
    // If we later include description in filename, parse here. For now, description isn't in name; return ''
    return '';
  }

  function formatDisplayFromTimestamp(ts) {
    // Input like 2025-09-18T12_15Z → display 2025-09-18 12:15 UTC
    if (!ts) return '';
    return ts.replace('T', ' ').replace('_', ':').replace('Z', ' UTC');
  }

  async function listAllBackupsForKey(key) {
    const { bucket } = getCfg();
    if (!bucket) throw new Error('Missing bucket');
    if (!hasValidToken()) throw new Error('Missing token');
    const base = `https://storage.googleapis.com/storage/v1/b/${encodeURIComponent(bucket)}/o`;
    let pageToken = '';
    const names = [];
    do {
      const params = new URLSearchParams();
      params.set('prefix', `flows/backups/${key}_`);
      params.set('fields', 'items(name),nextPageToken');
      if (pageToken) params.set('pageToken', pageToken);
      const url = `${base}?${params.toString()}`;
      const res = await fetch(url, { headers: { Authorization: `Bearer ${oauth.accessToken}` }, cache: 'no-store' });
      if (!res.ok) throw new Error('Failed to list backups');
      const json = await res.json();
      const items = Array.isArray(json.items) ? json.items : [];
      for (const it of items) {
        if (it && it.name) names.push(String(it.name));
      }
      pageToken = json.nextPageToken || '';
    } while (pageToken);
    // Sort newest first by timestamp parsed from name
    names.sort((a, b) => {
      const ta = extractTimestampFromBackupName(a);
      const tb = extractTimestampFromBackupName(b);
      return ta < tb ? 1 : (ta > tb ? -1 : 0);
    });
    return names;
  }

  function ensureVersionsPanelVisible(show) {
    if (!els.versionsPanel) return;
    els.versionsPanel.style.display = show ? '' : 'none';
  }

  async function loadVersionsFirstPage() {
    if (!currentFlowKey) { alert('Select a flow first.'); return; }
    if (!hasValidToken()) { alert('Please sign in first.'); return; }
    versionsPaging = { key: currentFlowKey, names: [], index: 0, pageSize: 5, busy: true };
    els.versionsList.innerHTML = '';
    els.versionsHint.textContent = '';
    try {
      const names = await listAllBackupsForKey(currentFlowKey);
      renderCurrentVersionItem();
      versionsPaging.names = names;
      versionsPaging.index = 0;
      renderVersionItems(names.slice(0, versionsPaging.pageSize));
      const hasMore = names.length > versionsPaging.pageSize;
      els.btnLoadMoreVersions.style.display = hasMore ? '' : 'none';
    } catch (e) {
      els.versionsHint.textContent = 'Failed to list versions';
    } finally {
      versionsPaging.busy = false;
    }
  }

  async function loadMoreVersions() {
    if (versionsPaging.busy) return;
    const { names, index, pageSize } = versionsPaging;
    const nextStart = index + pageSize;
    if (!names || nextStart >= names.length) { els.btnLoadMoreVersions.style.display = 'none'; return; }
    versionsPaging.busy = true;
    try {
      const slice = names.slice(nextStart, nextStart + pageSize);
      renderVersionItems(slice);
      versionsPaging.index = nextStart;
      const hasMore = (nextStart + pageSize) < names.length;
      els.btnLoadMoreVersions.style.display = hasMore ? '' : 'none';
    } catch (_) {
      els.versionsHint.textContent = 'Failed to load more versions';
    } finally {
      versionsPaging.busy = false;
    }
  }

  function renderVersionItems(items) {
    const frag = document.createDocumentFragment();
    (items || []).forEach((it) => {
      const name = String(it);
      const ts = extractTimestampFromBackupName(name);
      const line = document.createElement('div');
      line.className = 'step';
      const row = document.createElement('div');
      row.style.display = 'flex'; row.style.alignItems = 'center'; row.style.justifyContent = 'space-between';
      const label = document.createElement('div');
      label.textContent = `${formatDisplayFromTimestamp(ts) || name}`;
      const actions = document.createElement('div');
      const btnLoad = document.createElement('button'); btnLoad.className = 'btn'; btnLoad.textContent = 'Load';
      btnLoad.addEventListener('click', () => restoreVersionByName(name));
      actions.appendChild(btnLoad);
      row.appendChild(label); row.appendChild(actions);
      line.appendChild(row);
      frag.appendChild(line);

      // Asynchronously fetch description for this backup and update the label
      fetchBackupMeta(name).then((meta) => {
        if (meta && typeof meta.description === 'string' && meta.description.length > 0) {
          label.textContent = `${formatDisplayFromTimestamp(ts) || name} — ${meta.description}`;
        }
      }).catch(() => {});
    });
    els.versionsList.appendChild(frag);
  }

  async function fetchBackupMeta(objectName) {
    try {
      const { bucket } = getCfg();
      if (!bucket) return {};
      if (!hasValidToken()) return {};
      const res = await fetch(gcsDownloadUrl(bucket, objectName), { headers: { Authorization: `Bearer ${oauth.accessToken}` }, cache: 'no-store' });
      if (!res.ok) return {};
      const json = await res.json();
      let def = null;
      if (json && json.flows && currentFlowKey && json.flows[currentFlowKey]) def = json.flows[currentFlowKey];
      else if (json && currentFlowKey && json[currentFlowKey]) def = json[currentFlowKey];
      else def = json;
      if (!def || typeof def !== 'object') return {};
      const description = typeof def.description === 'string' ? def.description : '';
      const updated_at = typeof def.updated_at === 'string' ? def.updated_at : '';
      return { description, updated_at };
    } catch (_) {
      return {};
    }
  }

  function renderCurrentVersionItem() {
    const flows = (flowDoc && flowDoc.flows) || {};
    const def = flows[currentFlowKey] || {};
    const ts = typeof def.updated_at === 'string' ? def.updated_at : '';
    const desc = typeof def.description === 'string' ? def.description : '';
    const line = document.createElement('div');
    line.className = 'step';
    const row = document.createElement('div');
    row.style.display = 'flex'; row.style.alignItems = 'center'; row.style.justifyContent = 'space-between';
    const label = document.createElement('div');
    const when = formatDisplayFromTimestamp(ts);
    label.textContent = `${when || '(unsaved)'}${desc ? ' — ' + desc : ''}, current`;
    row.appendChild(label);
    line.appendChild(row);
    els.versionsList.appendChild(line);
  }

  async function restoreVersionByName(objectName) {
    try {
      const { bucket } = getCfg();
      if (!bucket) { alert('Missing bucket'); return; }
      if (!hasValidToken()) { alert('Please sign in first.'); return; }
      const res = await fetch(gcsDownloadUrl(bucket, objectName), { headers: { Authorization: `Bearer ${oauth.accessToken}` }, cache: 'no-store' });
      if (!res.ok) throw new Error('Failed to download version');
      const json = await res.json();
      let def = null;
      if (json && json.flows && json.flows[currentFlowKey]) def = json.flows[currentFlowKey];
      else if (json && json[currentFlowKey]) def = json[currentFlowKey];
      else def = json;
      if (!def || typeof def !== 'object') throw new Error('Invalid version structure');
      // Parse version timestamp from backup object name
      const ts = extractTimestampFromBackupName(objectName);
      // Apply to editor state
      if (!flowDoc || !flowDoc.flows) flowDoc = { flows: {} };
      flowDoc.flows[currentFlowKey] = def;
      // Strip inline code if any, then hydrate using the versioned backup first
      try { stripInlineScriptCodesForFlow(flowDoc.flows[currentFlowKey]); } catch (_) {}
      try { await hydrateScriptCodesForFlowWithVersion(flowDoc.flows[currentFlowKey], currentFlowKey, ts); } catch (_) {}
      renderSteps();
    } catch (e) {
      alert('Failed to load version: ' + e.message);
    }
  }

  function setCookie(name, value, days) {
    try {
      const d = new Date();
      d.setTime(d.getTime() + (days*24*60*60*1000));
      const expires = `expires=${d.toUTCString()}`;
      document.cookie = `${encodeURIComponent(name)}=${encodeURIComponent(String(value))}; ${expires}; path=/; SameSite=Lax`;
    } catch (_) {}
  }

  async function ensureFirebaseCookiesFromBucket() {
    try {
      const { bucket } = getCfg();
      if (!bucket || !hasValidToken()) return;
      const url = gcsDownloadUrl(bucket, 'firebase_config.json');
      const res = await fetch(url, { headers: { Authorization: `Bearer ${oauth.accessToken}` }, cache: 'no-store' });
      if (!res.ok) return;
      const json = await res.json();
      if (json && typeof json === 'object') {
        if (json.projectId) setCookie('projectId', json.projectId, 365);
        if (json.apiKey) setCookie('apiKey', json.apiKey, 365);
        if (json.authDomain) setCookie('authDomain', json.authDomain, 365);
      }
    } catch (_) {}
  }

  async function listFlowKeysFromGcs() {
    const { bucket } = getCfg();
    const out = [];
    if (!bucket || !hasValidToken()) return out;
    try {
      let pageToken = '';
      do {
        const prefix = 'flows/';
        const url = gcsListUrl(bucket, prefix) + (pageToken ? `&pageToken=${encodeURIComponent(pageToken)}` : '');
        const res = await fetch(url, { headers: { Authorization: `Bearer ${oauth.accessToken}` }, cache: 'no-store' });
        if (!res.ok) break;
        const json = await res.json();
        const items = Array.isArray(json.items) ? json.items : [];
        for (const it of items) {
          const name = it && it.name ? String(it.name) : '';
          if (!name.startsWith('flows/')) continue;
          if (name.startsWith('flows/backups/')) continue;
          if (!name.toLowerCase().endsWith('.json')) continue;
          // skip legacy combined file
          if (name === 'flows/flow.json') continue;
          const m = name.match(/^flows\/(.+)\.json$/);
          if (m) out.push(m[1]);
        }
        pageToken = json.nextPageToken || '';
      } while (pageToken);
    } catch (_) {}
    return out;
  }

  async function listFlowKeysLocally() {
    // Best-effort: read legacy combined file to derive keys
    try {
      const res = await fetch('flows/flow.json', { cache: 'no-store' });
      if (!res.ok) return [];
      const json = await res.json();
      if (json && json.flows && typeof json.flows === 'object') return Object.keys(json.flows);
    } catch (_) {}
    return [];
  }

  async function loadSingleFlow(key) {
    // Prefer Cloud single file, fallback to site-local candidates, then legacy combined
    const { bucket } = getCfg();
    // Cloud
    if (bucket && hasValidToken()) {
      try {
        const res = await fetch(gcsDownloadUrl(bucket, `flows/${key}.json`), { headers: { Authorization: `Bearer ${oauth.accessToken}` }, cache: 'no-store' });
        if (res.ok) {
          const json = await res.json();
          // Accept either {steps...} or { key: def } or {flows:{}}
          let def = null;
          if (json && json.flows && json.flows[key]) def = json.flows[key];
          else if (json && json[key]) def = json[key];
          else def = json;
          flowDoc = { flows: { [key]: def || {} } };
          try { stripInlineScriptCodesForFlow(flowDoc.flows[key]); } catch (_) {}
          try { await hydrateScriptCodesForFlow(flowDoc.flows[key], key); } catch (_) {}
          currentFlowKey = key;
          return true;
        }
      } catch (_) {}
    }
    // Local direct file candidates
    const candidates = [
      `flows/${key}.json`,
      `../flows/${key}.json`,
      `../../flows/${key}.json`,
      `/flows/${key}.json`
    ];
    for (const rel of candidates) {
      try {
        const res = await fetch(rel, { cache: 'no-store' });
        if (res.ok) {
          const json = await res.json();
          let def = null;
          if (json && json.flows && json.flows[key]) def = json.flows[key];
          else if (json && json[key]) def = json[key];
          else def = json;
          flowDoc = { flows: { [key]: def || {} } };
          try { stripInlineScriptCodesForFlow(flowDoc.flows[key]); } catch (_) {}
          try { await hydrateScriptCodesForFlow(flowDoc.flows[key], key); } catch (_) {}
          currentFlowKey = key;
          return true;
        }
      } catch (_) {}
    }
    // Fallback to legacy combined
    try {
      const res = await fetch('flows/flow.json', { cache: 'no-store' });
      if (res.ok) {
        const json = await res.json();
        const def = json && json.flows ? json.flows[key] : null;
        flowDoc = { flows: def ? { [key]: def } : {} };
        if (def) {
          try { stripInlineScriptCodesForFlow(flowDoc.flows[key]); } catch (_) {}
          try { await hydrateScriptCodesForFlow(flowDoc.flows[key], key); } catch (_) {}
        }
        currentFlowKey = def ? key : null;
        return !!def;
      }
    } catch (_) {}
    flowDoc = { flows: {} };
    currentFlowKey = null;
    return false;
  }

  async function loadInitial() {
    try {
      const u = new URL(location.href);
      const sel = u.searchParams.get('flow') || '';
      // Build list of keys
      let keys = [];
      if (hasValidToken()) keys = await listFlowKeysFromGcs();
      if (!keys || keys.length === 0) keys = await listFlowKeysLocally();
      flowKeys = Array.from(new Set(keys)).sort();
      // Best-effort triggers map from legacy combined file
      triggersMap = new Map();
      try {
        const { bucket } = getCfg();
        let combined = null;
        if (bucket && hasValidToken()) {
          const r = await fetch(gcsDownloadUrl(bucket, 'flows/flow.json'), { headers: { Authorization: `Bearer ${oauth.accessToken}` }, cache: 'no-store' });
          if (r.ok) combined = await r.json();
        }
        if (!combined) {
          const r2 = await fetch('flows/flow.json', { cache: 'no-store' });
          if (r2.ok) combined = await r2.json();
        }
        if (combined && combined.flows && typeof combined.flows === 'object') {
          Object.entries(combined.flows).forEach(([k, v]) => {
            if (v && typeof v === 'object' && v.trigger) triggersMap.set(k, String(v.trigger));
          });
        }
      } catch (_) {}

      // Load selected flow if any
      if (sel) {
        await loadSingleFlow(sel);
      } else {
        flowDoc = { flows: {} };
      currentFlowKey = null;
      }
      renderFlows();
      renderSteps();
    } catch (err) {
      console.error(err);
      flowDoc = { flows: {} };
      renderFlows();
      renderSteps();
    }
  }

  function renderFlows() {
    const flows = (flowDoc && flowDoc.flows) || {};
    const selected = currentFlowKey;
    els.flows.innerHTML = '';
    const keys = flowKeys && flowKeys.length ? flowKeys : Object.keys(flows);

    if (!keys || keys.length === 0) {
      const empty = document.createElement('div');
      empty.className = 'empty';
      empty.textContent = 'No flows found.';
      els.flows.appendChild(empty);
      return;
    }

    keys.forEach((key) => {
      const def = flows[key] || {};
      const item = document.createElement('a');
      item.href = `?flow=${encodeURIComponent(key)}`;
      item.className = 'flow-item' + (selected === key ? ' active' : '');

      const icon = document.createElement('div');
      icon.innerHTML = '⚡️';

      const meta = document.createElement('div');
      const k = document.createElement('div');
      k.className = 'flow-key';
      k.textContent = key;
      const t = document.createElement('div');
      t.className = 'flow-trigger';
      const trig = (def && def.trigger) ? def.trigger : (triggersMap.get(key) || '');
      t.textContent = trig;
      meta.appendChild(k);
      meta.appendChild(t);

      item.appendChild(icon);
      item.appendChild(meta);
      els.flows.appendChild(item);
    });
  }

  function renderSteps() {
    els.steps.innerHTML = '';
    const flows = (flowDoc && flowDoc.flows) || {};
    const def = flows[currentFlowKey];

    if (els.btnDeleteFlow) {
      els.btnDeleteFlow.disabled = !def;
    }

    if (!def) {
      const empty = document.createElement('div');
      empty.className = 'empty';
      empty.textContent = 'Select a flow to edit ask/say texts.';
      els.steps.appendChild(empty);
      return;
    }

    // Header
    const head = document.createElement('div');
    head.className = 'flow-header';
    const title = document.createElement('div');
    title.className = 'flow-title';
    title.textContent = currentFlowKey + (def.trigger ? '  ·  ' + def.trigger : '');
    const desc = document.createElement('div');
    desc.className = 'flow-desc';
    desc.textContent = def.description || '';
    head.appendChild(title);
    head.appendChild(desc);
    els.steps.appendChild(head);

    // Editable flow description
    const descField = fieldText('description', def.description || '', (v) => { def.description = v; });
    els.steps.appendChild(descField);

    const steps = Array.isArray(def.steps) ? def.steps : [];

    // Insert button before the first step
    els.steps.appendChild(buildInsertBetweenRow(def, 0));

    steps.forEach((step, idx) => {
      const s = document.createElement('div');
      s.className = 'step';
      if (selectedSteps.has(step)) s.classList.add('selected');
      if (deletedStepsSet.has(step)) s.classList.add('deleted');

      // Right-click context menu for duplicate
      s.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        try {
          if (!selectedSteps.has(step)) {
            selectedSteps.clear();
            selectedSteps.add(step);
            lastSelectedIndex = idx;
          }
          openStepContextMenu(e, def);
        } catch (_) {}
      });

      const head = document.createElement('div');
      head.className = 'step-head';
      const left = document.createElement('div');
      left.style.display = 'flex';
      left.style.alignItems = 'center';
      left.style.gap = '8px';
      // Grab handle for selection and dragging
      const grab = document.createElement('div');
      grab.className = 'grab-handle';
      grab.title = 'Click to select. Drag to move selected steps.';
      grab.draggable = true;
      grab.innerHTML = '<span></span><span></span><span></span>';
      grab.addEventListener('click', (e) => {
        const multi = e.metaKey || e.ctrlKey;
        const range = e.shiftKey;
        if (range && Array.isArray(def.steps) && lastSelectedIndex >= 0) {
          const a = Math.min(lastSelectedIndex, idx);
          const b = Math.max(lastSelectedIndex, idx);
          for (let i = a; i <= b; i++) selectedSteps.add(def.steps[i]);
        } else if (multi) {
          if (selectedSteps.has(step)) selectedSteps.delete(step); else selectedSteps.add(step);
          lastSelectedIndex = idx;
        } else {
          selectedSteps.clear();
          selectedSteps.add(step);
          lastSelectedIndex = idx;
        }
        renderSteps();
      });
      grab.addEventListener('dragstart', (e) => {
        try { e.dataTransfer.effectAllowed = 'move'; e.dataTransfer.setData('text/plain', 'steps'); } catch (_) {}
        if (!selectedSteps.has(step)) { selectedSteps.clear(); selectedSteps.add(step); lastSelectedIndex = idx; }
        isDraggingSteps = true;
        document.body.dataset.dragging = '1';
      });
      grab.addEventListener('dragend', () => {
        isDraggingSteps = false;
        delete document.body.dataset.dragging;
        document.querySelectorAll('.insert-row.drop-active').forEach((el) => el.classList.remove('drop-active'));
      });
      const type = step.ask ? 'ask'
        : (step.say ? 'say'
        : (step.wait ? 'wait'
        : (step.label ? 'label'
        : (step.goto ? 'goto'
        : (step.trigger ? 'trigger'
        : (step.set_attributes ? 'set_attributes'
        : (step.web_request ? 'web_request'
        : (step.sheets_add_row ? 'sheets_add_row'
        : (step.sheets_find_row ? 'sheets_find_row'
        : (step.sheets_get_row ? 'sheets_get_row'
        : (step.script ? 'script' : 'step')))))))))));
      const badge = document.createElement('span');
      badge.className = 'badge';
      badge.textContent = type.toUpperCase();
      if (deletedStepsSet.has(step)) {
        const delB = document.createElement('span');
        delB.className = 'badge warn';
        delB.textContent = 'DELETED';
        left.appendChild(delB);
      }
      left.appendChild(grab);
      left.appendChild(badge);
      const right = document.createElement('div');
      right.style.display = 'flex';
      right.style.alignItems = 'center';
      right.style.gap = '8px';
      const idxEl = document.createElement('div');
      idxEl.textContent = '#' + (idx + 1);
      idxEl.style.color = '#94a3b8';
      idxEl.style.fontSize = '12px';
      right.appendChild(idxEl);
      // Filters editor on the right side
      right.appendChild(buildFiltersEditor(step, true));
      s.appendChild(head);
      head.appendChild(left);
      head.appendChild(right);

      // Editable fields for all step types (hide step_id; edit filters via modal)
      appendEditorsForStep(step, s);

      els.steps.appendChild(s);

      // Insert button after this step (between idx and idx+1)
      els.steps.appendChild(buildInsertBetweenRow(def, idx + 1));
    });
  }

  // Helper to safely parse JSON text
  function safeParseJson(text) {
    try { return JSON.parse(text); } catch (_) { return null; }
  }

  // Append type-specific editors to a container for a given step
  function appendEditorsForStep(step, container) {
    // ASK
    if (step.ask != null) {
      container.appendChild(fieldText('ask', step.ask, (v) => { step.ask = v; }));
      const saveInit = step.saveAs != null ? String(step.saveAs) : '';
      container.appendChild(fieldText('saveAs', saveInit, (v) => { if (v) step.saveAs = v; else delete step.saveAs; }, true));
      const kbInit = Array.isArray(step.keyboard) ? step.keyboard.join('\n') : '';
      const kbField = fieldText('keyboard', kbInit, (v) => {
        const lines = String(v || '').split(/\r?\n/).map((s) => s.trim()).filter((s) => s.length > 0);
        if (lines.length > 0) step.keyboard = lines; else delete step.keyboard;
      });
      container.appendChild(kbField);
      // verification
      const verWrap = document.createElement('div'); verWrap.className = 'field';
      const verLabel = document.createElement('div'); verLabel.className = 'label'; verLabel.textContent = 'verification';
      const verSel = document.createElement('select');
      ['', 'strict'].forEach((opt) => { const o = document.createElement('option'); o.value = opt; o.textContent = opt || '(none)'; verSel.appendChild(o); });
      verSel.value = typeof step.verification === 'string' ? step.verification : '';
      verSel.style.background = 'rgba(17,24,39,0.6)'; verSel.style.border = '1px solid #1f2937'; verSel.style.color = '#e5e7eb'; verSel.style.borderRadius = '8px'; verSel.style.padding = '4px 6px';
      verSel.addEventListener('change', () => { const v = verSel.value; if (v) step.verification = v; else delete step.verification; });
      verWrap.appendChild(verLabel); verWrap.appendChild(verSel);
      container.appendChild(verWrap);
      return;
    }

    // SAY
        if (step.say != null) {
      container.appendChild(fieldText('say', step.say, (v) => { step.say = v; }));
      const uidInit = step.user_id != null ? String(step.user_id) : '';
      container.appendChild(fieldText('user_id', uidInit, (v) => { if (v) step.user_id = v; else delete step.user_id; }, true));
      return;
    }

    // WAIT
    if (step.wait != null) {
      const wrap = document.createElement('div'); wrap.className = 'field';
      const label = document.createElement('div'); label.className = 'label'; label.textContent = 'seconds';
      const input = document.createElement('input'); input.type = 'number'; input.min = '0'; input.value = String((step.wait && step.wait.seconds) || 0);
      input.addEventListener('input', () => {
        const n = Number(input.value); if (!step.wait || typeof step.wait !== 'object') step.wait = {}; step.wait.seconds = Number.isFinite(n) && n >= 0 ? n : 0;
      });
      wrap.appendChild(label); wrap.appendChild(input); container.appendChild(wrap);
      return;
    }

    // LABEL
    if (step.label != null) {
      container.appendChild(fieldText('label', step.label, (v) => { step.label = v; }, true));
      return;
    }

    // GOTO
    if (step.goto != null) {
      container.appendChild(fieldText('goto', step.goto, (v) => { step.goto = v; }, true));
      return;
    }

    // TRIGGER
    if (step.trigger != null) {
      container.appendChild(fieldText('trigger', step.trigger, (v) => { step.trigger = v; }, true));
      const uidInit = step.user_id != null ? String(step.user_id) : '';
      container.appendChild(fieldText('user_id', uidInit, (v) => { if (v) step.user_id = v; else delete step.user_id; }, true));
      return;
    }

    // SET ATTRIBUTES
    if (step.set_attributes != null) {
      const wrap = document.createElement('div'); wrap.className = 'field';
      const label = document.createElement('div'); label.className = 'label'; label.textContent = 'attributes (JSON)';
      const ta = document.createElement('textarea'); ta.value = JSON.stringify(step.set_attributes || {}, null, 2);
      ta.addEventListener('blur', () => { const obj = safeParseJson(ta.value); if (obj && typeof obj === 'object') step.set_attributes = obj; });
      wrap.appendChild(label); wrap.appendChild(ta); container.appendChild(wrap);
      return;
    }

    // WEB REQUEST
    if (step.web_request != null) {
      const req = step.web_request || {};
      const urlField = fieldText('url', req.url || '', (v) => { req.url = v; }, true);
      const methodWrap = document.createElement('div'); methodWrap.className = 'field';
      const methodLabel = document.createElement('div'); methodLabel.className = 'label'; methodLabel.textContent = 'method';
      const methodSel = document.createElement('select'); ['GET','POST','PUT','PATCH','DELETE'].forEach((m) => { const o = document.createElement('option'); o.value = m; o.textContent = m; methodSel.appendChild(o); }); methodSel.value = req.method || 'GET';
      methodSel.style.background = 'rgba(17,24,39,0.6)'; methodSel.style.border = '1px solid #1f2937'; methodSel.style.color = '#e5e7eb'; methodSel.style.borderRadius = '8px'; methodSel.style.padding = '4px 6px';
      methodSel.addEventListener('change', () => { req.method = methodSel.value; });
      methodWrap.appendChild(methodLabel); methodWrap.appendChild(methodSel);
      const bodyWrap = document.createElement('div'); bodyWrap.className = 'field';
      const bodyLabel = document.createElement('div'); bodyLabel.className = 'label'; bodyLabel.textContent = 'body JSON';
      const bodyTa = document.createElement('textarea'); bodyTa.value = req.body ? JSON.stringify(req.body, null, 2) : '';
      bodyTa.addEventListener('blur', () => { const obj = safeParseJson(bodyTa.value); if (obj != null) req.body = obj; else delete req.body; });
      bodyWrap.appendChild(bodyLabel); bodyWrap.appendChild(bodyTa);
      const saveField = fieldText('saveAs', req.saveAs || '', (v) => { if (v) req.saveAs = v; else delete req.saveAs; }, true);
      container.appendChild(urlField); container.appendChild(methodWrap); container.appendChild(bodyWrap); container.appendChild(saveField);
      step.web_request = req;
      return;
    }

    // SCRIPTS
    if (step.script != null) {
      const spec = step.script || {};
      const sid = (step && typeof step.step_id === 'string' && step.step_id) ? step.step_id : '';
      // File path (required for save)
      const fileWrap = document.createElement('div'); fileWrap.className = 'field';
      const fileLabel = document.createElement('div'); fileLabel.className = 'label'; fileLabel.textContent = 'file (path)';
      const fileInput = document.createElement('input'); fileInput.type = 'text'; fileInput.placeholder = sid ? scriptFileName(currentFlowKey || 'flow', sid) : 'script_file.js';
      fileInput.value = typeof spec.file === 'string' && spec.file ? spec.file : (sid ? scriptFileName(currentFlowKey || 'flow', sid) : (spec.file || ''));
      fileInput.addEventListener('input', () => { const v = String(fileInput.value || '').trim(); if (!spec || typeof spec !== 'object') step.script = {}; if (v) step.script.file = v; else delete step.script.file; });
      fileWrap.appendChild(fileLabel); fileWrap.appendChild(fileInput); container.appendChild(fileWrap);

      // Code editor (editor-only; not persisted in JSON)
      const codeWrap = document.createElement('div'); codeWrap.className = 'field';
      const codeLabel = document.createElement('div'); codeLabel.className = 'label'; codeLabel.textContent = 'code (JS)';
      const ta = document.createElement('textarea'); ta.value = String(spec.code || ''); ta.placeholder = 'Paste JS code. Use resolve({ ... }) to return variables.';
      ta.addEventListener('input', () => { if (!step.script || typeof step.script !== 'object') step.script = {}; step.script.code = ta.value; });
      codeWrap.appendChild(codeLabel); codeWrap.appendChild(ta); container.appendChild(codeWrap);

      // Timeout
      const wrap = document.createElement('div'); wrap.className = 'field';
      const label = document.createElement('div'); label.className = 'label'; label.textContent = 'timeoutMs';
      const input = document.createElement('input'); input.type = 'number'; input.min = '0'; input.value = String(spec.timeoutMs || '');
      input.addEventListener('input', () => { const n = Number(input.value); if (Number.isFinite(n) && n > 0) spec.timeoutMs = n; else delete spec.timeoutMs; });
      wrap.appendChild(label); wrap.appendChild(input); container.appendChild(wrap);
      step.script = Object.assign({}, spec, { file: fileInput.value || spec.file || (sid ? scriptFileName(currentFlowKey || 'flow', sid) : undefined) });
      return;
    }

    // SHEETS ADD ROW
    if (step.sheets_add_row != null) {
      const cfg = step.sheets_add_row || {};
      const cfgWrap = document.createElement('div'); cfgWrap.className = 'field';
      const l = document.createElement('div'); l.className = 'label'; l.textContent = 'config (JSON)';
      const ta = document.createElement('textarea'); ta.value = JSON.stringify(cfg, null, 2);
      ta.addEventListener('blur', () => { const obj = safeParseJson(ta.value); if (obj && typeof obj === 'object') step.sheets_add_row = obj; });
      cfgWrap.appendChild(l); cfgWrap.appendChild(ta); container.appendChild(cfgWrap);
      const save = String((cfg && cfg.saveAs) || '');
      container.appendChild(fieldText('saveAs', save, (v) => { const obj = step.sheets_add_row || {}; if (v) obj.saveAs = v; else delete obj.saveAs; step.sheets_add_row = obj; }, true));
      return;
    }

    // SHEETS FIND ROW
    if (step.sheets_find_row != null) {
      const cfg = step.sheets_find_row || {};
      const cfgWrap = document.createElement('div'); cfgWrap.className = 'field';
      const l = document.createElement('div'); l.className = 'label'; l.textContent = 'config (JSON)';
      const ta = document.createElement('textarea'); ta.value = JSON.stringify(cfg, null, 2);
      ta.addEventListener('blur', () => { const obj = safeParseJson(ta.value); if (obj && typeof obj === 'object') step.sheets_find_row = obj; });
      cfgWrap.appendChild(l); cfgWrap.appendChild(ta); container.appendChild(cfgWrap);
      const save = String((cfg && cfg.saveAs) || '');
      container.appendChild(fieldText('saveAs', save, (v) => { const obj = step.sheets_find_row || {}; if (v) obj.saveAs = v; else delete obj.saveAs; step.sheets_find_row = obj; }, true));
      return;
    }

    // SHEETS GET ROW
    if (step.sheets_get_row != null) {
      const cfg = step.sheets_get_row || {};
      const cfgWrap = document.createElement('div'); cfgWrap.className = 'field';
      const l = document.createElement('div'); l.className = 'label'; l.textContent = 'config (JSON)';
      const ta = document.createElement('textarea'); ta.value = JSON.stringify(cfg, null, 2);
      ta.addEventListener('blur', () => { const obj = safeParseJson(ta.value); if (obj && typeof obj === 'object') step.sheets_get_row = obj; });
      cfgWrap.appendChild(l); cfgWrap.appendChild(ta); container.appendChild(cfgWrap);
      const save = String((cfg && cfg.saveAs) || '');
      container.appendChild(fieldText('saveAs', save, (v) => { const obj = step.sheets_get_row || {}; if (v) obj.saveAs = v; else delete obj.saveAs; step.sheets_get_row = obj; }, true));
      return;
    }

    // Fallback: details without step_id/filters
    const details = Object.assign({}, step);
    try { delete details.step_id; delete details.filters; } catch (_) {}
    const readOnly = document.createElement('div'); readOnly.className = 'field';
    const label = document.createElement('div'); label.className = 'label'; label.textContent = 'Details';
    const val = document.createElement('div'); val.textContent = JSON.stringify(details, null, 2);
    readOnly.appendChild(label); readOnly.appendChild(val); container.appendChild(readOnly);
  }

  function fieldText(labelText, value, onInput, singleLine = false) {
    const wrap = document.createElement('div');
    wrap.className = 'field';

    const label = document.createElement('div');
    label.className = 'label';
    label.textContent = labelText;

    let input;
    if (singleLine) {
      input = document.createElement('input');
      input.type = 'text';
      input.value = value == null ? '' : String(value);
    } else {
      input = document.createElement('textarea');
      input.value = value == null ? '' : String(value);
    }

    input.addEventListener('input', (e) => onInput(e.target.value));

    wrap.appendChild(label);
    wrap.appendChild(input);
    return wrap;
  }

  // ---- Nested filters: parser, serializer, summary, and modal editor ----
  function filtersToNode(filters) {
    if (filters == null) return null;
    const t = typeof filters;
    if (t === 'string') return { type: 'cond', text: String(filters) };
    if (Array.isArray(filters)) {
      const children = filters.map((f) => filtersToNode(f)).filter(Boolean);
      return { type: 'group', op: 'OR', children };
    }
    if (t === 'object') {
      const andArr = Array.isArray(filters.and) ? filters.and : [];
      const children = andArr.map((f) => filtersToNode(f)).filter(Boolean);
      return { type: 'group', op: 'AND', children };
    }
    return null;
  }

  function normalizeNode(node) {
    if (!node) return null;
    if (node.type === 'cond') {
      const txt = String(node.text || '').trim();
      return txt ? { type: 'cond', text: txt } : null;
    }
    if (node.type === 'group') {
      const op = node.op === 'AND' ? 'AND' : 'OR';
      const children = (node.children || []).map(normalizeNode).filter(Boolean);
      // flatten nested same-op groups
      const flat = [];
      children.forEach((c) => {
        if (c && c.type === 'group' && c.op === op) flat.push(...(c.children || [])); else flat.push(c);
      });
      if (flat.length === 0) return null;
      if (flat.length === 1) return flat[0];
      return { type: 'group', op, children: flat };
    }
    return null;
  }

  function nodeToFilters(node) {
    const n = normalizeNode(node);
    if (!n) return undefined;
    if (n.type === 'cond') return n.text;
    if (n.type === 'group') {
      const parts = (n.children || []).map(nodeToFilters).filter((x) => x != null);
      if (n.op === 'AND') return { and: parts };
      return parts; // OR array
    }
    return undefined;
  }

  function summarizeNode(node) {
    const n = normalizeNode(node);
    if (!n) return '(no filters)';
    if (n.type === 'cond') return n.text;
    const op = n.op;
    const parts = (n.children || []).map((c) => {
      if (c.type === 'cond') return c.text;
      const inner = summarizeNode(c);
      // add parentheses for nested groups
      return '(' + inner + ')';
    });
    return parts.join(op === 'AND' ? ' AND ' : ' OR ');
  }

  function buildFiltersEditor(step, editable) {
    const wrap = document.createElement('div');
    wrap.style.display = 'flex';
    wrap.style.alignItems = 'center';
    wrap.style.gap = '8px';

    function getNode() { return filtersToNode(step.filters); }
    const summary = document.createElement('div');
    summary.style.fontSize = '12px';
    summary.style.color = '#cbd5e1';
    summary.style.maxWidth = '380px';
    summary.style.whiteSpace = 'nowrap';
    summary.style.overflow = 'hidden';
    summary.style.textOverflow = 'ellipsis';
    summary.textContent = summarizeNode(getNode());

    const btn = document.createElement('button');
    btn.className = 'btn';
    btn.textContent = 'Edit filters';
    btn.disabled = !editable;
    btn.addEventListener('click', () => openFiltersModal(step, summary));

    wrap.appendChild(summary);
    wrap.appendChild(btn);
    return wrap;
  }

  function openFiltersModal(step, summaryEl) {
    const overlay = document.createElement('div');
    overlay.style.position = 'fixed'; overlay.style.inset = '0';
    overlay.style.background = 'rgba(0,0,0,0.5)'; overlay.style.zIndex = '1000';

    const dialog = document.createElement('div');
    dialog.className = 'panel';
    dialog.style.position = 'absolute'; dialog.style.top = '10%'; dialog.style.left = '50%'; dialog.style.transform = 'translateX(-50%)';
    dialog.style.width = 'min(860px, 92vw)'; dialog.style.maxHeight = '80vh'; dialog.style.overflow = 'auto'; dialog.style.padding = '12px';

    const header = document.createElement('div'); header.className = 'flow-header';
    const title = document.createElement('div'); title.className = 'flow-title'; title.textContent = 'Edit Filters';
    const actions = document.createElement('div'); actions.className = 'toolbar';
    const btnClose = document.createElement('button'); btnClose.className = 'btn'; btnClose.textContent = 'Close';
    actions.appendChild(btnClose);
    header.appendChild(title); header.appendChild(actions);

    const body = document.createElement('div'); body.className = 'steps';

    let node = filtersToNode(step.filters) || { type: 'group', op: 'AND', children: [] };

    function buildNodeEditor(n) {
      if (!n || n.type === 'cond') {
        const line = document.createElement('div'); line.className = 'field';
        const l = document.createElement('div'); l.className = 'label'; l.textContent = 'condition';
        const ta = document.createElement('textarea'); ta.value = String((n && n.text) || '');
        ta.addEventListener('input', (e) => { if (n) n.text = e.target.value; });
        line.appendChild(l); line.appendChild(ta);
        return line;
      }
      // group editor
      const box = document.createElement('div'); box.className = 'step';
      const head = document.createElement('div'); head.style.display = 'flex'; head.style.alignItems = 'center'; head.style.gap = '8px'; head.style.marginBottom = '8px';
      const opLabel = document.createElement('div'); opLabel.className = 'label'; opLabel.textContent = 'Operator';
      const opSel = document.createElement('select');
      ['AND','OR'].forEach((k) => { const o = document.createElement('option'); o.value = k; o.textContent = k; opSel.appendChild(o); });
      opSel.value = n.op === 'OR' ? 'OR' : 'AND';
      opSel.style.background = 'rgba(17,24,39,0.6)'; opSel.style.border = '1px solid #1f2937'; opSel.style.color = '#e5e7eb'; opSel.style.borderRadius = '8px'; opSel.style.padding = '4px 6px';
      opSel.addEventListener('change', () => { n.op = opSel.value; });
      head.appendChild(opLabel); head.appendChild(opSel);
      box.appendChild(head);

      const childWrap = document.createElement('div'); childWrap.style.display = 'grid'; childWrap.style.gap = '8px';

      function renderChildren() {
        childWrap.innerHTML = '';
        (n.children || []).forEach((c, idx) => {
          const row = document.createElement('div'); row.className = 'field';
          const controls = document.createElement('div'); controls.className = 'label';
          const btnUp = document.createElement('button'); btnUp.className = 'btn'; btnUp.textContent = '↑'; btnUp.style.marginRight = '4px'; btnUp.disabled = idx === 0;
          const btnDown = document.createElement('button'); btnDown.className = 'btn'; btnDown.textContent = '↓'; btnDown.style.marginRight = '4px'; btnDown.disabled = idx >= (n.children.length - 1);
          const btnDel = document.createElement('button'); btnDel.className = 'btn'; btnDel.textContent = 'Delete';
          btnUp.addEventListener('click', () => { const t = n.children[idx-1]; n.children[idx-1] = n.children[idx]; n.children[idx] = t; renderChildren(); });
          btnDown.addEventListener('click', () => { const t = n.children[idx+1]; n.children[idx+1] = n.children[idx]; n.children[idx] = t; renderChildren(); });
          btnDel.addEventListener('click', () => { n.children.splice(idx, 1); renderChildren(); });
          controls.appendChild(btnUp); controls.appendChild(btnDown); controls.appendChild(btnDel);
          const editor = buildNodeEditor(c);
          row.appendChild(controls); row.appendChild(editor);
          childWrap.appendChild(row);
        });
      }

      const addRow = document.createElement('div'); addRow.style.display = 'flex'; addRow.style.gap = '8px'; addRow.style.marginTop = '8px';
      const btnAddCond = document.createElement('button'); btnAddCond.className = 'btn'; btnAddCond.textContent = 'Add condition';
      const btnAddGroup = document.createElement('button'); btnAddGroup.className = 'btn'; btnAddGroup.textContent = 'Add subgroup';
      btnAddCond.addEventListener('click', () => { n.children = n.children || []; n.children.push({ type: 'cond', text: '' }); renderChildren(); });
      btnAddGroup.addEventListener('click', () => { n.children = n.children || []; n.children.push({ type: 'group', op: 'AND', children: [] }); renderChildren(); });
      addRow.appendChild(btnAddCond); addRow.appendChild(btnAddGroup);

      renderChildren();
      box.appendChild(childWrap);
      box.appendChild(addRow);
      return box;
    }

    const editorEl = buildNodeEditor(node);

    const footer = document.createElement('div'); footer.className = 'footer';
    const hint = document.createElement('div'); hint.className = 'hint'; hint.textContent = 'Variables must be written as {{variable}}.';
    const buttons = document.createElement('div');
    const btnClear = document.createElement('button'); btnClear.className = 'btn'; btnClear.textContent = 'Clear';
    const btnSave = document.createElement('button'); btnSave.className = 'btn primary'; btnSave.textContent = 'Save';
    buttons.appendChild(btnClear); buttons.appendChild(btnSave);
    footer.appendChild(hint); footer.appendChild(buttons);

    btnClose.addEventListener('click', () => overlay.remove());
    btnClear.addEventListener('click', () => { node = { type: 'group', op: 'AND', children: [] }; const repl = buildNodeEditor(node); editorEl.replaceWith(repl); body.insertBefore(repl, footer); });
    btnSave.addEventListener('click', () => {
      step.filters = nodeToFilters(node);
      if (summaryEl) summaryEl.textContent = summarizeNode(filtersToNode(step.filters));
      overlay.remove();
    });

    dialog.appendChild(header);
    dialog.appendChild(body);
    body.appendChild(editorEl);
    dialog.appendChild(footer);
    overlay.appendChild(dialog);
    document.body.appendChild(overlay);
  }

  // ---- Add Step (+) UI ----
  function buildInsertBetweenRow(def, insertIndex) {
    const row = document.createElement('div');
    row.style.display = 'flex';
    row.style.alignItems = 'center';
    row.style.justifyContent = 'center';
    row.style.margin = '6px 0';
    row.className = 'insert-row';

    const lineL = document.createElement('div'); lineL.style.flex = '1'; lineL.style.height = '1px'; lineL.style.background = '#1f2937';
    const btn = document.createElement('button');
    btn.className = 'btn';
    btn.textContent = '+';
    btn.title = 'Add step here';
    btn.style.width = '32px'; btn.style.height = '28px'; btn.style.padding = '0';
    btn.addEventListener('click', () => openAddStepModal(def, insertIndex));
    const lineR = document.createElement('div'); lineR.style.flex = '1'; lineR.style.height = '1px'; lineR.style.background = '#1f2937';

    row.appendChild(lineL); row.appendChild(btn); row.appendChild(lineR);
    // Drag-and-drop target for moving selected steps
    row.addEventListener('dragover', (e) => {
      if (!isDraggingSteps) return;
      e.preventDefault();
      row.classList.add('drop-active');
    });
    row.addEventListener('dragleave', () => {
      row.classList.remove('drop-active');
    });
    row.addEventListener('drop', (e) => {
      if (!isDraggingSteps) return;
      e.preventDefault();
      row.classList.remove('drop-active');
      moveSelectedSteps(def, insertIndex);
    });
    return row;
  }

  function moveSelectedSteps(def, insertIndex) {
    try {
      const steps = Array.isArray(def.steps) ? def.steps : [];
      if (steps.length === 0 || selectedSteps.size === 0) return;
      const indices = [];
      const moving = [];
      steps.forEach((st, i) => { if (selectedSteps.has(st)) { indices.push(i); moving.push(st); } });
      if (indices.length === 0) return;
      const minIdx = Math.min(...indices);
      const maxIdx = Math.max(...indices);
      if (insertIndex >= minIdx && insertIndex <= (maxIdx + 1)) return;
      indices.sort((a, b) => b - a).forEach((i) => { steps.splice(i, 1); });
      const removedBefore = indices.filter((i) => i < insertIndex).length;
      const target = Math.max(0, Math.min(insertIndex - removedBefore, steps.length));
      steps.splice(target, 0, ...moving);
      renderSteps();
      try {
        const all = els.steps.querySelectorAll('.step');
        const first = all[target];
        if (first && typeof first.scrollIntoView === 'function') first.scrollIntoView({ block: 'center' });
      } catch (_) {}
    } catch (_) {}
  }

  function closeContextMenu() {
    try {
      if (openContextMenuEl) { openContextMenuEl.remove(); openContextMenuEl = null; }
    } catch (_) { openContextMenuEl = null; }
  }

  function openStepContextMenu(event, def) {
    closeContextMenu();
    const menu = document.createElement('div');
    menu.className = 'panel';
    menu.style.position = 'fixed';
    menu.style.zIndex = '10000';
    menu.style.padding = '6px';
    menu.style.minWidth = '180px';
    menu.style.background = 'rgba(17,24,39,0.98)';
    menu.style.border = '1px solid #1f2937';
    menu.style.borderRadius = '10px';

    const count = selectedSteps.size || 0;

    // Copy JSON of selected steps
    if (count > 0) {
      const btnCopy = document.createElement('button');
      btnCopy.className = 'btn';
      btnCopy.textContent = count > 1 ? `Copy JSON (${count})` : 'Copy JSON';
      btnCopy.style.width = '100%';
      btnCopy.style.marginBottom = '6px';
      btnCopy.addEventListener('click', async () => {
        try {
          const steps = Array.isArray(def.steps) ? def.steps : [];
          const indices = [];
          steps.forEach((st, i) => { if (selectedSteps.has(st)) indices.push(i); });
          indices.sort((a, b) => a - b);
          const payload = indices.map((i) => steps[i]);
          const text = JSON.stringify(payload.length === 1 ? payload[0] : payload, null, 2);
          if (navigator.clipboard && navigator.clipboard.writeText) {
            await navigator.clipboard.writeText(text);
          } else {
            const ta = document.createElement('textarea');
            ta.value = text; document.body.appendChild(ta); ta.select();
            try { document.execCommand('copy'); } catch (_) {}
            ta.remove();
          }
          try { alert(`Copied ${payload.length} step${payload.length === 1 ? '' : 's'} to clipboard.`); } catch (_) {}
        } catch (_) {}
        closeContextMenu();
      });
      menu.appendChild(btnCopy);
    }
    const btnDup = document.createElement('button');
    btnDup.className = 'btn';
    btnDup.textContent = count > 1 ? `Duplicate selected (${count})` : 'Duplicate selected';
    btnDup.style.width = '100%';
    btnDup.style.marginBottom = '6px';
    btnDup.addEventListener('click', () => { try { duplicateSelectedSteps(def); } catch (_) {} closeContextMenu(); });
    menu.appendChild(btnDup);

    const anyDeletedSelected = (() => {
      for (const st of selectedSteps) { if (deletedStepsSet.has(st)) return true; }
      return false;
    })();

    if (count > 0 && !anyDeletedSelected) {
      const btnDel = document.createElement('button');
      btnDel.className = 'btn';
      btnDel.textContent = count > 1 ? `Delete selected (${count})` : 'Delete selected';
      btnDel.style.width = '100%';
      btnDel.addEventListener('click', () => { try { markSelectedStepsDeleted(); } catch (_) {} closeContextMenu(); });
      menu.appendChild(btnDel);
    }

    if (anyDeletedSelected) {
      const btnRestore = document.createElement('button');
      btnRestore.className = 'btn';
      btnRestore.textContent = count > 1 ? `Restore selected (${count})` : 'Restore selected';
      btnRestore.style.width = '100%';
      btnRestore.addEventListener('click', () => { try { restoreSelectedSteps(); } catch (_) {} closeContextMenu(); });
      menu.appendChild(btnRestore);
    }

    const x = event.clientX;
    const y = event.clientY;
    menu.style.left = Math.max(0, Math.min(x, window.innerWidth - 200)) + 'px';
    menu.style.top = Math.max(0, Math.min(y, window.innerHeight - 60)) + 'px';

    document.body.appendChild(menu);
    openContextMenuEl = menu;

    const offClick = (ev) => {
      if (!menu.contains(ev.target)) {
        document.removeEventListener('mousedown', offClick, true);
        document.removeEventListener('scroll', closeContextMenu, true);
        document.removeEventListener('keydown', onKey, true);
        closeContextMenu();
      }
    };
    const onKey = (ev) => { if (ev.key === 'Escape') { offClick(ev); } };
    document.addEventListener('mousedown', offClick, true);
    document.addEventListener('scroll', closeContextMenu, true);
    document.addEventListener('keydown', onKey, true);
  }

  function markSelectedStepsDeleted() {
    if (selectedSteps.size === 0) return;
    for (const st of selectedSteps) deletedStepsSet.add(st);
    renderSteps();
  }

  function restoreSelectedSteps() {
    if (selectedSteps.size === 0) return;
    for (const st of selectedSteps) deletedStepsSet.delete(st);
    renderSteps();
  }

  function duplicateSelectedSteps(def) {
    if (!def || !Array.isArray(def.steps)) return;
    const steps = def.steps;
    if (steps.length === 0 || selectedSteps.size === 0) return;

    // Collect selected indices and originals in increasing order
    const selectedIndices = [];
    steps.forEach((st, i) => { if (selectedSteps.has(st)) selectedIndices.push(i); });
    if (selectedIndices.length === 0) return;
    selectedIndices.sort((a, b) => a - b);

    const insertAfter = Math.max(...selectedIndices);

    // Existing step_id set
    const existingIds = new Set();
    steps.forEach((s) => { if (s && typeof s.step_id === 'string' && s.step_id) existingIds.add(s.step_id); });

    function genId() {
      const alphabet = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
      let out = '';
      for (let i = 0; i < 8; i++) out += alphabet.charAt(Math.floor(Math.random() * alphabet.length));
      return out;
    }

    const clones = selectedIndices.map((i) => {
      const original = steps[i];
      const cloned = JSON.parse(JSON.stringify(original));
      // Ensure a unique step_id
      try {
        let id = '';
        do { id = genId(); } while (existingIds.has(id));
        cloned.step_id = id;
        existingIds.add(id);
      } catch (_) {}
      return cloned;
    });

    const target = Math.min(insertAfter + 1, steps.length);
    steps.splice(target, 0, ...clones);

    // Select the new clones
    selectedSteps.clear();
    clones.forEach((c) => selectedSteps.add(c));
    lastSelectedIndex = target + clones.length - 1;

    renderSteps();
    // Scroll to first of new clones
    try {
      const all = els.steps.querySelectorAll('.step');
      const first = all[target];
      if (first && typeof first.scrollIntoView === 'function') first.scrollIntoView({ block: 'center' });
    } catch (_) {}
  }

  function openAddStepModal(def, insertIndex) {
    const overlay = document.createElement('div'); overlay.style.position = 'fixed'; overlay.style.inset = '0'; overlay.style.background = 'rgba(0,0,0,0.5)'; overlay.style.zIndex = '1000';
    const dialog = document.createElement('div'); dialog.className = 'panel'; dialog.style.position = 'absolute'; dialog.style.top = '10%'; dialog.style.left = '50%'; dialog.style.transform = 'translateX(-50%)'; dialog.style.width = 'min(860px, 92vw)'; dialog.style.maxHeight = '80vh'; dialog.style.overflow = 'auto'; dialog.style.padding = '12px';

    const header = document.createElement('div'); header.className = 'flow-header';
    const title = document.createElement('div'); title.className = 'flow-title'; title.textContent = 'Add Step';
    const actions = document.createElement('div'); actions.className = 'toolbar';
    const btnClose = document.createElement('button'); btnClose.className = 'btn'; btnClose.textContent = 'Close';
    actions.appendChild(btnClose); header.appendChild(title); header.appendChild(actions);

    const body = document.createElement('div'); body.className = 'steps';

    // Type selector
    const typeField = document.createElement('div'); typeField.className = 'field';
    const typeLabel = document.createElement('div'); typeLabel.className = 'label'; typeLabel.textContent = 'Type';
    const typeSel = document.createElement('select');
    const types = [
      { v: 'say', n: 'Say (bot message)' },
      { v: 'ask', n: 'Ask (await user answer)' },
      { v: 'wait', n: 'Wait' },
      { v: 'label', n: 'Label' },
      { v: 'goto', n: 'Goto (jump to label)' },
      { v: 'trigger', n: 'Trigger another flow' },
      { v: 'set_attributes', n: 'Set attributes' },
      { v: 'web_request', n: 'Web request' },
      { v: 'sheets_add_row', n: 'Sheets: add row' },
      { v: 'sheets_find_row', n: 'Sheets: find row' },
      { v: 'sheets_get_row', n: 'Sheets: get row' },
      { v: 'script', n: 'Run script' },
      { v: 'from_json', n: 'From JSON' }
    ];
    types.forEach((t) => { const o = document.createElement('option'); o.value = t.v; o.textContent = t.n; typeSel.appendChild(o); });
    typeField.appendChild(typeLabel); typeField.appendChild(typeSel);

    // Dynamic form container
    const formWrap = document.createElement('div');

    function field(label, inputEl) {
      const f = document.createElement('div'); f.className = 'field';
      const l = document.createElement('div'); l.className = 'label'; l.textContent = label;
      f.appendChild(l); f.appendChild(inputEl); return f;
    }

    function rebuildForm() {
      formWrap.innerHTML = '';
      const t = typeSel.value;
      if (t === 'say') {
        const ta = document.createElement('textarea');
        ta.placeholder = 'Message text (supports {{variables}})';
        const uid = document.createElement('input'); uid.type = 'text'; uid.placeholder = 'user_id (optional, supports {{variables}})';
        formWrap.appendChild(field('say', ta));
        formWrap.appendChild(field('user_id', uid));
      } else if (t === 'ask') {
        const ta = document.createElement('textarea'); ta.placeholder = 'Question text';
        const save = document.createElement('input'); save.type = 'text'; save.placeholder = 'Variable name (saveAs)';
        const kb = document.createElement('textarea'); kb.placeholder = 'Keyboard options (one per line, optional)';
        const ver = document.createElement('select'); ['','strict'].forEach((v) => { const o = document.createElement('option'); o.value = v; o.textContent = v || '(none)'; ver.appendChild(o); });
        formWrap.appendChild(field('ask', ta));
        formWrap.appendChild(field('saveAs', save));
        formWrap.appendChild(field('keyboard', kb));
        formWrap.appendChild(field('verification', ver));
      } else if (t === 'wait') {
        const secs = document.createElement('input'); secs.type = 'number'; secs.placeholder = 'Seconds'; secs.min = '0';
        formWrap.appendChild(field('seconds', secs));
      } else if (t === 'label') {
        const i = document.createElement('input'); i.type = 'text'; i.placeholder = 'Label name';
        formWrap.appendChild(field('label', i));
      } else if (t === 'goto') {
        const i = document.createElement('input'); i.type = 'text'; i.placeholder = 'Target label name';
        formWrap.appendChild(field('goto', i));
      } else if (t === 'trigger') {
        const i = document.createElement('input'); i.type = 'text'; i.placeholder = 'Flow key or /trigger';
        const uid = document.createElement('input'); uid.type = 'text'; uid.placeholder = 'user_id (optional, supports {{variables}})';
        formWrap.appendChild(field('trigger', i));
        formWrap.appendChild(field('user_id', uid));
      } else if (t === 'set_attributes') {
        const ta = document.createElement('textarea'); ta.placeholder = '{ "name": "{{name}}" }';
        formWrap.appendChild(field('attributes (JSON object)', ta));
      } else if (t === 'web_request') {
        const url = document.createElement('input'); url.type = 'text'; url.placeholder = 'https://api.example.com';
        const method = document.createElement('select'); ['GET','POST','PUT','PATCH','DELETE'].forEach((m) => { const o = document.createElement('option'); o.value = m; o.textContent = m; method.appendChild(o); });
        const body = document.createElement('textarea'); body.placeholder = '{ "foo": "bar" } (optional)';
        const save = document.createElement('input'); save.type = 'text'; save.placeholder = 'saveAs (optional)';
        formWrap.appendChild(field('url', url));
        formWrap.appendChild(field('method', method));
        formWrap.appendChild(field('body JSON', body));
        formWrap.appendChild(field('saveAs', save));
      } else if (t === 'sheets_add_row') {
        const ta = document.createElement('textarea'); ta.placeholder = '{ "spreadsheetId": "...", "sheet": "Sheet1", "values": {"A": "{{name}}"} }';
        const save = document.createElement('input'); save.type = 'text'; save.placeholder = 'saveAs (optional)';
        formWrap.appendChild(field('config (JSON)', ta));
        formWrap.appendChild(field('saveAs', save));
      } else if (t === 'sheets_find_row') {
        const ta = document.createElement('textarea'); ta.placeholder = '{ "spreadsheetId": "...", "sheet": "Sheet1", "where": {"A": "{{email}}"} }';
        const save = document.createElement('input'); save.type = 'text'; save.placeholder = 'saveAs (optional)';
        formWrap.appendChild(field('config (JSON)', ta));
        formWrap.appendChild(field('saveAs', save));
      } else if (t === 'sheets_get_row') {
        const ta = document.createElement('textarea'); ta.placeholder = '{ "spreadsheetId": "...", "sheet": "Sheet1", "row": {{rowNum}} }';
        const save = document.createElement('input'); save.type = 'text'; save.placeholder = 'saveAs (optional)';
        formWrap.appendChild(field('config (JSON)', ta));
        formWrap.appendChild(field('saveAs', save));
      } else if (t === 'script') {
        const file = document.createElement('input'); file.type = 'text'; file.placeholder = 'script file (e.g., script_flow_step.js)';
        const code = document.createElement('textarea'); code.placeholder = '// JS code (editor-only). Call resolve({ key: value }) to return values'; code.style.minHeight = '160px';
        const timeout = document.createElement('input'); timeout.type = 'number'; timeout.placeholder = 'timeoutMs (optional)'; timeout.min = '0';
        formWrap.appendChild(field('file', file));
        formWrap.appendChild(field('code', code));
        formWrap.appendChild(field('timeoutMs', timeout));
      } else if (t === 'from_json') {
        const ta = document.createElement('textarea');
        ta.placeholder = 'Paste a step object or an array of steps JSON';
        ta.style.minHeight = '160px';
        formWrap.appendChild(field('JSON', ta));
      }
    }

    rebuildForm();
    typeSel.addEventListener('change', rebuildForm);

    const footer = document.createElement('div'); footer.className = 'footer';
    const hint = document.createElement('div'); hint.className = 'hint'; hint.textContent = 'Fill fields; variables use {{name}}.';
    const actions2 = document.createElement('div');
    const btnAdd = document.createElement('button'); btnAdd.className = 'btn primary'; btnAdd.textContent = 'Add step';
    actions2.appendChild(btnAdd);
    footer.appendChild(hint); footer.appendChild(actions2);

    function parseJsonSafe(txt) { try { return JSON.parse(txt); } catch (_) { return null; } }

    btnAdd.addEventListener('click', () => {
      const t = typeSel.value;
      let step = {};
      const q = (sel) => formWrap.querySelector(sel);
      if (t === 'say') {
        step.say = String((q('textarea') || {}).value || '');
        const inputs = formWrap.querySelectorAll('input[type="text"]');
        const uid = inputs && inputs[0];
        if (uid && uid.value) step.user_id = String(uid.value);
      } else if (t === 'ask') {
        const ta = q('textarea'); const save = formWrap.querySelector('input[type="text"]');
        const areas = formWrap.querySelectorAll('textarea');
        const kb = areas.length > 1 ? areas[1] : null;
        const ver = formWrap.querySelector('select');
        step.ask = String((ta && ta.value) || '');
        if (save && save.value) step.saveAs = String(save.value);
        if (kb && kb.value) step.keyboard = kb.value.split(/\r?\n/).map((s) => s.trim()).filter((s) => s.length > 0);
        if (ver && ver.value) step.verification = ver.value;
      } else if (t === 'wait') {
        const secs = formWrap.querySelector('input[type="number"]');
        const n = Number(secs && secs.value);
        step.wait = Number.isFinite(n) ? { seconds: n } : { seconds: 1 };
      } else if (t === 'label') {
        const i = formWrap.querySelector('input[type="text"]'); step.label = String((i && i.value) || 'label');
      } else if (t === 'goto') {
        const i = formWrap.querySelector('input[type="text"]'); step.goto = String((i && i.value) || 'label');
      } else if (t === 'trigger') {
        const inputs = formWrap.querySelectorAll('input[type="text"]');
        const trg = inputs && inputs[0];
        const uid = inputs && inputs[1];
        step.trigger = String((trg && trg.value) || '');
        if (uid && uid.value) step.user_id = String(uid.value);
      } else if (t === 'set_attributes') {
        const ta = formWrap.querySelector('textarea'); const obj = parseJsonSafe(ta && ta.value || '{}'); step.set_attributes = obj || {};
      } else if (t === 'web_request') {
        const inputs = formWrap.querySelectorAll('input'); const url = inputs[0]; const save = inputs[1];
        const method = formWrap.querySelector('select'); const body = formWrap.querySelector('textarea');
        const req = { url: String((url && url.value) || '') };
        req.method = method && method.value ? method.value : 'GET';
        const bodyObj = parseJsonSafe(body && body.value || ''); if (bodyObj) req.body = bodyObj;
        if (save && save.value) req.saveAs = String(save.value);
        step.web_request = req;
      } else if (t === 'sheets_add_row') {
        const ta = formWrap.querySelector('textarea'); const obj = parseJsonSafe(ta && ta.value || '{}');
        const save = formWrap.querySelector('input[type="text"]');
        step.sheets_add_row = obj || {};
        if (save && save.value) step.sheets_add_row.saveAs = String(save.value);
      } else if (t === 'sheets_find_row') {
        const ta = formWrap.querySelector('textarea'); const obj = parseJsonSafe(ta && ta.value || '{}');
        const save = formWrap.querySelector('input[type="text"]');
        step.sheets_find_row = obj || {};
        if (save && save.value) step.sheets_find_row.saveAs = String(save.value);
      } else if (t === 'sheets_get_row') {
        const ta = formWrap.querySelector('textarea'); const obj = parseJsonSafe(ta && ta.value || '{}');
        const save = formWrap.querySelector('input[type="text"]');
        step.sheets_get_row = obj || {};
        if (save && save.value) step.sheets_get_row.saveAs = String(save.value);
      } else if (t === 'script') {
        const inputs = formWrap.querySelectorAll('input');
        const ta = formWrap.querySelector('textarea');
        const fileInput = inputs && inputs[0];
        const timeout = inputs && inputs[1] && inputs[1].type === 'number' ? inputs[1] : formWrap.querySelector('input[type="number"]');
        const spec = {};
        const fileVal = String((fileInput && fileInput.value) || '').trim();
        if (fileVal) spec.file = fileVal;
        const n = Number(timeout && timeout.value);
        if (Number.isFinite(n) && n > 0) spec.timeoutMs = n;
        // Keep code only in editor's memory; runtime JSON will strip it on save
        const codeVal = String((ta && ta.value) || '');
        if (codeVal) spec.code = codeVal;
        step.script = spec;
      } else if (t === 'from_json') {
        const ta = formWrap.querySelector('textarea');
        const txt = String((ta && ta.value) || '').trim();
        if (!txt) { alert('Paste JSON first.'); return; }
        let parsed = null;
        try { parsed = JSON.parse(txt); } catch (e) { alert('Invalid JSON: ' + e.message); return; }
        let stepsToInsert = [];
        if (Array.isArray(parsed)) stepsToInsert = parsed;
        else if (parsed && typeof parsed === 'object') stepsToInsert = [parsed];
        else { alert('JSON must be an object or an array of objects.'); return; }
        if (!Array.isArray(def.steps)) def.steps = [];
        // Build existing id set
        const existingIds = new Set();
        def.steps.forEach((s) => { if (s && typeof s.step_id === 'string' && s.step_id) existingIds.add(s.step_id); });
        function genId() {
          const alphabet = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
          let out = '';
          for (let i = 0; i < 8; i++) out += alphabet.charAt(Math.floor(Math.random() * alphabet.length));
          return out;
        }
        // Normalize and ensure unique step_id on incoming steps
        const normalized = stepsToInsert.map((s) => {
          const clone = JSON.parse(JSON.stringify(s || {}));
          if (!clone || typeof clone !== 'object') return {};
          if (typeof clone.step_id === 'string' && clone.step_id) {
            if (existingIds.has(clone.step_id)) {
              let id = '';
              do { id = genId(); } while (existingIds.has(id));
              clone.step_id = id;
            }
            existingIds.add(clone.step_id);
          } else {
            let id = '';
            do { id = genId(); } while (existingIds.has(id));
            clone.step_id = id;
            existingIds.add(id);
          }
          return clone;
        });
        const pos = Math.max(0, Math.min(insertIndex, def.steps.length));
        def.steps.splice(pos, 0, ...normalized);
        overlay.remove();
        renderSteps();
        return;
      }

      if (!Array.isArray(def.steps)) def.steps = [];
      const pos = Math.max(0, Math.min(insertIndex, def.steps.length));
      def.steps.splice(pos, 0, step);
      overlay.remove();
      renderSteps();
    });

    dialog.appendChild(header);
    dialog.appendChild(body);
    body.appendChild(typeField);
    body.appendChild(formWrap);
    dialog.appendChild(footer);
    overlay.appendChild(dialog);
    document.body.appendChild(overlay);

    btnClose.addEventListener('click', () => overlay.remove());
  }

  // ---- Create Flow UI ----
  function openCreateFlowModal() {
    const overlay = document.createElement('div'); overlay.style.position = 'fixed'; overlay.style.inset = '0'; overlay.style.background = 'rgba(0,0,0,0.5)'; overlay.style.zIndex = '1000';
    const dialog = document.createElement('div'); dialog.className = 'panel'; dialog.style.position = 'absolute'; dialog.style.top = '12%'; dialog.style.left = '50%'; dialog.style.transform = 'translateX(-50%)'; dialog.style.width = 'min(720px, 92vw)'; dialog.style.maxHeight = '80vh'; dialog.style.overflow = 'auto'; dialog.style.padding = '12px';

    const header = document.createElement('div'); header.className = 'flow-header';
    const title = document.createElement('div'); title.className = 'flow-title'; title.textContent = 'Create New Flow';
    const actions = document.createElement('div'); actions.className = 'toolbar';
    const btnClose = document.createElement('button'); btnClose.className = 'btn'; btnClose.textContent = 'Close';
    actions.appendChild(btnClose); header.appendChild(title); header.appendChild(actions);

    const body = document.createElement('div'); body.className = 'steps';

    function row(labelText, inputEl) {
      const r = document.createElement('div'); r.className = 'field';
      const l = document.createElement('div'); l.className = 'label'; l.textContent = labelText; r.appendChild(l); r.appendChild(inputEl); return r;
    }

    const keyInput = document.createElement('input'); keyInput.type = 'text'; keyInput.placeholder = 'flow key (e.g., orders)';
    const typeSel = document.createElement('select');
    ;[['chat','Chat (triggered by command)'], ['webhook','Webhook (headless)'], ['error_handler','Error handler (called on errors)']].forEach(([v, n]) => { const o = document.createElement('option'); o.value = v; o.textContent = n; typeSel.appendChild(o); });
    const triggerInput = document.createElement('input'); triggerInput.type = 'text'; triggerInput.placeholder = '/orders (for chat) or orders (for webhook)';
    const descInput = document.createElement('input'); descInput.type = 'text'; descInput.placeholder = 'optional description';

    function updateTriggerPlaceholder() {
      if (typeSel.value === 'webhook') triggerInput.placeholder = 'orders (webhook name)';
      else if (typeSel.value === 'error_handler') triggerInput.placeholder = '(not used)';
      else triggerInput.placeholder = '/orders (Telegram command)';
    }
    typeSel.addEventListener('change', updateTriggerPlaceholder);
    updateTriggerPlaceholder();

    body.appendChild(row('key', keyInput));
    body.appendChild(row('type', typeSel));
    body.appendChild(row('trigger', triggerInput));
    body.appendChild(row('description', descInput));

    const footer = document.createElement('div'); footer.className = 'footer';
    const hint = document.createElement('div'); hint.className = 'hint'; hint.textContent = 'Keys must be letters/numbers/_- and unique.';
    const buttons = document.createElement('div');
    const btnCreate = document.createElement('button'); btnCreate.className = 'btn primary'; btnCreate.textContent = 'Create';
    buttons.appendChild(btnCreate);
    footer.appendChild(hint); footer.appendChild(buttons);

    btnClose.addEventListener('click', () => overlay.remove());
    btnCreate.addEventListener('click', async () => {
      try {
        const key = String(keyInput.value || '').trim();
        const type = typeSel.value === 'webhook' ? 'webhook' : (typeSel.value === 'error_handler' ? 'error_handler' : 'chat');
        const trigger = String(triggerInput.value || '').trim();
        const description = String(descInput.value || '').trim();
        if (!key) { alert('Enter a flow key'); return; }
        if (!/^[a-zA-Z0-9_\-]+$/.test(key)) { alert('Key may contain only letters, numbers, _ or -'); return; }
        if (Array.isArray(flowKeys) && flowKeys.includes(key)) { alert('A flow with this key already exists'); return; }

        // Build minimal definition
        const def = { description, steps: [] };
        if (type === 'webhook') {
          def.type = 'webhook';
          def.trigger = trigger || key;
        } else if (type === 'error_handler') {
          def.type = 'error_handler';
          // No trigger; this flow is invoked programmatically with variables
          def.description = def.description || 'Handles errors from other flows';
        } else {
          def.trigger = trigger || ('/' + key);
          def.steps = [{ say: 'Hello! This is a new flow.' }];
        }

        // Apply to editor state (merge, do not overwrite other flows)
        if (!flowDoc || !flowDoc.flows) flowDoc = { flows: {} };
        flowDoc.flows[key] = def;
        currentFlowKey = key;
        // Update list and UI
        try {
          if (!Array.isArray(flowKeys)) flowKeys = [];
          if (!flowKeys.includes(key)) flowKeys.push(key);
          flowKeys = Array.from(new Set(flowKeys)).sort();
        } catch (_) {}
        renderFlows();
        renderSteps();

        // If signed in, publish immediately to create file and update versions
        if (hasValidToken()) {
          await saveCurrentFlowToCloudWithBackup();
        } else {
          alert('Flow created locally. Sign in and click Publish to upload and update versions.');
        }
        overlay.remove();
      } catch (e) {
        alert('Failed to create flow: ' + (e && e.message ? e.message : e));
      }
    });

    dialog.appendChild(header);
    dialog.appendChild(body);
    dialog.appendChild(footer);
    overlay.appendChild(dialog);
    document.body.appendChild(overlay);
  }

  function downloadJson(obj, filename) {
    const json = JSON.stringify(obj, null, 2);
    const blob = new Blob([json], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    setTimeout(() => {
      URL.revokeObjectURL(url);
      a.remove();
    }, 0);
  }

  async function saveCurrentFlowToCloudWithBackup() {
    if (!flowDoc || !currentFlowKey) return alert('Select a flow first.');
    const def = (flowDoc.flows && flowDoc.flows[currentFlowKey]) || null;
    if (!def) return alert('Nothing to save.');
    const { bucket } = getCfg();
    if (!bucket) return alert('Please configure Bucket.');
    if (!hasValidToken()) { alert('Please sign in first.'); return; }
    // Ensure each step has a unique 8-char step_id before saving
    try {
      // Apply local deletions before generating IDs and saving
      if (def && Array.isArray(def.steps) && deletedStepsSet.size > 0) {
        const filtered = def.steps.filter((s) => !deletedStepsSet.has(s));
        if (filtered.length !== def.steps.length) {
          def.steps = filtered;
          // Update selection to remove references to deleted steps
          const still = new Set(filtered);
          Array.from(selectedSteps).forEach((st) => { if (!still.has(st)) selectedSteps.delete(st); });
        }
        deletedStepsSet.clear();
      }
      const existing = new Set();
      function genId() {
        const alphabet = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
        let out = '';
        for (let i = 0; i < 8; i++) out += alphabet.charAt(Math.floor(Math.random() * alphabet.length));
        return out;
      }
      if (def && Array.isArray(def.steps)) {
        // collect existing ids first to avoid duplicates
        def.steps.forEach((s) => { if (s && typeof s.step_id === 'string' && s.step_id.length > 0) existing.add(s.step_id); });
        def.steps.forEach((s) => {
          if (!s || (typeof s.step_id === 'string' && s.step_id.length > 0)) return;
          let id = '';
          do { id = genId(); } while (existing.has(id));
          s.step_id = id;
          existing.add(id);
        });
      }
    } catch (_) {}
    try {
      const token = oauth.accessToken;
      const mainPath = `flows/${currentFlowKey}.json`;
      // 1) Read current file; if present, back it up using its own updated_at
      let currentText = null;
      let previousUpdatedAt = '';
      try {
        const getRes = await fetch(gcsDownloadUrl(bucket, mainPath), { headers: { Authorization: `Bearer ${token}` }, cache: 'no-store' });
        if (getRes.ok) currentText = await getRes.text();
      } catch (_) {}
      if (currentText != null) {
        try {
          const json = JSON.parse(currentText);
          let prevDef = null;
          if (json && json.flows && json.flows[currentFlowKey]) prevDef = json.flows[currentFlowKey];
          else if (json && json[currentFlowKey]) prevDef = json[currentFlowKey];
          else prevDef = json;
          if (prevDef && typeof prevDef.updated_at === 'string') previousUpdatedAt = prevDef.updated_at;
        } catch (_) {}
        const tsForBackup = previousUpdatedAt || formatUtcNowForFlow();
        const backupName = formatBackupName(currentFlowKey, tsForBackup);
        const upBackup = await fetch(gcsUploadUrl(bucket, backupName), {
          method: 'POST',
          headers: { 'Authorization': `Bearer ${token}`, 'Content-Type': 'application/json' },
          body: currentText
        });
        if (!upBackup.ok) console.warn('Backup upload failed');
      }
      // Prepare new timestamp for this save (also used for script backups when code changes)
      const newTimestampUtc = formatUtcNowForFlow();
      try { def.updated_at = newTimestampUtc; } catch (_) {}

      // 2) For each script step: upload code to scripts/, create backup of previous if code changed, and set file reference; do not store inline code in JSON
      let stepsForRestore = null;
      let scriptCodesByIdForRestore = null;
      try {
        const steps = Array.isArray(def.steps) ? def.steps : [];
        const scriptCodesById = new Map();
        for (const st of steps) {
          if (!st || st.script == null) continue;
          const sid = (st && typeof st.step_id === 'string' && st.step_id) ? st.step_id : '';
          if (!sid) continue;
          const spec = st.script || {};
          const code = typeof spec.code === 'string' ? spec.code : '';
          const fileName = typeof spec.file === 'string' && spec.file ? spec.file : scriptFileName(currentFlowKey, sid);
          const objectPath = toScriptObjectPathFromSpec(fileName);
          let existingText = null;
          try {
            const getRes = await fetch(gcsDownloadUrl(bucket, objectPath), { headers: { Authorization: `Bearer ${token}` }, cache: 'no-store' });
            if (getRes.ok) existingText = await getRes.text();
          } catch (_) {}
          if (code && existingText != null && existingText !== code) {
            // Backup previous to scripts/backups with current flow version timestamp
            const backupPath = scriptBackupObjectPath(currentFlowKey, sid, newTimestampUtc);
            try {
              await fetch(gcsUploadUrl(bucket, backupPath), {
                method: 'POST', headers: { 'Authorization': `Bearer ${token}`, 'Content-Type': 'application/javascript; charset=utf-8' }, body: existingText
              });
            } catch (_) {}
          }
          // Upload new code only if provided in the editor
          if (code) {
            try {
              await fetch(gcsUploadUrl(bucket, objectPath), {
                method: 'POST', headers: { 'Authorization': `Bearer ${token}`, 'Content-Type': 'application/javascript; charset=utf-8' }, body: code
              });
            } catch (_) {}
            scriptCodesById.set(sid, code);
          }
          // Replace inline code with file reference for stored flow
          st.script = Object.assign({}, spec, { file: fileName });
          try { delete st.script.code; } catch (_) {}
        }
        // Defer restoring code until after we upload sanitized JSON
        stepsForRestore = steps;
        scriptCodesByIdForRestore = scriptCodesById;
      } catch (_) {}

      // 3) Upload new content (store as single-flow object)
      const newBody = JSON.stringify(def, null, 2);
      const upMain = await fetch(gcsUploadUrl(bucket, mainPath), {
        method: 'POST',
        headers: { 'Authorization': `Bearer ${token}`, 'Content-Type': 'application/json' },
        body: newBody
      });
      if (!upMain.ok) throw new Error('Upload failed');

      // 4) Update versions file within flows prefix (flows/versions.txt)
      try {
        const versionsPath = 'flows/versions.txt';
        // Read existing text if any
        let existing = '';
        try {
          const resV = await fetch(gcsDownloadUrl(bucket, versionsPath), { headers: { Authorization: `Bearer ${token}` }, cache: 'no-store' });
          if (resV.ok) existing = await resV.text();
        } catch (_) {}
        // Convert to map, update, and serialize back to key=value lines
        const map = {};
        String(existing || '')
          .split(/\r?\n/)
          .map((l) => l.trim())
          .filter((l) => l && !l.startsWith('#') && !l.startsWith('//'))
          .forEach((line) => {
            const idx = line.indexOf('=');
            if (idx <= 0) return;
            const k = line.slice(0, idx).trim();
            const v = line.slice(idx + 1).trim();
            if (k) map[k] = v;
          });
        map[currentFlowKey] = newTimestampUtc;
        const bodyV = Object.entries(map).map(([k, v]) => `${k}=${v}`).join('\n') + '\n';
        await fetch(gcsUploadUrl(bucket, versionsPath), {
          method: 'POST',
          headers: { 'Authorization': `Bearer ${token}`, 'Content-Type': 'text/plain; charset=utf-8' },
          body: bodyV
        });
      } catch (_) {}

      // Restore editor-only inline code back into in-memory def for UX
      try {
        if (stepsForRestore && scriptCodesByIdForRestore) {
          for (const st of stepsForRestore) {
            if (!st || st.script == null) continue;
            const sid = (st && typeof st.step_id === 'string' && st.step_id) ? st.step_id : '';
            if (sid && scriptCodesByIdForRestore.has(sid)) {
              if (typeof st.script !== 'object' || st.script == null) st.script = {};
              st.script.code = scriptCodesByIdForRestore.get(sid);
            }
          }
        }
      } catch (_) {}
      alert('Saved to Cloud.');
      try { renderSteps(); } catch (_) {}
    } catch (e) {
      console.error(e);
      alert('Save failed: ' + e.message);
    }
  }

  async function deleteCurrentFlow() {
    try {
      if (!currentFlowKey) { alert('Select a flow first.'); return; }
      const key = currentFlowKey;
      const sure = confirm(`Delete flow "${key}"? This will permanently delete flows/${key}.json from the bucket.`);
      if (!sure) return;
      const { bucket } = getCfg();
      if (!bucket) { alert('Please configure Bucket.'); return; }
      if (!hasValidToken()) { alert('Please sign in first.'); return; }
      const token = oauth.accessToken;
      const mainPath = `flows/${key}.json`;

      // Best-effort: back up current content before delete
      let currentText = null;
      let previousUpdatedAt = '';
      try {
        const getRes = await fetch(gcsDownloadUrl(bucket, mainPath), { headers: { Authorization: `Bearer ${token}` }, cache: 'no-store' });
        if (getRes.ok) currentText = await getRes.text();
      } catch (_) {}
      if (currentText != null) {
        try {
          const json = JSON.parse(currentText);
          let prevDef = null;
          if (json && json.flows && json.flows[key]) prevDef = json.flows[key];
          else if (json && json[key]) prevDef = json[key];
          else prevDef = json;
          if (prevDef && typeof prevDef.updated_at === 'string') previousUpdatedAt = prevDef.updated_at;
        } catch (_) {}
        const tsForBackup = previousUpdatedAt || formatUtcNowForFlow();
        const backupName = formatBackupName(key, tsForBackup);
        try {
          await fetch(gcsUploadUrl(bucket, backupName), { method: 'POST', headers: { 'Authorization': `Bearer ${token}`, 'Content-Type': 'application/json' }, body: currentText });
        } catch (_) {}
      }

      // Delete the flow object
      const delRes = await fetch(gcsDeleteUrl(bucket, mainPath), { method: 'DELETE', headers: { Authorization: `Bearer ${token}` } });
      if (!delRes.ok && delRes.status !== 404) throw new Error('Delete failed');

      // Update versions.txt: remove key
      try {
        const versionsPath = 'flows/versions.txt';
        let existing = '';
        try {
          const resV = await fetch(gcsDownloadUrl(bucket, versionsPath), { headers: { Authorization: `Bearer ${token}` }, cache: 'no-store' });
          if (resV.ok) existing = await resV.text();
        } catch (_) {}
        const map = {};
        String(existing || '')
          .split(/\r?\n/)
          .map((l) => l.trim())
          .filter((l) => l && !l.startsWith('#') && !l.startsWith('//'))
          .forEach((line) => {
            const idx = line.indexOf('=');
            if (idx <= 0) return;
            const k = line.slice(0, idx).trim();
            const v = line.slice(idx + 1).trim();
            if (k) map[k] = v;
          });
        try { delete map[key]; } catch (_) {}
        const bodyV = Object.entries(map).map(([k, v]) => `${k}=${v}`).join('\n') + (Object.keys(map).length ? '\n' : '');
        await fetch(gcsUploadUrl(bucket, versionsPath), { method: 'POST', headers: { 'Authorization': `Bearer ${token}`, 'Content-Type': 'text/plain; charset=utf-8' }, body: bodyV });
      } catch (_) {}

      // Update local state and UI
      try { if (flowDoc && flowDoc.flows) delete flowDoc.flows[key]; } catch (_) {}
      try { flowKeys = (Array.isArray(flowKeys) ? flowKeys.filter((k) => k !== key) : []); } catch (_) {}
      currentFlowKey = null;
      ensureVersionsPanelVisible(false);
      renderFlows();
      renderSteps();
      alert('Flow deleted.');
    } catch (e) {
      console.error(e);
      alert('Delete failed: ' + (e && e.message ? e.message : e));
    }
  }

  function loadStoredTokenOnly() {
    try {
      const stored = JSON.parse(localStorage.getItem('gcs_token') || '{}');
      const { accessToken, tokenExpiresAt } = stored;
      if (accessToken && Number.isFinite(tokenExpiresAt)) {
        oauth.accessToken = accessToken;
        oauth.tokenExpiresAt = tokenExpiresAt;
      }
    } catch (_) {}
    updateAuthStatus();
  }

  function hasValidToken() {
    return !!(oauth.accessToken && Date.now() < oauth.tokenExpiresAt - 5000);
  }

  function handleImportFile(file) {
    const reader = new FileReader();
    reader.onload = () => {
      try {
        const data = JSON.parse(reader.result);
        if (!data || typeof data !== 'object' || !data.flows) {
          throw new Error('Invalid structure: expected root object with "flows"');
        }
        flowDoc = data;
        currentFlowKey = null;
        renderFlows();
        renderSteps();
      } catch (e) {
        alert('Invalid JSON: ' + e.message);
      }
    };
    reader.readAsText(file);
  }

  // Events
  els.fileInput.addEventListener('change', (e) => {
    const file = e.target.files && e.target.files[0];
    if (file) handleImportFile(file);
    e.target.value = '';
  });
  els.btnPublish.addEventListener('click', saveCurrentFlowToCloudWithBackup);
  els.btnAuth.addEventListener('click', async () => {
    try { await getAccessToken(true); } catch (e) { alert('Auth failed: ' + e.message); }
  });
  els.btnSignOut.addEventListener('click', signOut);
  if (els.btnSignOutHeader) els.btnSignOutHeader.addEventListener('click', signOut);
  if (els.btnNewFlow) els.btnNewFlow.addEventListener('click', openCreateFlowModal);
  if (els.btnBrowseVersions) els.btnBrowseVersions.addEventListener('click', async () => {
    ensureVersionsPanelVisible(true);
    await loadVersionsFirstPage();
  });
  if (els.btnDeleteFlow) els.btnDeleteFlow.addEventListener('click', deleteCurrentFlow);
  if (els.btnLoadMoreVersions) els.btnLoadMoreVersions.addEventListener('click', loadMoreVersions);
  if (els.btnCloseVersions) els.btnCloseVersions.addEventListener('click', () => ensureVersionsPanelVisible(false));

  // Init
  loadConfig();
  // Only load stored token; do not auto sign-in or refresh
  loadStoredTokenOnly();
  // If token already present, set Firebase cookies from bucket for other pages
  if (hasValidToken()) { ensureFirebaseCookiesFromBucket().catch(() => {}); }
  loadInitial();
  </script>
  <!-- Load Google Identity Services client library (deferred). No secrets embedded. -->
  <script src="https://accounts.google.com/gsi/client" async defer></script>
</body>
</html>
