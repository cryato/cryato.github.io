<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Flow Text Editor</title>
  <style>
    :root { --bg: #0f172a; --panel: #111827; --muted: #94a3b8; --text: #e5e7eb; --primary: #22d3ee; --accent: #8b5cf6; }
    html, body { height: 100%; }
    body { margin: 0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica Neue, Arial, "Apple Color Emoji", "Segoe UI Emoji"; background: linear-gradient(180deg, #0b1022 0%, #0f172a 100%); color: var(--text); }
    header { display: flex; align-items: center; justify-content: space-between; padding: 16px 20px; border-bottom: 1px solid #1f2937; backdrop-filter: blur(8px); position: sticky; top: 0; background: rgba(17,24,39,0.6); z-index: 10; }
    header h1 { margin: 0; font-size: 16px; font-weight: 600; letter-spacing: 0.3px; }
    .container { display: grid; grid-template-columns: 280px 1fr; gap: 16px; padding: 16px; align-items: start; }
    .panel { background: rgba(17,24,39,0.65); border: 1px solid #1f2937; border-radius: 12px; box-shadow: 0 10px 30px rgba(0,0,0,0.35), inset 0 1px 0 rgba(255,255,255,0.03); }
    .flows { padding: 8px; }
    .flow-item { display: flex; align-items: center; gap: 8px; padding: 10px 12px; margin: 8px; border-radius: 10px; cursor: pointer; border: 1px solid transparent; color: #cbd5e1; }
    .flow-item:hover { background: rgba(148,163,184,0.08); border-color: rgba(148,163,184,0.15); }
    .flow-item.active { background: rgba(139,92,246,0.12); border-color: rgba(139,92,246,0.35); color: #e9d5ff; }
    .flow-key { font-weight: 600; font-size: 13px; }
    .flow-trigger { font-size: 12px; color: var(--muted); }

    .steps { padding: 16px; }
    .flow-header { display: flex; align-items: center; justify-content: space-between; gap: 12px; margin-bottom: 16px; padding: 8px 4px; }
    .flow-title { font-size: 18px; font-weight: 700; letter-spacing: 0.2px; }
    .flow-desc { color: var(--muted); font-size: 13px; }

    .step { padding: 14px; margin: 12px 0; border-radius: 12px; border: 1px solid #1f2937; background: rgba(2,6,23,0.55); }
    .step-head { display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px; }
    .badge { font-size: 11px; padding: 3px 8px; border-radius: 999px; border: 1px solid #1f2937; background: rgba(15,23,42,0.6); color: #b3e1ff; }

    .field { display: grid; grid-template-columns: 140px 1fr; gap: 12px; align-items: start; margin: 10px 0; }
    .label { color: var(--muted); font-size: 12px; padding-top: 7px; }
    input[type="text"], textarea { width: 100%; box-sizing: border-box; background: rgba(17,24,39,0.6); border: 1px solid #1f2937; color: var(--text); padding: 10px 12px; border-radius: 10px; outline: none; font-size: 13px; }
    textarea { min-height: 60px; resize: vertical; }

    .toolbar { display: flex; gap: 8px; }
    .btn { appearance: none; border: 1px solid #283449; background: linear-gradient(180deg, #0b1224 0%, #0a1222 100%); color: #e5e7eb; border-radius: 10px; padding: 10px 14px; font-size: 13px; cursor: pointer; box-shadow: 0 6px 16px rgba(0,0,0,0.25), inset 0 1px 0 rgba(255,255,255,0.04); transition: transform 120ms ease, border-color 120ms ease, background 120ms ease; }
    .btn:hover { transform: translateY(-1px); border-color: #334155; }
    .btn.primary { border-color: rgba(34,211,238,0.6); background: linear-gradient(180deg, rgba(34,211,238,0.18) 0%, rgba(34,211,238,0.10) 100%); color: #cffafe; }
    .btn.accent { border-color: rgba(139,92,246,0.6); background: linear-gradient(180deg, rgba(139,92,246,0.18) 0%, rgba(139,92,246,0.10) 100%); color: #ede9fe; }

    .empty { padding: 40px; text-align: center; color: var(--muted); }
    .footer { padding: 12px 16px; display: flex; justify-content: space-between; align-items: center; border-top: 1px solid #1f2937; }
    .hint { color: var(--muted); font-size: 12px; }
    .code { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; background: rgba(2,6,23,0.6); border: 1px solid #1f2937; padding: 2px 6px; border-radius: 6px; }
  </style>
</head>
<body>
  <header>
    <h1>Supportable Flow Editor</h1>
    <div class="toolbar">
      <a id="lnkConversations" class="btn" href="conversations">Conversations</a>
      <a id="lnkInteractions" class="btn" href="interactions">Interactions</a>
      <button id="btnSignOutHeader" class="btn">Sign out</button>
      <button id="btnBrowseVersions" class="btn">Browse versions</button>
      <button id="btnPublish" class="btn accent">Publish</button>
    </div>
  </header>
  <div class="container">
    <div class="panel">
      <div class="flows" id="flows"></div>
    </div>
    <div class="panel">
      <div class="steps" id="steps">
        <div class="empty">Select a flow to edit ask/say texts.</div>
      </div>
      <div class="footer">
        <div class="hint">Variables must be written as <span class="code">{{variable}}</span>.</div>
        <div class="hint">Only <span class="code">ask</span> and <span class="code">say</span> are editable.</div>
      </div>
    </div>
  </div>

  <!-- Versions panel -->
  <div id="versionsPanel" class="panel" style="display:none; margin: 16px; padding: 12px;">
    <div class="steps">
      <div class="flow-header">
        <div class="flow-title">Versions</div>
        <div class="toolbar">
          <button id="btnCloseVersions" class="btn">Close</button>
        </div>
      </div>
      <div id="versionsList" class="steps"></div>
      <div style="display:flex; gap:8px; align-items:center; margin-top:8px;">
        <button id="btnLoadMoreVersions" class="btn">Load more</button>
        <div id="versionsHint" class="hint"></div>
      </div>
    </div>
  </div>

  <input type="file" id="fileInput" accept="application/json" style="display:none" />

  <!-- Cloud Storage config panel (client-only; no secrets stored besides OAuth client ID) -->
  <div id="gcsPanel" class="panel" style="margin: 16px; padding: 12px;">
    <div class="steps">
      <div class="flow-header">
        <div class="flow-title">Google Cloud Storage</div>
        <div class="toolbar">
          <button id="btnAuth" class="btn">Sign in</button>
          <button id="btnSignOut" class="btn">Sign out</button>
        </div>
      </div>
      <div class="hint" id="authStatus" style="margin-top:8px;">Not signed in</div>
    </div>
  </div>

  <script>
  // Google Identity Services
  // Loaded via script tag injected below. Uses OAuth 2.0 token model for GCS JSON API.
  const els = {
    flows: document.getElementById('flows'),
    steps: document.getElementById('steps'),
    btnPublish: document.getElementById('btnPublish'),
    btnSignOutHeader: document.getElementById('btnSignOutHeader'),
    btnBrowseVersions: document.getElementById('btnBrowseVersions'),
    fileInput: document.getElementById('fileInput'),
    // Cloud panel
    btnAuth: document.getElementById('btnAuth'),
    btnSignOut: document.getElementById('btnSignOut'),
    authStatus: document.getElementById('authStatus'),
    gcsPanel: document.getElementById('gcsPanel'),
    versionsPanel: document.getElementById('versionsPanel'),
    versionsList: document.getElementById('versionsList'),
    btnLoadMoreVersions: document.getElementById('btnLoadMoreVersions'),
    btnCloseVersions: document.getElementById('btnCloseVersions'),
    versionsHint: document.getElementById('versionsHint'),
  };

  let flowDoc = null; // { flows: { key: def } }
  let currentFlowKey = null;
  let oauth = { clientId: '', accessToken: '', tokenExpiresAt: 0, scope: 'https://www.googleapis.com/auth/devstorage.read_write', tokenClient: null };
  let gsiLoaded = false;
  let versionsPaging = { key: '', names: [], index: 0, pageSize: 5, busy: false };
  let flowKeys = [];
  let triggersMap = new Map(); // key -> trigger (best-effort)

  // Load config from localStorage or URL params (client_id, bucket).
  function loadConfig() {
    const url = new URL(window.location.href);
    const params = Object.fromEntries(url.searchParams.entries());
    const stored = JSON.parse(localStorage.getItem('gcs_config') || '{}');
    const clientId = params.client_id || stored.clientId || '';
    const bucket = params.bucket || stored.bucket || '';
    const object = 'flows/'; // prefix for per-flow files
    oauth.clientId = clientId;
    // Persist silently so future loads work without showing fields
    localStorage.setItem('gcs_config', JSON.stringify({ clientId, bucket, object }));
    updateAuthStatus();
  }

  function updateAuthStatus() {
    const isAuthed = oauth.accessToken && Date.now() < oauth.tokenExpiresAt;
    els.authStatus.textContent = isAuthed ? 'Signed in' : 'Not signed in';
    if (els.gcsPanel) {
      els.gcsPanel.style.display = isAuthed ? 'none' : '';
    }
  }

  function ensureGsiScript() {
    return new Promise((resolve) => {
      if (gsiLoaded) return resolve();
      const s = document.createElement('script');
      s.src = 'https://accounts.google.com/gsi/client';
      s.async = true; s.defer = true;
      s.onload = () => { gsiLoaded = true; resolve(); };
      document.head.appendChild(s);
    });
  }

  async function getAccessToken(force = false) {
    if (!oauth.clientId) throw new Error('Missing OAuth Client ID');
    const stillValid = oauth.accessToken && Date.now() < oauth.tokenExpiresAt - 5000;
    if (stillValid && !force) return oauth.accessToken;
    await ensureGsiScript();
    return new Promise((resolve, reject) => {
      try {
        if (!oauth.tokenClient) {
          oauth.tokenClient = google.accounts.oauth2.initTokenClient({
            client_id: oauth.clientId,
            scope: oauth.scope,
            callback: (resp) => {
              if (resp && resp.access_token) {
                oauth.accessToken = resp.access_token;
                // expires_in seconds
                const expires = Number(resp.expires_in || 0);
                oauth.tokenExpiresAt = Date.now() + Math.max(0, expires - 10) * 1000;
                // Remember window: 1 year
                const oneYearMs = 365 * 24 * 60 * 60 * 1000;
                const rememberUntil = Date.now() + oneYearMs;
                localStorage.setItem('gcs_token', JSON.stringify({
                  accessToken: oauth.accessToken,
                  tokenExpiresAt: oauth.tokenExpiresAt,
                  rememberUntil
                }));
                updateAuthStatus();
                // Set Firebase cookies from firebase_config.json in the bucket for other pages
                ensureFirebaseCookiesFromBucket().catch(() => {});
                // After successful sign-in, clean URL if it has params
                if (force && window.location.search && window.location.search.length > 1) {
                  const clean = window.location.origin + window.location.pathname;
                  // Use replace to avoid back button pollution
                  window.location.replace(clean);
                  return; // stop further execution; reload will happen
                }
                resolve(oauth.accessToken);
              } else {
                reject(new Error('No access token'));
              }
            }
          });
        }
        oauth.tokenClient.requestAccessToken({ prompt: force ? 'consent' : 'none' });
      } catch (e) {
        reject(e);
      }
    });
  }

  function signOut() {
    const sure = confirm('Sign out? You will need to sign in again to Publish.');
    if (!sure) return;
    oauth.accessToken = '';
    oauth.tokenExpiresAt = 0;
    try { localStorage.removeItem('gcs_token'); } catch (_) {}
    updateAuthStatus();
  }

  function getCfg() {
    try {
      const stored = JSON.parse(localStorage.getItem('gcs_config') || '{}');
      const bucket = (stored.bucket || '').trim();
      const object = 'flows/';
      return { bucket, object };
    } catch (_) {
      return { bucket: '', object: 'flows/' };
    }
  }

  function gcsDownloadUrl(bucket, objectPath) {
    return `https://storage.googleapis.com/storage/v1/b/${encodeURIComponent(bucket)}/o/${encodeURIComponent(objectPath)}?alt=media`;
  }

  function gcsUploadUrl(bucket, objectPath) {
    return `https://storage.googleapis.com/upload/storage/v1/b/${encodeURIComponent(bucket)}/o?uploadType=media&name=${encodeURIComponent(objectPath)}`;
  }

  function gcsListUrl(bucket, prefix) {
    const base = `https://storage.googleapis.com/storage/v1/b/${encodeURIComponent(bucket)}/o`;
    const params = new URLSearchParams();
    params.set('prefix', prefix.replace(/^\/*/, ''));
    params.set('fields', 'items(name),nextPageToken');
    return `${base}?${params.toString()}`;
  }

  function formatUtcNowForFlow() {
    const d = new Date();
    const pad = (n) => String(n).padStart(2, '0');
    const yyyy = d.getUTCFullYear();
    const mm = pad(d.getUTCMonth() + 1);
    const dd = pad(d.getUTCDate());
    const HH = pad(d.getUTCHours());
    const MM = pad(d.getUTCMinutes());
    return `${yyyy}-${mm}-${dd}T${HH}_${MM}Z`;
  }

  function formatBackupName(key, timestampUtc) {
    const safeKey = String(key || 'flow');
    const ts = String(timestampUtc || '');
    return `flows/backups/${safeKey}_${ts}.json`;
  }

  function extractTimestampFromBackupName(name) {
    const m = String(name).match(/\/([^\/]+)_([0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}_[0-9]{2}Z)\.json$/);
    return m ? m[2] : '';
  }

  function extractDescriptionFromName(name) {
    // If we later include description in filename, parse here. For now, description isn't in name; return ''
    return '';
  }

  function formatDisplayFromTimestamp(ts) {
    // Input like 2025-09-18T12_15Z → display 2025-09-18 12:15 UTC
    if (!ts) return '';
    return ts.replace('T', ' ').replace('_', ':').replace('Z', ' UTC');
  }

  async function listAllBackupsForKey(key) {
    const { bucket } = getCfg();
    if (!bucket) throw new Error('Missing bucket');
    if (!hasValidToken()) throw new Error('Missing token');
    const base = `https://storage.googleapis.com/storage/v1/b/${encodeURIComponent(bucket)}/o`;
    let pageToken = '';
    const names = [];
    do {
      const params = new URLSearchParams();
      params.set('prefix', `flows/backups/${key}_`);
      params.set('fields', 'items(name),nextPageToken');
      if (pageToken) params.set('pageToken', pageToken);
      const url = `${base}?${params.toString()}`;
      const res = await fetch(url, { headers: { Authorization: `Bearer ${oauth.accessToken}` }, cache: 'no-store' });
      if (!res.ok) throw new Error('Failed to list backups');
      const json = await res.json();
      const items = Array.isArray(json.items) ? json.items : [];
      for (const it of items) {
        if (it && it.name) names.push(String(it.name));
      }
      pageToken = json.nextPageToken || '';
    } while (pageToken);
    // Sort newest first by timestamp parsed from name
    names.sort((a, b) => {
      const ta = extractTimestampFromBackupName(a);
      const tb = extractTimestampFromBackupName(b);
      return ta < tb ? 1 : (ta > tb ? -1 : 0);
    });
    return names;
  }

  function ensureVersionsPanelVisible(show) {
    if (!els.versionsPanel) return;
    els.versionsPanel.style.display = show ? '' : 'none';
  }

  async function loadVersionsFirstPage() {
    if (!currentFlowKey) { alert('Select a flow first.'); return; }
    if (!hasValidToken()) { alert('Please sign in first.'); return; }
    versionsPaging = { key: currentFlowKey, names: [], index: 0, pageSize: 5, busy: true };
    els.versionsList.innerHTML = '';
    els.versionsHint.textContent = '';
    try {
      const names = await listAllBackupsForKey(currentFlowKey);
      renderCurrentVersionItem();
      versionsPaging.names = names;
      versionsPaging.index = 0;
      renderVersionItems(names.slice(0, versionsPaging.pageSize));
      const hasMore = names.length > versionsPaging.pageSize;
      els.btnLoadMoreVersions.style.display = hasMore ? '' : 'none';
    } catch (e) {
      els.versionsHint.textContent = 'Failed to list versions';
    } finally {
      versionsPaging.busy = false;
    }
  }

  async function loadMoreVersions() {
    if (versionsPaging.busy) return;
    const { names, index, pageSize } = versionsPaging;
    const nextStart = index + pageSize;
    if (!names || nextStart >= names.length) { els.btnLoadMoreVersions.style.display = 'none'; return; }
    versionsPaging.busy = true;
    try {
      const slice = names.slice(nextStart, nextStart + pageSize);
      renderVersionItems(slice);
      versionsPaging.index = nextStart;
      const hasMore = (nextStart + pageSize) < names.length;
      els.btnLoadMoreVersions.style.display = hasMore ? '' : 'none';
    } catch (_) {
      els.versionsHint.textContent = 'Failed to load more versions';
    } finally {
      versionsPaging.busy = false;
    }
  }

  function renderVersionItems(items) {
    const frag = document.createDocumentFragment();
    (items || []).forEach((it) => {
      const name = String(it);
      const ts = extractTimestampFromBackupName(name);
      const line = document.createElement('div');
      line.className = 'step';
      const row = document.createElement('div');
      row.style.display = 'flex'; row.style.alignItems = 'center'; row.style.justifyContent = 'space-between';
      const label = document.createElement('div');
      label.textContent = `${formatDisplayFromTimestamp(ts) || name}`;
      const actions = document.createElement('div');
      const btnLoad = document.createElement('button'); btnLoad.className = 'btn'; btnLoad.textContent = 'Load';
      btnLoad.addEventListener('click', () => restoreVersionByName(name));
      actions.appendChild(btnLoad);
      row.appendChild(label); row.appendChild(actions);
      line.appendChild(row);
      frag.appendChild(line);

      // Asynchronously fetch description for this backup and update the label
      fetchBackupMeta(name).then((meta) => {
        if (meta && typeof meta.description === 'string' && meta.description.length > 0) {
          label.textContent = `${formatDisplayFromTimestamp(ts) || name} — ${meta.description}`;
        }
      }).catch(() => {});
    });
    els.versionsList.appendChild(frag);
  }

  async function fetchBackupMeta(objectName) {
    try {
      const { bucket } = getCfg();
      if (!bucket) return {};
      if (!hasValidToken()) return {};
      const res = await fetch(gcsDownloadUrl(bucket, objectName), { headers: { Authorization: `Bearer ${oauth.accessToken}` }, cache: 'no-store' });
      if (!res.ok) return {};
      const json = await res.json();
      let def = null;
      if (json && json.flows && currentFlowKey && json.flows[currentFlowKey]) def = json.flows[currentFlowKey];
      else if (json && currentFlowKey && json[currentFlowKey]) def = json[currentFlowKey];
      else def = json;
      if (!def || typeof def !== 'object') return {};
      const description = typeof def.description === 'string' ? def.description : '';
      const updated_at = typeof def.updated_at === 'string' ? def.updated_at : '';
      return { description, updated_at };
    } catch (_) {
      return {};
    }
  }

  function renderCurrentVersionItem() {
    const flows = (flowDoc && flowDoc.flows) || {};
    const def = flows[currentFlowKey] || {};
    const ts = typeof def.updated_at === 'string' ? def.updated_at : '';
    const desc = typeof def.description === 'string' ? def.description : '';
    const line = document.createElement('div');
    line.className = 'step';
    const row = document.createElement('div');
    row.style.display = 'flex'; row.style.alignItems = 'center'; row.style.justifyContent = 'space-between';
    const label = document.createElement('div');
    const when = formatDisplayFromTimestamp(ts);
    label.textContent = `${when || '(unsaved)'}${desc ? ' — ' + desc : ''}, current`;
    row.appendChild(label);
    line.appendChild(row);
    els.versionsList.appendChild(line);
  }

  async function restoreVersionByName(objectName) {
    try {
      const { bucket } = getCfg();
      if (!bucket) { alert('Missing bucket'); return; }
      if (!hasValidToken()) { alert('Please sign in first.'); return; }
      const res = await fetch(gcsDownloadUrl(bucket, objectName), { headers: { Authorization: `Bearer ${oauth.accessToken}` }, cache: 'no-store' });
      if (!res.ok) throw new Error('Failed to download version');
      const json = await res.json();
      let def = null;
      if (json && json.flows && json.flows[currentFlowKey]) def = json.flows[currentFlowKey];
      else if (json && json[currentFlowKey]) def = json[currentFlowKey];
      else def = json;
      if (!def || typeof def !== 'object') throw new Error('Invalid version structure');
      // Apply to editor state
      if (!flowDoc || !flowDoc.flows) flowDoc = { flows: {} };
      flowDoc.flows[currentFlowKey] = def;
      renderSteps();
    } catch (e) {
      alert('Failed to load version: ' + e.message);
    }
  }

  function setCookie(name, value, days) {
    try {
      const d = new Date();
      d.setTime(d.getTime() + (days*24*60*60*1000));
      const expires = `expires=${d.toUTCString()}`;
      document.cookie = `${encodeURIComponent(name)}=${encodeURIComponent(String(value))}; ${expires}; path=/; SameSite=Lax`;
    } catch (_) {}
  }

  async function ensureFirebaseCookiesFromBucket() {
    try {
      const { bucket } = getCfg();
      if (!bucket || !hasValidToken()) return;
      const url = gcsDownloadUrl(bucket, 'firebase_config.json');
      const res = await fetch(url, { headers: { Authorization: `Bearer ${oauth.accessToken}` }, cache: 'no-store' });
      if (!res.ok) return;
      const json = await res.json();
      if (json && typeof json === 'object') {
        if (json.projectId) setCookie('projectId', json.projectId, 365);
        if (json.apiKey) setCookie('apiKey', json.apiKey, 365);
        if (json.authDomain) setCookie('authDomain', json.authDomain, 365);
      }
    } catch (_) {}
  }

  async function listFlowKeysFromGcs() {
    const { bucket } = getCfg();
    const out = [];
    if (!bucket || !hasValidToken()) return out;
    try {
      let pageToken = '';
      do {
        const prefix = 'flows/';
        const url = gcsListUrl(bucket, prefix) + (pageToken ? `&pageToken=${encodeURIComponent(pageToken)}` : '');
        const res = await fetch(url, { headers: { Authorization: `Bearer ${oauth.accessToken}` }, cache: 'no-store' });
        if (!res.ok) break;
        const json = await res.json();
        const items = Array.isArray(json.items) ? json.items : [];
        for (const it of items) {
          const name = it && it.name ? String(it.name) : '';
          if (!name.startsWith('flows/')) continue;
          if (name.startsWith('flows/backups/')) continue;
          if (!name.toLowerCase().endsWith('.json')) continue;
          // skip legacy combined file
          if (name === 'flows/flow.json') continue;
          const m = name.match(/^flows\/(.+)\.json$/);
          if (m) out.push(m[1]);
        }
        pageToken = json.nextPageToken || '';
      } while (pageToken);
    } catch (_) {}
    return out;
  }

  async function listFlowKeysLocally() {
    // Best-effort: read legacy combined file to derive keys
    try {
      const res = await fetch('flows/flow.json', { cache: 'no-store' });
      if (!res.ok) return [];
      const json = await res.json();
      if (json && json.flows && typeof json.flows === 'object') return Object.keys(json.flows);
    } catch (_) {}
    return [];
  }

  async function loadSingleFlow(key) {
    // Prefer Cloud single file, fallback to site-local candidates, then legacy combined
    const { bucket } = getCfg();
    // Cloud
    if (bucket && hasValidToken()) {
      try {
        const res = await fetch(gcsDownloadUrl(bucket, `flows/${key}.json`), { headers: { Authorization: `Bearer ${oauth.accessToken}` }, cache: 'no-store' });
        if (res.ok) {
          const json = await res.json();
          // Accept either {steps...} or { key: def } or {flows:{}}
          let def = null;
          if (json && json.flows && json.flows[key]) def = json.flows[key];
          else if (json && json[key]) def = json[key];
          else def = json;
          flowDoc = { flows: { [key]: def || {} } };
          currentFlowKey = key;
          return true;
        }
      } catch (_) {}
    }
    // Local direct file candidates
    const candidates = [
      `flows/${key}.json`,
      `../flows/${key}.json`,
      `../../flows/${key}.json`,
      `/flows/${key}.json`
    ];
    for (const rel of candidates) {
      try {
        const res = await fetch(rel, { cache: 'no-store' });
        if (res.ok) {
          const json = await res.json();
          let def = null;
          if (json && json.flows && json.flows[key]) def = json.flows[key];
          else if (json && json[key]) def = json[key];
          else def = json;
          flowDoc = { flows: { [key]: def || {} } };
          currentFlowKey = key;
          return true;
        }
      } catch (_) {}
    }
    // Fallback to legacy combined
    try {
      const res = await fetch('flows/flow.json', { cache: 'no-store' });
      if (res.ok) {
        const json = await res.json();
        const def = json && json.flows ? json.flows[key] : null;
        flowDoc = { flows: def ? { [key]: def } : {} };
        currentFlowKey = def ? key : null;
        return !!def;
      }
    } catch (_) {}
    flowDoc = { flows: {} };
    currentFlowKey = null;
    return false;
  }

  async function loadInitial() {
    try {
      const u = new URL(location.href);
      const sel = u.searchParams.get('flow') || '';
      // Build list of keys
      let keys = [];
      if (hasValidToken()) keys = await listFlowKeysFromGcs();
      if (!keys || keys.length === 0) keys = await listFlowKeysLocally();
      flowKeys = Array.from(new Set(keys)).sort();
      // Best-effort triggers map from legacy combined file
      triggersMap = new Map();
      try {
        const { bucket } = getCfg();
        let combined = null;
        if (bucket && hasValidToken()) {
          const r = await fetch(gcsDownloadUrl(bucket, 'flows/flow.json'), { headers: { Authorization: `Bearer ${oauth.accessToken}` }, cache: 'no-store' });
          if (r.ok) combined = await r.json();
        }
        if (!combined) {
          const r2 = await fetch('flows/flow.json', { cache: 'no-store' });
          if (r2.ok) combined = await r2.json();
        }
        if (combined && combined.flows && typeof combined.flows === 'object') {
          Object.entries(combined.flows).forEach(([k, v]) => {
            if (v && typeof v === 'object' && v.trigger) triggersMap.set(k, String(v.trigger));
          });
        }
      } catch (_) {}

      // Load selected flow if any
      if (sel) {
        await loadSingleFlow(sel);
      } else {
        flowDoc = { flows: {} };
      currentFlowKey = null;
      }
      renderFlows();
      renderSteps();
    } catch (err) {
      console.error(err);
      flowDoc = { flows: {} };
      renderFlows();
      renderSteps();
    }
  }

  function renderFlows() {
    const flows = (flowDoc && flowDoc.flows) || {};
    const selected = currentFlowKey;
    els.flows.innerHTML = '';
    const keys = flowKeys && flowKeys.length ? flowKeys : Object.keys(flows);

    if (!keys || keys.length === 0) {
      const empty = document.createElement('div');
      empty.className = 'empty';
      empty.textContent = 'No flows found.';
      els.flows.appendChild(empty);
      return;
    }

    keys.forEach((key) => {
      const def = flows[key] || {};
      const item = document.createElement('a');
      item.href = `?flow=${encodeURIComponent(key)}`;
      item.className = 'flow-item' + (selected === key ? ' active' : '');

      const icon = document.createElement('div');
      icon.innerHTML = '⚡️';

      const meta = document.createElement('div');
      const k = document.createElement('div');
      k.className = 'flow-key';
      k.textContent = key;
      const t = document.createElement('div');
      t.className = 'flow-trigger';
      const trig = (def && def.trigger) ? def.trigger : (triggersMap.get(key) || '');
      t.textContent = trig;
      meta.appendChild(k);
      meta.appendChild(t);

      item.appendChild(icon);
      item.appendChild(meta);
      els.flows.appendChild(item);
    });
  }

  function renderSteps() {
    els.steps.innerHTML = '';
    const flows = (flowDoc && flowDoc.flows) || {};
    const def = flows[currentFlowKey];

    if (!def) {
      const empty = document.createElement('div');
      empty.className = 'empty';
      empty.textContent = 'Select a flow to edit ask/say texts.';
      els.steps.appendChild(empty);
      return;
    }

    // Header
    const head = document.createElement('div');
    head.className = 'flow-header';
    const title = document.createElement('div');
    title.className = 'flow-title';
    title.textContent = currentFlowKey + (def.trigger ? '  ·  ' + def.trigger : '');
    const desc = document.createElement('div');
    desc.className = 'flow-desc';
    desc.textContent = def.description || '';
    head.appendChild(title);
    head.appendChild(desc);
    els.steps.appendChild(head);

    // Editable flow description
    const descField = fieldText('description', def.description || '', (v) => { def.description = v; });
    els.steps.appendChild(descField);

    const steps = Array.isArray(def.steps) ? def.steps : [];
    steps.forEach((step, idx) => {
      const s = document.createElement('div');
      s.className = 'step';

      const head = document.createElement('div');
      head.className = 'step-head';
      const left = document.createElement('div');
      const type = step.ask ? 'ask' : (step.say ? 'say' : (step.wait ? 'wait' : (step.script ? 'script' : 'step')));
      const badge = document.createElement('span');
      badge.className = 'badge';
      badge.textContent = type.toUpperCase();
      left.appendChild(badge);
      const right = document.createElement('div');
      right.textContent = '#' + (idx + 1);
      right.style.color = '#94a3b8';
      right.style.fontSize = '12px';
      s.appendChild(head);
      head.appendChild(left);
      head.appendChild(right);

      // Editable fields for ask/say only
      if (step.ask != null || step.say != null) {
        if (step.ask != null) {
          const field = fieldText('ask', step.ask, (v) => { step.ask = v; });
          s.appendChild(field);
        }
        if (step.saveAs != null) {
          const field = fieldText('saveAs', step.saveAs, (v) => { step.saveAs = v; }, true);
          s.appendChild(field);
        }
        if (step.say != null) {
          const field = fieldText('say', step.say, (v) => { step.say = v; });
          s.appendChild(field);
        }
      } else {
        const readOnly = document.createElement('div');
        readOnly.className = 'field';
        const label = document.createElement('div');
        label.className = 'label';
        label.textContent = 'Details';
        const val = document.createElement('div');
        val.textContent = JSON.stringify(step, null, 2);
        readOnly.appendChild(label);
        readOnly.appendChild(val);
        s.appendChild(readOnly);
      }

      els.steps.appendChild(s);
    });
  }

  function fieldText(labelText, value, onInput, singleLine = false) {
    const wrap = document.createElement('div');
    wrap.className = 'field';

    const label = document.createElement('div');
    label.className = 'label';
    label.textContent = labelText;

    let input;
    if (singleLine) {
      input = document.createElement('input');
      input.type = 'text';
      input.value = value == null ? '' : String(value);
    } else {
      input = document.createElement('textarea');
      input.value = value == null ? '' : String(value);
    }

    input.addEventListener('input', (e) => onInput(e.target.value));

    wrap.appendChild(label);
    wrap.appendChild(input);
    return wrap;
  }

  function downloadJson(obj, filename) {
    const json = JSON.stringify(obj, null, 2);
    const blob = new Blob([json], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    setTimeout(() => {
      URL.revokeObjectURL(url);
      a.remove();
    }, 0);
  }

  async function saveCurrentFlowToCloudWithBackup() {
    if (!flowDoc || !currentFlowKey) return alert('Select a flow first.');
    const def = (flowDoc.flows && flowDoc.flows[currentFlowKey]) || null;
    if (!def) return alert('Nothing to save.');
    const { bucket } = getCfg();
    if (!bucket) return alert('Please configure Bucket.');
    if (!hasValidToken()) { alert('Please sign in first.'); return; }
    try {
      const token = oauth.accessToken;
      const mainPath = `flows/${currentFlowKey}.json`;
      // 1) Read current file; if present, back it up using its own updated_at
      let currentText = null;
      let previousUpdatedAt = '';
      try {
        const getRes = await fetch(gcsDownloadUrl(bucket, mainPath), { headers: { Authorization: `Bearer ${token}` }, cache: 'no-store' });
        if (getRes.ok) currentText = await getRes.text();
      } catch (_) {}
      if (currentText != null) {
        try {
          const json = JSON.parse(currentText);
          let prevDef = null;
          if (json && json.flows && json.flows[currentFlowKey]) prevDef = json.flows[currentFlowKey];
          else if (json && json[currentFlowKey]) prevDef = json[currentFlowKey];
          else prevDef = json;
          if (prevDef && typeof prevDef.updated_at === 'string') previousUpdatedAt = prevDef.updated_at;
        } catch (_) {}
        const tsForBackup = previousUpdatedAt || formatUtcNowForFlow();
        const backupName = formatBackupName(currentFlowKey, tsForBackup);
        const upBackup = await fetch(gcsUploadUrl(bucket, backupName), {
          method: 'POST',
          headers: { 'Authorization': `Bearer ${token}`, 'Content-Type': 'application/json' },
          body: currentText
        });
        if (!upBackup.ok) console.warn('Backup upload failed');
      }
      // 2) Upload new content (store as single-flow object)
      const newTimestampUtc = formatUtcNowForFlow();
      try { def.updated_at = newTimestampUtc; } catch (_) {}
      const newBody = JSON.stringify(def, null, 2);
      const upMain = await fetch(gcsUploadUrl(bucket, mainPath), {
        method: 'POST',
        headers: { 'Authorization': `Bearer ${token}`, 'Content-Type': 'application/json' },
        body: newBody
      });
      if (!upMain.ok) throw new Error('Upload failed');
      alert('Saved to Cloud.');
    } catch (e) {
      console.error(e);
      alert('Save failed: ' + e.message);
    }
  }

  function loadStoredTokenOnly() {
    try {
      const stored = JSON.parse(localStorage.getItem('gcs_token') || '{}');
      const { accessToken, tokenExpiresAt } = stored;
      if (accessToken && Number.isFinite(tokenExpiresAt)) {
        oauth.accessToken = accessToken;
        oauth.tokenExpiresAt = tokenExpiresAt;
      }
    } catch (_) {}
    updateAuthStatus();
  }

  function hasValidToken() {
    return !!(oauth.accessToken && Date.now() < oauth.tokenExpiresAt - 5000);
  }

  function handleImportFile(file) {
    const reader = new FileReader();
    reader.onload = () => {
      try {
        const data = JSON.parse(reader.result);
        if (!data || typeof data !== 'object' || !data.flows) {
          throw new Error('Invalid structure: expected root object with "flows"');
        }
        flowDoc = data;
        currentFlowKey = null;
        renderFlows();
        renderSteps();
      } catch (e) {
        alert('Invalid JSON: ' + e.message);
      }
    };
    reader.readAsText(file);
  }

  // Events
  els.fileInput.addEventListener('change', (e) => {
    const file = e.target.files && e.target.files[0];
    if (file) handleImportFile(file);
    e.target.value = '';
  });
  els.btnPublish.addEventListener('click', saveCurrentFlowToCloudWithBackup);
  els.btnAuth.addEventListener('click', async () => {
    try { await getAccessToken(true); } catch (e) { alert('Auth failed: ' + e.message); }
  });
  els.btnSignOut.addEventListener('click', signOut);
  if (els.btnSignOutHeader) els.btnSignOutHeader.addEventListener('click', signOut);
  if (els.btnBrowseVersions) els.btnBrowseVersions.addEventListener('click', async () => {
    ensureVersionsPanelVisible(true);
    await loadVersionsFirstPage();
  });
  if (els.btnLoadMoreVersions) els.btnLoadMoreVersions.addEventListener('click', loadMoreVersions);
  if (els.btnCloseVersions) els.btnCloseVersions.addEventListener('click', () => ensureVersionsPanelVisible(false));

  // Init
  loadConfig();
  // Only load stored token; do not auto sign-in or refresh
  loadStoredTokenOnly();
  // If token already present, set Firebase cookies from bucket for other pages
  if (hasValidToken()) { ensureFirebaseCookiesFromBucket().catch(() => {}); }
  loadInitial();
  </script>
  <!-- Load Google Identity Services client library (deferred). No secrets embedded. -->
  <script src="https://accounts.google.com/gsi/client" async defer></script>
</body>
</html>
