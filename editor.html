<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Flow Text Editor</title>
  <style>
    :root { --bg: #0f172a; --panel: #111827; --muted: #94a3b8; --text: #e5e7eb; --primary: #22d3ee; --accent: #8b5cf6; }
    html, body { height: 100%; }
    body { margin: 0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica Neue, Arial, "Apple Color Emoji", "Segoe UI Emoji"; background: linear-gradient(180deg, #0b1022 0%, #0f172a 100%); color: var(--text); }
    header { display: flex; align-items: center; justify-content: space-between; padding: 16px 20px; border-bottom: 1px solid #1f2937; backdrop-filter: blur(8px); position: sticky; top: 0; background: rgba(17,24,39,0.6); z-index: 10; }
    header h1 { margin: 0; font-size: 16px; font-weight: 600; letter-spacing: 0.3px; }
    .container { display: grid; grid-template-columns: 280px 1fr; gap: 16px; padding: 16px; align-items: start; }
    .panel { background: rgba(17,24,39,0.65); border: 1px solid #1f2937; border-radius: 12px; box-shadow: 0 10px 30px rgba(0,0,0,0.35), inset 0 1px 0 rgba(255,255,255,0.03); }
    .flows { padding: 8px; }
    .flow-item { display: flex; align-items: center; gap: 8px; padding: 10px 12px; margin: 8px; border-radius: 10px; cursor: pointer; border: 1px solid transparent; color: #cbd5e1; }
    .flow-item:hover { background: rgba(148,163,184,0.08); border-color: rgba(148,163,184,0.15); }
    .flow-item.active { background: rgba(139,92,246,0.12); border-color: rgba(139,92,246,0.35); color: #e9d5ff; }
    .flow-key { font-weight: 600; font-size: 13px; }
    .flow-trigger { font-size: 12px; color: var(--muted); }

    .steps { padding: 16px; }
    .flow-header { display: flex; align-items: center; justify-content: space-between; gap: 12px; margin-bottom: 16px; padding: 8px 4px; }
    .flow-title { font-size: 18px; font-weight: 700; letter-spacing: 0.2px; }
    .flow-desc { color: var(--muted); font-size: 13px; }

    .step { padding: 14px; margin: 12px 0; border-radius: 12px; border: 1px solid #1f2937; background: rgba(2,6,23,0.55); }
    .step-head { display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px; }
    .badge { font-size: 11px; padding: 3px 8px; border-radius: 999px; border: 1px solid #1f2937; background: rgba(15,23,42,0.6); color: #b3e1ff; }

    .field { display: grid; grid-template-columns: 140px 1fr; gap: 12px; align-items: start; margin: 10px 0; }
    .label { color: var(--muted); font-size: 12px; padding-top: 7px; }
    input[type="text"], textarea { width: 100%; box-sizing: border-box; background: rgba(17,24,39,0.6); border: 1px solid #1f2937; color: var(--text); padding: 10px 12px; border-radius: 10px; outline: none; font-size: 13px; }
    textarea { min-height: 60px; resize: vertical; }

    .toolbar { display: flex; gap: 8px; }
    .btn { appearance: none; border: 1px solid #283449; background: linear-gradient(180deg, #0b1224 0%, #0a1222 100%); color: #e5e7eb; border-radius: 10px; padding: 10px 14px; font-size: 13px; cursor: pointer; box-shadow: 0 6px 16px rgba(0,0,0,0.25), inset 0 1px 0 rgba(255,255,255,0.04); transition: transform 120ms ease, border-color 120ms ease, background 120ms ease; }
    .btn:hover { transform: translateY(-1px); border-color: #334155; }
    .btn.primary { border-color: rgba(34,211,238,0.6); background: linear-gradient(180deg, rgba(34,211,238,0.18) 0%, rgba(34,211,238,0.10) 100%); color: #cffafe; }
    .btn.accent { border-color: rgba(139,92,246,0.6); background: linear-gradient(180deg, rgba(139,92,246,0.18) 0%, rgba(139,92,246,0.10) 100%); color: #ede9fe; }

    .empty { padding: 40px; text-align: center; color: var(--muted); }
    .footer { padding: 12px 16px; display: flex; justify-content: space-between; align-items: center; border-top: 1px solid #1f2937; }
    .hint { color: var(--muted); font-size: 12px; }
    .code { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; background: rgba(2,6,23,0.6); border: 1px solid #1f2937; padding: 2px 6px; border-radius: 6px; }
  </style>
</head>
<body>
  <header>
    <h1>Supportable Flow Editor</h1>
    <div class="toolbar">
      <a id="lnkConversations" class="btn" href="conversations">Conversations</a>
      <a id="lnkInteractions" class="btn" href="interactions">Interactions</a>
      <button id="btnSignOutHeader" class="btn">Sign out</button>
      <button id="btnBrowseVersions" class="btn">Browse versions</button>
      <button id="btnPublish" class="btn accent">Publish</button>
    </div>
  </header>
  <div class="container">
    <div class="panel">
      <div class="flows" id="flows"></div>
    </div>
    <div class="panel">
      <div class="steps" id="steps">
        <div class="empty">Select a flow to edit ask/say texts.</div>
      </div>
      <div class="footer">
        <div class="hint">Variables must be written as <span class="code">{{variable}}</span>.</div>
        <div class="hint">Only <span class="code">ask</span> and <span class="code">say</span> are editable.</div>
      </div>
    </div>
  </div>

  <!-- Versions panel -->
  <div id="versionsPanel" class="panel" style="display:none; margin: 16px; padding: 12px;">
    <div class="steps">
      <div class="flow-header">
        <div class="flow-title">Versions</div>
        <div class="toolbar">
          <button id="btnCloseVersions" class="btn">Close</button>
        </div>
      </div>
      <div id="versionsList" class="steps"></div>
      <div style="display:flex; gap:8px; align-items:center; margin-top:8px;">
        <button id="btnLoadMoreVersions" class="btn">Load more</button>
        <div id="versionsHint" class="hint"></div>
      </div>
    </div>
  </div>

  <input type="file" id="fileInput" accept="application/json" style="display:none" />

  <!-- Cloud Storage config panel (client-only; no secrets stored besides OAuth client ID) -->
  <div id="gcsPanel" class="panel" style="margin: 16px; padding: 12px;">
    <div class="steps">
      <div class="flow-header">
        <div class="flow-title">Google Cloud Storage</div>
        <div class="toolbar">
          <button id="btnAuth" class="btn">Sign in</button>
          <button id="btnSignOut" class="btn">Sign out</button>
        </div>
      </div>
      <div class="hint" id="authStatus" style="margin-top:8px;">Not signed in</div>
    </div>
  </div>

  <script>
  // Google Identity Services
  // Loaded via script tag injected below. Uses OAuth 2.0 token model for GCS JSON API.
  const els = {
    flows: document.getElementById('flows'),
    steps: document.getElementById('steps'),
    btnPublish: document.getElementById('btnPublish'),
    btnSignOutHeader: document.getElementById('btnSignOutHeader'),
    btnBrowseVersions: document.getElementById('btnBrowseVersions'),
    fileInput: document.getElementById('fileInput'),
    // Cloud panel
    btnAuth: document.getElementById('btnAuth'),
    btnSignOut: document.getElementById('btnSignOut'),
    authStatus: document.getElementById('authStatus'),
    gcsPanel: document.getElementById('gcsPanel'),
    versionsPanel: document.getElementById('versionsPanel'),
    versionsList: document.getElementById('versionsList'),
    btnLoadMoreVersions: document.getElementById('btnLoadMoreVersions'),
    btnCloseVersions: document.getElementById('btnCloseVersions'),
    versionsHint: document.getElementById('versionsHint'),
  };

  let flowDoc = null; // { flows: { key: def } }
  let currentFlowKey = null;
  let oauth = { clientId: '', accessToken: '', tokenExpiresAt: 0, scope: 'https://www.googleapis.com/auth/devstorage.read_write', tokenClient: null };
  let gsiLoaded = false;
  let versionsPaging = { key: '', names: [], index: 0, pageSize: 5, busy: false };
  let flowKeys = [];
  let triggersMap = new Map(); // key -> trigger (best-effort)

  // Load config from localStorage or URL params (client_id, bucket).
  function loadConfig() {
    const url = new URL(window.location.href);
    const params = Object.fromEntries(url.searchParams.entries());
    const stored = JSON.parse(localStorage.getItem('gcs_config') || '{}');
    const clientId = params.client_id || stored.clientId || '';
    const bucket = params.bucket || stored.bucket || '';
    const object = 'flows/'; // prefix for per-flow files
    oauth.clientId = clientId;
    // Persist silently so future loads work without showing fields
    localStorage.setItem('gcs_config', JSON.stringify({ clientId, bucket, object }));
    updateAuthStatus();
  }

  function updateAuthStatus() {
    const isAuthed = oauth.accessToken && Date.now() < oauth.tokenExpiresAt;
    els.authStatus.textContent = isAuthed ? 'Signed in' : 'Not signed in';
    if (els.gcsPanel) {
      els.gcsPanel.style.display = isAuthed ? 'none' : '';
    }
  }

  function ensureGsiScript() {
    return new Promise((resolve) => {
      if (gsiLoaded) return resolve();
      const s = document.createElement('script');
      s.src = 'https://accounts.google.com/gsi/client';
      s.async = true; s.defer = true;
      s.onload = () => { gsiLoaded = true; resolve(); };
      document.head.appendChild(s);
    });
  }

  async function getAccessToken(force = false) {
    if (!oauth.clientId) throw new Error('Missing OAuth Client ID');
    const stillValid = oauth.accessToken && Date.now() < oauth.tokenExpiresAt - 5000;
    if (stillValid && !force) return oauth.accessToken;
    await ensureGsiScript();
    return new Promise((resolve, reject) => {
      try {
        if (!oauth.tokenClient) {
          oauth.tokenClient = google.accounts.oauth2.initTokenClient({
            client_id: oauth.clientId,
            scope: oauth.scope,
            callback: (resp) => {
              if (resp && resp.access_token) {
                oauth.accessToken = resp.access_token;
                // expires_in seconds
                const expires = Number(resp.expires_in || 0);
                oauth.tokenExpiresAt = Date.now() + Math.max(0, expires - 10) * 1000;
                // Remember window: 1 year
                const oneYearMs = 365 * 24 * 60 * 60 * 1000;
                const rememberUntil = Date.now() + oneYearMs;
                localStorage.setItem('gcs_token', JSON.stringify({
                  accessToken: oauth.accessToken,
                  tokenExpiresAt: oauth.tokenExpiresAt,
                  rememberUntil
                }));
                updateAuthStatus();
                // Set Firebase cookies from firebase_config.json in the bucket for other pages
                ensureFirebaseCookiesFromBucket().catch(() => {});
                // After successful sign-in, clean URL if it has params
                if (force && window.location.search && window.location.search.length > 1) {
                  const clean = window.location.origin + window.location.pathname;
                  // Use replace to avoid back button pollution
                  window.location.replace(clean);
                  return; // stop further execution; reload will happen
                }
                resolve(oauth.accessToken);
              } else {
                reject(new Error('No access token'));
              }
            }
          });
        }
        oauth.tokenClient.requestAccessToken({ prompt: force ? 'consent' : 'none' });
      } catch (e) {
        reject(e);
      }
    });
  }

  function signOut() {
    const sure = confirm('Sign out? You will need to sign in again to Publish.');
    if (!sure) return;
    oauth.accessToken = '';
    oauth.tokenExpiresAt = 0;
    try { localStorage.removeItem('gcs_token'); } catch (_) {}
    updateAuthStatus();
  }

  function getCfg() {
    try {
      const stored = JSON.parse(localStorage.getItem('gcs_config') || '{}');
      const bucket = (stored.bucket || '').trim();
      const object = 'flows/';
      return { bucket, object };
    } catch (_) {
      return { bucket: '', object: 'flows/' };
    }
  }

  function gcsDownloadUrl(bucket, objectPath) {
    return `https://storage.googleapis.com/storage/v1/b/${encodeURIComponent(bucket)}/o/${encodeURIComponent(objectPath)}?alt=media`;
  }

  function gcsUploadUrl(bucket, objectPath) {
    return `https://storage.googleapis.com/upload/storage/v1/b/${encodeURIComponent(bucket)}/o?uploadType=media&name=${encodeURIComponent(objectPath)}`;
  }

  function gcsListUrl(bucket, prefix) {
    const base = `https://storage.googleapis.com/storage/v1/b/${encodeURIComponent(bucket)}/o`;
    const params = new URLSearchParams();
    params.set('prefix', prefix.replace(/^\/*/, ''));
    params.set('fields', 'items(name),nextPageToken');
    return `${base}?${params.toString()}`;
  }

  function formatUtcNowForFlow() {
    const d = new Date();
    const pad = (n) => String(n).padStart(2, '0');
    const yyyy = d.getUTCFullYear();
    const mm = pad(d.getUTCMonth() + 1);
    const dd = pad(d.getUTCDate());
    const HH = pad(d.getUTCHours());
    const MM = pad(d.getUTCMinutes());
    return `${yyyy}-${mm}-${dd}T${HH}_${MM}Z`;
  }

  function formatBackupName(key, timestampUtc) {
    const safeKey = String(key || 'flow');
    const ts = String(timestampUtc || '');
    return `flows/backups/${safeKey}_${ts}.json`;
  }

  function extractTimestampFromBackupName(name) {
    const m = String(name).match(/\/([^\/]+)_([0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}_[0-9]{2}Z)\.json$/);
    return m ? m[2] : '';
  }

  function extractDescriptionFromName(name) {
    // If we later include description in filename, parse here. For now, description isn't in name; return ''
    return '';
  }

  function formatDisplayFromTimestamp(ts) {
    // Input like 2025-09-18T12_15Z → display 2025-09-18 12:15 UTC
    if (!ts) return '';
    return ts.replace('T', ' ').replace('_', ':').replace('Z', ' UTC');
  }

  async function listAllBackupsForKey(key) {
    const { bucket } = getCfg();
    if (!bucket) throw new Error('Missing bucket');
    if (!hasValidToken()) throw new Error('Missing token');
    const base = `https://storage.googleapis.com/storage/v1/b/${encodeURIComponent(bucket)}/o`;
    let pageToken = '';
    const names = [];
    do {
      const params = new URLSearchParams();
      params.set('prefix', `flows/backups/${key}_`);
      params.set('fields', 'items(name),nextPageToken');
      if (pageToken) params.set('pageToken', pageToken);
      const url = `${base}?${params.toString()}`;
      const res = await fetch(url, { headers: { Authorization: `Bearer ${oauth.accessToken}` }, cache: 'no-store' });
      if (!res.ok) throw new Error('Failed to list backups');
      const json = await res.json();
      const items = Array.isArray(json.items) ? json.items : [];
      for (const it of items) {
        if (it && it.name) names.push(String(it.name));
      }
      pageToken = json.nextPageToken || '';
    } while (pageToken);
    // Sort newest first by timestamp parsed from name
    names.sort((a, b) => {
      const ta = extractTimestampFromBackupName(a);
      const tb = extractTimestampFromBackupName(b);
      return ta < tb ? 1 : (ta > tb ? -1 : 0);
    });
    return names;
  }

  function ensureVersionsPanelVisible(show) {
    if (!els.versionsPanel) return;
    els.versionsPanel.style.display = show ? '' : 'none';
  }

  async function loadVersionsFirstPage() {
    if (!currentFlowKey) { alert('Select a flow first.'); return; }
    if (!hasValidToken()) { alert('Please sign in first.'); return; }
    versionsPaging = { key: currentFlowKey, names: [], index: 0, pageSize: 5, busy: true };
    els.versionsList.innerHTML = '';
    els.versionsHint.textContent = '';
    try {
      const names = await listAllBackupsForKey(currentFlowKey);
      renderCurrentVersionItem();
      versionsPaging.names = names;
      versionsPaging.index = 0;
      renderVersionItems(names.slice(0, versionsPaging.pageSize));
      const hasMore = names.length > versionsPaging.pageSize;
      els.btnLoadMoreVersions.style.display = hasMore ? '' : 'none';
    } catch (e) {
      els.versionsHint.textContent = 'Failed to list versions';
    } finally {
      versionsPaging.busy = false;
    }
  }

  async function loadMoreVersions() {
    if (versionsPaging.busy) return;
    const { names, index, pageSize } = versionsPaging;
    const nextStart = index + pageSize;
    if (!names || nextStart >= names.length) { els.btnLoadMoreVersions.style.display = 'none'; return; }
    versionsPaging.busy = true;
    try {
      const slice = names.slice(nextStart, nextStart + pageSize);
      renderVersionItems(slice);
      versionsPaging.index = nextStart;
      const hasMore = (nextStart + pageSize) < names.length;
      els.btnLoadMoreVersions.style.display = hasMore ? '' : 'none';
    } catch (_) {
      els.versionsHint.textContent = 'Failed to load more versions';
    } finally {
      versionsPaging.busy = false;
    }
  }

  function renderVersionItems(items) {
    const frag = document.createDocumentFragment();
    (items || []).forEach((it) => {
      const name = String(it);
      const ts = extractTimestampFromBackupName(name);
      const line = document.createElement('div');
      line.className = 'step';
      const row = document.createElement('div');
      row.style.display = 'flex'; row.style.alignItems = 'center'; row.style.justifyContent = 'space-between';
      const label = document.createElement('div');
      label.textContent = `${formatDisplayFromTimestamp(ts) || name}`;
      const actions = document.createElement('div');
      const btnLoad = document.createElement('button'); btnLoad.className = 'btn'; btnLoad.textContent = 'Load';
      btnLoad.addEventListener('click', () => restoreVersionByName(name));
      actions.appendChild(btnLoad);
      row.appendChild(label); row.appendChild(actions);
      line.appendChild(row);
      frag.appendChild(line);

      // Asynchronously fetch description for this backup and update the label
      fetchBackupMeta(name).then((meta) => {
        if (meta && typeof meta.description === 'string' && meta.description.length > 0) {
          label.textContent = `${formatDisplayFromTimestamp(ts) || name} — ${meta.description}`;
        }
      }).catch(() => {});
    });
    els.versionsList.appendChild(frag);
  }

  async function fetchBackupMeta(objectName) {
    try {
      const { bucket } = getCfg();
      if (!bucket) return {};
      if (!hasValidToken()) return {};
      const res = await fetch(gcsDownloadUrl(bucket, objectName), { headers: { Authorization: `Bearer ${oauth.accessToken}` }, cache: 'no-store' });
      if (!res.ok) return {};
      const json = await res.json();
      let def = null;
      if (json && json.flows && currentFlowKey && json.flows[currentFlowKey]) def = json.flows[currentFlowKey];
      else if (json && currentFlowKey && json[currentFlowKey]) def = json[currentFlowKey];
      else def = json;
      if (!def || typeof def !== 'object') return {};
      const description = typeof def.description === 'string' ? def.description : '';
      const updated_at = typeof def.updated_at === 'string' ? def.updated_at : '';
      return { description, updated_at };
    } catch (_) {
      return {};
    }
  }

  function renderCurrentVersionItem() {
    const flows = (flowDoc && flowDoc.flows) || {};
    const def = flows[currentFlowKey] || {};
    const ts = typeof def.updated_at === 'string' ? def.updated_at : '';
    const desc = typeof def.description === 'string' ? def.description : '';
    const line = document.createElement('div');
    line.className = 'step';
    const row = document.createElement('div');
    row.style.display = 'flex'; row.style.alignItems = 'center'; row.style.justifyContent = 'space-between';
    const label = document.createElement('div');
    const when = formatDisplayFromTimestamp(ts);
    label.textContent = `${when || '(unsaved)'}${desc ? ' — ' + desc : ''}, current`;
    row.appendChild(label);
    line.appendChild(row);
    els.versionsList.appendChild(line);
  }

  async function restoreVersionByName(objectName) {
    try {
      const { bucket } = getCfg();
      if (!bucket) { alert('Missing bucket'); return; }
      if (!hasValidToken()) { alert('Please sign in first.'); return; }
      const res = await fetch(gcsDownloadUrl(bucket, objectName), { headers: { Authorization: `Bearer ${oauth.accessToken}` }, cache: 'no-store' });
      if (!res.ok) throw new Error('Failed to download version');
      const json = await res.json();
      let def = null;
      if (json && json.flows && json.flows[currentFlowKey]) def = json.flows[currentFlowKey];
      else if (json && json[currentFlowKey]) def = json[currentFlowKey];
      else def = json;
      if (!def || typeof def !== 'object') throw new Error('Invalid version structure');
      // Apply to editor state
      if (!flowDoc || !flowDoc.flows) flowDoc = { flows: {} };
      flowDoc.flows[currentFlowKey] = def;
      renderSteps();
    } catch (e) {
      alert('Failed to load version: ' + e.message);
    }
  }

  function setCookie(name, value, days) {
    try {
      const d = new Date();
      d.setTime(d.getTime() + (days*24*60*60*1000));
      const expires = `expires=${d.toUTCString()}`;
      document.cookie = `${encodeURIComponent(name)}=${encodeURIComponent(String(value))}; ${expires}; path=/; SameSite=Lax`;
    } catch (_) {}
  }

  async function ensureFirebaseCookiesFromBucket() {
    try {
      const { bucket } = getCfg();
      if (!bucket || !hasValidToken()) return;
      const url = gcsDownloadUrl(bucket, 'firebase_config.json');
      const res = await fetch(url, { headers: { Authorization: `Bearer ${oauth.accessToken}` }, cache: 'no-store' });
      if (!res.ok) return;
      const json = await res.json();
      if (json && typeof json === 'object') {
        if (json.projectId) setCookie('projectId', json.projectId, 365);
        if (json.apiKey) setCookie('apiKey', json.apiKey, 365);
        if (json.authDomain) setCookie('authDomain', json.authDomain, 365);
      }
    } catch (_) {}
  }

  async function listFlowKeysFromGcs() {
    const { bucket } = getCfg();
    const out = [];
    if (!bucket || !hasValidToken()) return out;
    try {
      let pageToken = '';
      do {
        const prefix = 'flows/';
        const url = gcsListUrl(bucket, prefix) + (pageToken ? `&pageToken=${encodeURIComponent(pageToken)}` : '');
        const res = await fetch(url, { headers: { Authorization: `Bearer ${oauth.accessToken}` }, cache: 'no-store' });
        if (!res.ok) break;
        const json = await res.json();
        const items = Array.isArray(json.items) ? json.items : [];
        for (const it of items) {
          const name = it && it.name ? String(it.name) : '';
          if (!name.startsWith('flows/')) continue;
          if (name.startsWith('flows/backups/')) continue;
          if (!name.toLowerCase().endsWith('.json')) continue;
          // skip legacy combined file
          if (name === 'flows/flow.json') continue;
          const m = name.match(/^flows\/(.+)\.json$/);
          if (m) out.push(m[1]);
        }
        pageToken = json.nextPageToken || '';
      } while (pageToken);
    } catch (_) {}
    return out;
  }

  async function listFlowKeysLocally() {
    // Best-effort: read legacy combined file to derive keys
    try {
      const res = await fetch('flows/flow.json', { cache: 'no-store' });
      if (!res.ok) return [];
      const json = await res.json();
      if (json && json.flows && typeof json.flows === 'object') return Object.keys(json.flows);
    } catch (_) {}
    return [];
  }

  async function loadSingleFlow(key) {
    // Prefer Cloud single file, fallback to site-local candidates, then legacy combined
    const { bucket } = getCfg();
    // Cloud
    if (bucket && hasValidToken()) {
      try {
        const res = await fetch(gcsDownloadUrl(bucket, `flows/${key}.json`), { headers: { Authorization: `Bearer ${oauth.accessToken}` }, cache: 'no-store' });
        if (res.ok) {
          const json = await res.json();
          // Accept either {steps...} or { key: def } or {flows:{}}
          let def = null;
          if (json && json.flows && json.flows[key]) def = json.flows[key];
          else if (json && json[key]) def = json[key];
          else def = json;
          flowDoc = { flows: { [key]: def || {} } };
          currentFlowKey = key;
          return true;
        }
      } catch (_) {}
    }
    // Local direct file candidates
    const candidates = [
      `flows/${key}.json`,
      `../flows/${key}.json`,
      `../../flows/${key}.json`,
      `/flows/${key}.json`
    ];
    for (const rel of candidates) {
      try {
        const res = await fetch(rel, { cache: 'no-store' });
        if (res.ok) {
          const json = await res.json();
          let def = null;
          if (json && json.flows && json.flows[key]) def = json.flows[key];
          else if (json && json[key]) def = json[key];
          else def = json;
          flowDoc = { flows: { [key]: def || {} } };
          currentFlowKey = key;
          return true;
        }
      } catch (_) {}
    }
    // Fallback to legacy combined
    try {
      const res = await fetch('flows/flow.json', { cache: 'no-store' });
      if (res.ok) {
        const json = await res.json();
        const def = json && json.flows ? json.flows[key] : null;
        flowDoc = { flows: def ? { [key]: def } : {} };
        currentFlowKey = def ? key : null;
        return !!def;
      }
    } catch (_) {}
    flowDoc = { flows: {} };
    currentFlowKey = null;
    return false;
  }

  async function loadInitial() {
    try {
      const u = new URL(location.href);
      const sel = u.searchParams.get('flow') || '';
      // Build list of keys
      let keys = [];
      if (hasValidToken()) keys = await listFlowKeysFromGcs();
      if (!keys || keys.length === 0) keys = await listFlowKeysLocally();
      flowKeys = Array.from(new Set(keys)).sort();
      // Best-effort triggers map from legacy combined file
      triggersMap = new Map();
      try {
        const { bucket } = getCfg();
        let combined = null;
        if (bucket && hasValidToken()) {
          const r = await fetch(gcsDownloadUrl(bucket, 'flows/flow.json'), { headers: { Authorization: `Bearer ${oauth.accessToken}` }, cache: 'no-store' });
          if (r.ok) combined = await r.json();
        }
        if (!combined) {
          const r2 = await fetch('flows/flow.json', { cache: 'no-store' });
          if (r2.ok) combined = await r2.json();
        }
        if (combined && combined.flows && typeof combined.flows === 'object') {
          Object.entries(combined.flows).forEach(([k, v]) => {
            if (v && typeof v === 'object' && v.trigger) triggersMap.set(k, String(v.trigger));
          });
        }
      } catch (_) {}

      // Load selected flow if any
      if (sel) {
        await loadSingleFlow(sel);
      } else {
        flowDoc = { flows: {} };
      currentFlowKey = null;
      }
      renderFlows();
      renderSteps();
    } catch (err) {
      console.error(err);
      flowDoc = { flows: {} };
      renderFlows();
      renderSteps();
    }
  }

  function renderFlows() {
    const flows = (flowDoc && flowDoc.flows) || {};
    const selected = currentFlowKey;
    els.flows.innerHTML = '';
    const keys = flowKeys && flowKeys.length ? flowKeys : Object.keys(flows);

    if (!keys || keys.length === 0) {
      const empty = document.createElement('div');
      empty.className = 'empty';
      empty.textContent = 'No flows found.';
      els.flows.appendChild(empty);
      return;
    }

    keys.forEach((key) => {
      const def = flows[key] || {};
      const item = document.createElement('a');
      item.href = `?flow=${encodeURIComponent(key)}`;
      item.className = 'flow-item' + (selected === key ? ' active' : '');

      const icon = document.createElement('div');
      icon.innerHTML = '⚡️';

      const meta = document.createElement('div');
      const k = document.createElement('div');
      k.className = 'flow-key';
      k.textContent = key;
      const t = document.createElement('div');
      t.className = 'flow-trigger';
      const trig = (def && def.trigger) ? def.trigger : (triggersMap.get(key) || '');
      t.textContent = trig;
      meta.appendChild(k);
      meta.appendChild(t);

      item.appendChild(icon);
      item.appendChild(meta);
      els.flows.appendChild(item);
    });
  }

  function renderSteps() {
    els.steps.innerHTML = '';
    const flows = (flowDoc && flowDoc.flows) || {};
    const def = flows[currentFlowKey];

    if (!def) {
      const empty = document.createElement('div');
      empty.className = 'empty';
      empty.textContent = 'Select a flow to edit ask/say texts.';
      els.steps.appendChild(empty);
      return;
    }

    // Header
    const head = document.createElement('div');
    head.className = 'flow-header';
    const title = document.createElement('div');
    title.className = 'flow-title';
    title.textContent = currentFlowKey + (def.trigger ? '  ·  ' + def.trigger : '');
    const desc = document.createElement('div');
    desc.className = 'flow-desc';
    desc.textContent = def.description || '';
    head.appendChild(title);
    head.appendChild(desc);
    els.steps.appendChild(head);

    // Editable flow description
    const descField = fieldText('description', def.description || '', (v) => { def.description = v; });
    els.steps.appendChild(descField);

    const steps = Array.isArray(def.steps) ? def.steps : [];
    steps.forEach((step, idx) => {
      const s = document.createElement('div');
      s.className = 'step';

      const head = document.createElement('div');
      head.className = 'step-head';
      const left = document.createElement('div');
      const type = step.ask ? 'ask' : (step.say ? 'say' : (step.wait ? 'wait' : (step.script ? 'script' : 'step')));
      const badge = document.createElement('span');
      badge.className = 'badge';
      badge.textContent = type.toUpperCase();
      left.appendChild(badge);
      const right = document.createElement('div');
      right.style.display = 'flex';
      right.style.alignItems = 'center';
      right.style.gap = '8px';
      const idxEl = document.createElement('div');
      idxEl.textContent = '#' + (idx + 1);
      idxEl.style.color = '#94a3b8';
      idxEl.style.fontSize = '12px';
      right.appendChild(idxEl);
      // Filters editor on the right side
      right.appendChild(buildFiltersEditor(step, true));
      s.appendChild(head);
      head.appendChild(left);
      head.appendChild(right);

      // Editable fields for ask/say only
      if (step.ask != null || step.say != null) {
        if (step.ask != null) {
          const field = fieldText('ask', step.ask, (v) => { step.ask = v; });
          s.appendChild(field);
        }
        if (step.saveAs != null) {
          const field = fieldText('saveAs', step.saveAs, (v) => { step.saveAs = v; }, true);
          s.appendChild(field);
        }
        if (step.say != null) {
          const field = fieldText('say', step.say, (v) => { step.say = v; });
          s.appendChild(field);
        }
      } else {
        const readOnly = document.createElement('div');
        readOnly.className = 'field';
        const label = document.createElement('div');
        label.className = 'label';
        label.textContent = 'Details';
        const val = document.createElement('div');
        val.textContent = JSON.stringify(step, null, 2);
        readOnly.appendChild(label);
        readOnly.appendChild(val);
        s.appendChild(readOnly);
      }

      els.steps.appendChild(s);
    });
  }

  function fieldText(labelText, value, onInput, singleLine = false) {
    const wrap = document.createElement('div');
    wrap.className = 'field';

    const label = document.createElement('div');
    label.className = 'label';
    label.textContent = labelText;

    let input;
    if (singleLine) {
      input = document.createElement('input');
      input.type = 'text';
      input.value = value == null ? '' : String(value);
    } else {
      input = document.createElement('textarea');
      input.value = value == null ? '' : String(value);
    }

    input.addEventListener('input', (e) => onInput(e.target.value));

    wrap.appendChild(label);
    wrap.appendChild(input);
    return wrap;
  }

  // ---- Nested filters: parser, serializer, summary, and modal editor ----
  function filtersToNode(filters) {
    if (filters == null) return null;
    const t = typeof filters;
    if (t === 'string') return { type: 'cond', text: String(filters) };
    if (Array.isArray(filters)) {
      const children = filters.map((f) => filtersToNode(f)).filter(Boolean);
      return { type: 'group', op: 'OR', children };
    }
    if (t === 'object') {
      const andArr = Array.isArray(filters.and) ? filters.and : [];
      const children = andArr.map((f) => filtersToNode(f)).filter(Boolean);
      return { type: 'group', op: 'AND', children };
    }
    return null;
  }

  function normalizeNode(node) {
    if (!node) return null;
    if (node.type === 'cond') {
      const txt = String(node.text || '').trim();
      return txt ? { type: 'cond', text: txt } : null;
    }
    if (node.type === 'group') {
      const op = node.op === 'AND' ? 'AND' : 'OR';
      const children = (node.children || []).map(normalizeNode).filter(Boolean);
      // flatten nested same-op groups
      const flat = [];
      children.forEach((c) => {
        if (c && c.type === 'group' && c.op === op) flat.push(...(c.children || [])); else flat.push(c);
      });
      if (flat.length === 0) return null;
      if (flat.length === 1) return flat[0];
      return { type: 'group', op, children: flat };
    }
    return null;
  }

  function nodeToFilters(node) {
    const n = normalizeNode(node);
    if (!n) return undefined;
    if (n.type === 'cond') return n.text;
    if (n.type === 'group') {
      const parts = (n.children || []).map(nodeToFilters).filter((x) => x != null);
      if (n.op === 'AND') return { and: parts };
      return parts; // OR array
    }
    return undefined;
  }

  function summarizeNode(node) {
    const n = normalizeNode(node);
    if (!n) return '(no filters)';
    if (n.type === 'cond') return n.text;
    const op = n.op;
    const parts = (n.children || []).map((c) => {
      if (c.type === 'cond') return c.text;
      const inner = summarizeNode(c);
      // add parentheses for nested groups
      return '(' + inner + ')';
    });
    return parts.join(op === 'AND' ? ' AND ' : ' OR ');
  }

  function buildFiltersEditor(step, editable) {
    const wrap = document.createElement('div');
    wrap.style.display = 'flex';
    wrap.style.alignItems = 'center';
    wrap.style.gap = '8px';

    function getNode() { return filtersToNode(step.filters); }
    const summary = document.createElement('div');
    summary.style.fontSize = '12px';
    summary.style.color = '#cbd5e1';
    summary.style.maxWidth = '380px';
    summary.style.whiteSpace = 'nowrap';
    summary.style.overflow = 'hidden';
    summary.style.textOverflow = 'ellipsis';
    summary.textContent = summarizeNode(getNode());

    const btn = document.createElement('button');
    btn.className = 'btn';
    btn.textContent = 'Edit filters';
    btn.disabled = !editable;
    btn.addEventListener('click', () => openFiltersModal(step, summary));

    wrap.appendChild(summary);
    wrap.appendChild(btn);
    return wrap;
  }

  function openFiltersModal(step, summaryEl) {
    const overlay = document.createElement('div');
    overlay.style.position = 'fixed'; overlay.style.inset = '0';
    overlay.style.background = 'rgba(0,0,0,0.5)'; overlay.style.zIndex = '1000';

    const dialog = document.createElement('div');
    dialog.className = 'panel';
    dialog.style.position = 'absolute'; dialog.style.top = '10%'; dialog.style.left = '50%'; dialog.style.transform = 'translateX(-50%)';
    dialog.style.width = 'min(860px, 92vw)'; dialog.style.maxHeight = '80vh'; dialog.style.overflow = 'auto'; dialog.style.padding = '12px';

    const header = document.createElement('div'); header.className = 'flow-header';
    const title = document.createElement('div'); title.className = 'flow-title'; title.textContent = 'Edit Filters';
    const actions = document.createElement('div'); actions.className = 'toolbar';
    const btnClose = document.createElement('button'); btnClose.className = 'btn'; btnClose.textContent = 'Close';
    actions.appendChild(btnClose);
    header.appendChild(title); header.appendChild(actions);

    const body = document.createElement('div'); body.className = 'steps';

    let node = filtersToNode(step.filters) || { type: 'group', op: 'AND', children: [] };

    function buildNodeEditor(n) {
      if (!n || n.type === 'cond') {
        const line = document.createElement('div'); line.className = 'field';
        const l = document.createElement('div'); l.className = 'label'; l.textContent = 'condition';
        const ta = document.createElement('textarea'); ta.value = String((n && n.text) || '');
        ta.addEventListener('input', (e) => { if (n) n.text = e.target.value; });
        line.appendChild(l); line.appendChild(ta);
        return line;
      }
      // group editor
      const box = document.createElement('div'); box.className = 'step';
      const head = document.createElement('div'); head.style.display = 'flex'; head.style.alignItems = 'center'; head.style.gap = '8px'; head.style.marginBottom = '8px';
      const opLabel = document.createElement('div'); opLabel.className = 'label'; opLabel.textContent = 'Operator';
      const opSel = document.createElement('select');
      ['AND','OR'].forEach((k) => { const o = document.createElement('option'); o.value = k; o.textContent = k; opSel.appendChild(o); });
      opSel.value = n.op === 'OR' ? 'OR' : 'AND';
      opSel.style.background = 'rgba(17,24,39,0.6)'; opSel.style.border = '1px solid #1f2937'; opSel.style.color = '#e5e7eb'; opSel.style.borderRadius = '8px'; opSel.style.padding = '4px 6px';
      opSel.addEventListener('change', () => { n.op = opSel.value; });
      head.appendChild(opLabel); head.appendChild(opSel);
      box.appendChild(head);

      const childWrap = document.createElement('div'); childWrap.style.display = 'grid'; childWrap.style.gap = '8px';

      function renderChildren() {
        childWrap.innerHTML = '';
        (n.children || []).forEach((c, idx) => {
          const row = document.createElement('div'); row.className = 'field';
          const controls = document.createElement('div'); controls.className = 'label';
          const btnUp = document.createElement('button'); btnUp.className = 'btn'; btnUp.textContent = '↑'; btnUp.style.marginRight = '4px'; btnUp.disabled = idx === 0;
          const btnDown = document.createElement('button'); btnDown.className = 'btn'; btnDown.textContent = '↓'; btnDown.style.marginRight = '4px'; btnDown.disabled = idx >= (n.children.length - 1);
          const btnDel = document.createElement('button'); btnDel.className = 'btn'; btnDel.textContent = 'Delete';
          btnUp.addEventListener('click', () => { const t = n.children[idx-1]; n.children[idx-1] = n.children[idx]; n.children[idx] = t; renderChildren(); });
          btnDown.addEventListener('click', () => { const t = n.children[idx+1]; n.children[idx+1] = n.children[idx]; n.children[idx] = t; renderChildren(); });
          btnDel.addEventListener('click', () => { n.children.splice(idx, 1); renderChildren(); });
          controls.appendChild(btnUp); controls.appendChild(btnDown); controls.appendChild(btnDel);
          const editor = buildNodeEditor(c);
          row.appendChild(controls); row.appendChild(editor);
          childWrap.appendChild(row);
        });
      }

      const addRow = document.createElement('div'); addRow.style.display = 'flex'; addRow.style.gap = '8px'; addRow.style.marginTop = '8px';
      const btnAddCond = document.createElement('button'); btnAddCond.className = 'btn'; btnAddCond.textContent = 'Add condition';
      const btnAddGroup = document.createElement('button'); btnAddGroup.className = 'btn'; btnAddGroup.textContent = 'Add subgroup';
      btnAddCond.addEventListener('click', () => { n.children = n.children || []; n.children.push({ type: 'cond', text: '' }); renderChildren(); });
      btnAddGroup.addEventListener('click', () => { n.children = n.children || []; n.children.push({ type: 'group', op: 'AND', children: [] }); renderChildren(); });
      addRow.appendChild(btnAddCond); addRow.appendChild(btnAddGroup);

      renderChildren();
      box.appendChild(childWrap);
      box.appendChild(addRow);
      return box;
    }

    const editorEl = buildNodeEditor(node);

    const footer = document.createElement('div'); footer.className = 'footer';
    const hint = document.createElement('div'); hint.className = 'hint'; hint.textContent = 'Variables must be written as {{variable}}.';
    const buttons = document.createElement('div');
    const btnClear = document.createElement('button'); btnClear.className = 'btn'; btnClear.textContent = 'Clear';
    const btnSave = document.createElement('button'); btnSave.className = 'btn primary'; btnSave.textContent = 'Save';
    buttons.appendChild(btnClear); buttons.appendChild(btnSave);
    footer.appendChild(hint); footer.appendChild(buttons);

    btnClose.addEventListener('click', () => overlay.remove());
    btnClear.addEventListener('click', () => { node = { type: 'group', op: 'AND', children: [] }; const repl = buildNodeEditor(node); editorEl.replaceWith(repl); body.insertBefore(repl, footer); });
    btnSave.addEventListener('click', () => {
      step.filters = nodeToFilters(node);
      if (summaryEl) summaryEl.textContent = summarizeNode(filtersToNode(step.filters));
      overlay.remove();
    });

    dialog.appendChild(header);
    dialog.appendChild(body);
    body.appendChild(editorEl);
    dialog.appendChild(footer);
    overlay.appendChild(dialog);
    document.body.appendChild(overlay);
  }

  function downloadJson(obj, filename) {
    const json = JSON.stringify(obj, null, 2);
    const blob = new Blob([json], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    setTimeout(() => {
      URL.revokeObjectURL(url);
      a.remove();
    }, 0);
  }

  async function saveCurrentFlowToCloudWithBackup() {
    if (!flowDoc || !currentFlowKey) return alert('Select a flow first.');
    const def = (flowDoc.flows && flowDoc.flows[currentFlowKey]) || null;
    if (!def) return alert('Nothing to save.');
    const { bucket } = getCfg();
    if (!bucket) return alert('Please configure Bucket.');
    if (!hasValidToken()) { alert('Please sign in first.'); return; }
    // Ensure each step has a unique 8-char step_id before saving
    try {
      const existing = new Set();
      function genId() {
        const alphabet = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
        let out = '';
        for (let i = 0; i < 8; i++) out += alphabet.charAt(Math.floor(Math.random() * alphabet.length));
        return out;
      }
      if (def && Array.isArray(def.steps)) {
        // collect existing ids first to avoid duplicates
        def.steps.forEach((s) => { if (s && typeof s.step_id === 'string' && s.step_id.length > 0) existing.add(s.step_id); });
        def.steps.forEach((s) => {
          if (!s || (typeof s.step_id === 'string' && s.step_id.length > 0)) return;
          let id = '';
          do { id = genId(); } while (existing.has(id));
          s.step_id = id;
          existing.add(id);
        });
      }
    } catch (_) {}
    try {
      const token = oauth.accessToken;
      const mainPath = `flows/${currentFlowKey}.json`;
      // 1) Read current file; if present, back it up using its own updated_at
      let currentText = null;
      let previousUpdatedAt = '';
      try {
        const getRes = await fetch(gcsDownloadUrl(bucket, mainPath), { headers: { Authorization: `Bearer ${token}` }, cache: 'no-store' });
        if (getRes.ok) currentText = await getRes.text();
      } catch (_) {}
      if (currentText != null) {
        try {
          const json = JSON.parse(currentText);
          let prevDef = null;
          if (json && json.flows && json.flows[currentFlowKey]) prevDef = json.flows[currentFlowKey];
          else if (json && json[currentFlowKey]) prevDef = json[currentFlowKey];
          else prevDef = json;
          if (prevDef && typeof prevDef.updated_at === 'string') previousUpdatedAt = prevDef.updated_at;
        } catch (_) {}
        const tsForBackup = previousUpdatedAt || formatUtcNowForFlow();
        const backupName = formatBackupName(currentFlowKey, tsForBackup);
        const upBackup = await fetch(gcsUploadUrl(bucket, backupName), {
          method: 'POST',
          headers: { 'Authorization': `Bearer ${token}`, 'Content-Type': 'application/json' },
          body: currentText
        });
        if (!upBackup.ok) console.warn('Backup upload failed');
      }
      // 2) Upload new content (store as single-flow object)
      const newTimestampUtc = formatUtcNowForFlow();
      try { def.updated_at = newTimestampUtc; } catch (_) {}
      const newBody = JSON.stringify(def, null, 2);
      const upMain = await fetch(gcsUploadUrl(bucket, mainPath), {
        method: 'POST',
        headers: { 'Authorization': `Bearer ${token}`, 'Content-Type': 'application/json' },
        body: newBody
      });
      if (!upMain.ok) throw new Error('Upload failed');

      // 3) Update versions file within flows prefix (flows/versions.txt)
      try {
        const versionsPath = 'flows/versions.txt';
        // Read existing text if any
        let existing = '';
        try {
          const resV = await fetch(gcsDownloadUrl(bucket, versionsPath), { headers: { Authorization: `Bearer ${token}` }, cache: 'no-store' });
          if (resV.ok) existing = await resV.text();
        } catch (_) {}
        // Convert to map, update, and serialize back to key=value lines
        const map = {};
        String(existing || '')
          .split(/\r?\n/)
          .map((l) => l.trim())
          .filter((l) => l && !l.startsWith('#') && !l.startsWith('//'))
          .forEach((line) => {
            const idx = line.indexOf('=');
            if (idx <= 0) return;
            const k = line.slice(0, idx).trim();
            const v = line.slice(idx + 1).trim();
            if (k) map[k] = v;
          });
        map[currentFlowKey] = newTimestampUtc;
        const bodyV = Object.entries(map).map(([k, v]) => `${k}=${v}`).join('\n') + '\n';
        await fetch(gcsUploadUrl(bucket, versionsPath), {
          method: 'POST',
          headers: { 'Authorization': `Bearer ${token}`, 'Content-Type': 'text/plain; charset=utf-8' },
          body: bodyV
        });
      } catch (_) {}
      alert('Saved to Cloud.');
    } catch (e) {
      console.error(e);
      alert('Save failed: ' + e.message);
    }
  }

  function loadStoredTokenOnly() {
    try {
      const stored = JSON.parse(localStorage.getItem('gcs_token') || '{}');
      const { accessToken, tokenExpiresAt } = stored;
      if (accessToken && Number.isFinite(tokenExpiresAt)) {
        oauth.accessToken = accessToken;
        oauth.tokenExpiresAt = tokenExpiresAt;
      }
    } catch (_) {}
    updateAuthStatus();
  }

  function hasValidToken() {
    return !!(oauth.accessToken && Date.now() < oauth.tokenExpiresAt - 5000);
  }

  function handleImportFile(file) {
    const reader = new FileReader();
    reader.onload = () => {
      try {
        const data = JSON.parse(reader.result);
        if (!data || typeof data !== 'object' || !data.flows) {
          throw new Error('Invalid structure: expected root object with "flows"');
        }
        flowDoc = data;
        currentFlowKey = null;
        renderFlows();
        renderSteps();
      } catch (e) {
        alert('Invalid JSON: ' + e.message);
      }
    };
    reader.readAsText(file);
  }

  // Events
  els.fileInput.addEventListener('change', (e) => {
    const file = e.target.files && e.target.files[0];
    if (file) handleImportFile(file);
    e.target.value = '';
  });
  els.btnPublish.addEventListener('click', saveCurrentFlowToCloudWithBackup);
  els.btnAuth.addEventListener('click', async () => {
    try { await getAccessToken(true); } catch (e) { alert('Auth failed: ' + e.message); }
  });
  els.btnSignOut.addEventListener('click', signOut);
  if (els.btnSignOutHeader) els.btnSignOutHeader.addEventListener('click', signOut);
  if (els.btnBrowseVersions) els.btnBrowseVersions.addEventListener('click', async () => {
    ensureVersionsPanelVisible(true);
    await loadVersionsFirstPage();
  });
  if (els.btnLoadMoreVersions) els.btnLoadMoreVersions.addEventListener('click', loadMoreVersions);
  if (els.btnCloseVersions) els.btnCloseVersions.addEventListener('click', () => ensureVersionsPanelVisible(false));

  // Init
  loadConfig();
  // Only load stored token; do not auto sign-in or refresh
  loadStoredTokenOnly();
  // If token already present, set Firebase cookies from bucket for other pages
  if (hasValidToken()) { ensureFirebaseCookiesFromBucket().catch(() => {}); }
  loadInitial();
  </script>
  <!-- Load Google Identity Services client library (deferred). No secrets embedded. -->
  <script src="https://accounts.google.com/gsi/client" async defer></script>
</body>
</html>
