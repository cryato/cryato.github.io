<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Conversations Viewer</title>
  <style>
    :root { --bg: #0f172a; --panel: #111827; --muted: #94a3b8; --text: #e5e7eb; --primary: #22d3ee; --accent: #8b5cf6; }
    html, body { height: 100%; }
    body { margin: 0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica Neue, Arial; background: linear-gradient(180deg, #0b1022 0%, #0f172a 100%); color: var(--text); }
    header { display: flex; align-items: center; justify-content: space-between; padding: 12px 16px; border-bottom: 1px solid #1f2937; position: sticky; top: 0; background: rgba(17,24,39,0.6); backdrop-filter: blur(8px); z-index: 10; }
    header h1 { font-size: 16px; margin: 0; }
    .toolbar { display: flex; gap: 8px; align-items: center; }
    input[type="text"], input[type="date"], select { background: rgba(17,24,39,0.6); border: 1px solid #1f2937; color: var(--text); padding: 8px 10px; border-radius: 8px; outline: none; font-size: 13px; }
    .btn { appearance: none; border: 1px solid #283449; background: linear-gradient(180deg, #0b1224 0%, #0a1222 100%); color: #e5e7eb; border-radius: 8px; padding: 8px 12px; font-size: 13px; cursor: pointer; }
    .container { display: grid; grid-template-columns: 320px 1fr; gap: 16px; padding: 16px; }
    .panel { background: rgba(17,24,39,0.65); border: 1px solid #1f2937; border-radius: 12px; }
    .left { padding: 12px; }
    .field { display: grid; grid-template-columns: 90px 1fr; align-items: center; gap: 8px; margin: 8px 0; }
    .label { color: var(--muted); font-size: 12px; }
    .messages { display: flex; flex-direction: column; height: calc(100vh - 120px); overflow: auto; padding: 12px; }
    .msg { border: 1px solid #1f2937; background: rgba(2,6,23,0.55); border-radius: 10px; padding: 10px; margin: 8px 0; }
    .meta { color: var(--muted); font-size: 12px; margin-bottom: 6px; display: flex; gap: 8px; flex-wrap: wrap; }
    .bubble-user { border-left: 3px solid #22d3ee; }
    .bubble-bot { border-left: 3px solid #8b5cf6; }
    a { color: #93c5fd; }
    .empty { color: var(--muted); padding: 16px; }
  </style>
</head>
<body>
  <header>
    <h1>Conversations</h1>
    <div class="toolbar">
      <button id="btnReload" class="btn">Reload</button>
      <a id="lnkInteractions" class="btn" href="#">Interactions</a>
    </div>
  </header>

    <div class="container">
    <div class="panel left">
      <div class="field">
        <div class="label">Bot</div>
        <select id="selBot">
          <option value="">Main Bot</option>
          <!-- Additional bot options populated from URL param or hardcoded -->
        </select>
      </div>
      <div class="field">
        <div class="label">Customer ID</div>
        <input id="inpUserId" type="text" placeholder="user_id or botname+user_id" />
      </div>
      <div class="field">
        <div class="label">Start</div>
        <input id="inpStart" type="date" />
      </div>
      <div class="field">
        <div class="label">End</div>
        <input id="inpEnd" type="date" />
      </div>
      <div class="field">
        <div></div>
        <button id="btnApply" class="btn">Apply</button>
      </div>
      <div style="margin-top:12px; color: var(--muted); font-size: 12px;"></div>
    </div>
    <div class="panel">
      <div id="messages" class="messages"></div>
    </div>
  </div>

  <script type="module">
    import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.12.5/firebase-app.js';
    import { getAuth, signInAnonymously, onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/10.12.5/firebase-auth.js';
    import { getFirestore, collection, query, where, orderBy, limit, startAfter, Timestamp, getDocs } from 'https://www.gstatic.com/firebasejs/10.12.5/firebase-firestore.js';

    // Configure via URL params / cookies / (best-effort) GCS firebase_config.json.
    const TAG = '[Conversations]';
    function readCookie(name) {
      const match = document.cookie.match(new RegExp('(?:^|; )' + name.replace(/([.$?*|{}()\[\]\\\/\+^])/g, '\\$1') + '=([^;]*)'));
      return match ? decodeURIComponent(match[1]) : '';
    }
    function setCookie(name, value, days) {
      try {
        const d = new Date();
        d.setTime(d.getTime() + (days*24*60*60*1000));
        const expires = `expires=${d.toUTCString()}`;
        document.cookie = `${encodeURIComponent(name)}=${encodeURIComponent(String(value))}; ${expires}; path=/; SameSite=Lax`;
      } catch (_) {}
    }
    function safeJsonParse(raw, fallback) {
      try { return JSON.parse(raw); } catch (_) { return fallback; }
    }
    function getConfigFromUrlOrCookies() {
      const u = new URL(location.href);
      const p = (k) => u.searchParams.get(k) || '';
      return {
        apiKey: p('apiKey') || readCookie('apiKey') || '',
        authDomain: p('authDomain') || readCookie('authDomain') || '',
        projectId: p('projectId') || readCookie('projectId') || '',
      };
    }
    function getStoredGcsToken() {
      const stored = safeJsonParse(localStorage.getItem('gcs_token') || '{}', {});
      const accessToken = stored && typeof stored.accessToken === 'string' ? stored.accessToken : '';
      const tokenExpiresAt = stored && Number.isFinite(stored.tokenExpiresAt) ? stored.tokenExpiresAt : 0;
      return { accessToken, tokenExpiresAt };
    }
    function getStoredGcsBucket() {
      const stored = safeJsonParse(localStorage.getItem('gcs_config') || '{}', {});
      const bucket = stored && typeof stored.bucket === 'string' ? stored.bucket : '';
      return { bucket };
    }
    function hasValidGcsToken(tok) {
      return !!(tok && tok.accessToken && Date.now() < (tok.tokenExpiresAt || 0) - 5000);
    }
    function gcsDownloadUrl(bucket, objectName) {
      return `https://storage.googleapis.com/storage/v1/b/${encodeURIComponent(bucket)}/o/${encodeURIComponent(objectName)}?alt=media`;
    }
    async function tryHydrateFirebaseConfigFromGcs() {
      const { bucket } = getStoredGcsBucket();
      const tok = getStoredGcsToken();
      if (!bucket || !hasValidGcsToken(tok)) return null;
      try {
        const res = await fetch(gcsDownloadUrl(bucket, 'firebase_config.json'), {
          headers: { Authorization: `Bearer ${tok.accessToken}` },
          cache: 'no-store'
        });
        if (!res.ok) {
          console.warn(TAG, 'Failed to fetch firebase_config.json from GCS', { bucket, status: res.status });
          return null;
        }
        const json = await res.json();
        if (!json || typeof json !== 'object') return null;
        if (json.projectId) setCookie('projectId', json.projectId, 365);
        if (json.apiKey) setCookie('apiKey', json.apiKey, 365);
        if (json.authDomain) setCookie('authDomain', json.authDomain, 365);
        return {
          apiKey: json.apiKey || '',
          authDomain: json.authDomain || '',
          projectId: json.projectId || '',
        };
      } catch (e) {
        console.warn(TAG, 'Exception while fetching firebase_config.json from GCS', e);
        return null;
      }
    }
    function renderFatal(msg, details) {
      const el = document.getElementById('messages');
      if (!el) return;
      const d = details ? `<pre style="white-space:pre-wrap; font-size:12px; color:#cbd5e1; margin-top:10px;">${details}</pre>` : '';
      el.innerHTML = `<div class="empty"><div style="font-weight:600; color:#fecaca;">${msg}</div>${d}</div>`;
    }

    async function diagnoseIdentityToolkit(apiKey) {
      const out = { ok: false, status: 0, body: null, url: '' };
      if (!apiKey) return out;
      const url = `https://identitytoolkit.googleapis.com/v1/accounts:signUp?key=${encodeURIComponent(apiKey)}`;
      out.url = url;
      try {
        const res = await fetch(url, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ returnSecureToken: true }),
          cache: 'no-store'
        });
        out.status = res.status;
        const text = await res.text();
        try { out.body = JSON.parse(text); } catch (_) { out.body = text; }
        out.ok = res.ok;
        return out;
      } catch (e) {
        out.body = { exception: e && e.message ? e.message : String(e) };
        return out;
      }
    }

    function explainIdentityToolkitDiagnosis(diag) {
      const msg = diag && diag.body && diag.body.error && diag.body.error.message ? String(diag.body.error.message) : '';
      if (!msg) return '';
      // Common Identity Toolkit / Firebase Auth setup failures
      if (msg.includes('CONFIGURATION_NOT_FOUND')) {
        return [
          'Identity Toolkit returned CONFIGURATION_NOT_FOUND.',
          'This usually means Firebase Authentication/Identity Platform is not enabled/configured for this Google Cloud project, or the API key is not allowed to use Identity Toolkit.',
          'Fix: In Firebase Console → Authentication → Get started (or Sign-in method), enable Authentication and enable Anonymous (or another provider).',
          'Also check: Google Cloud Console → APIs & Services → API key restrictions (allow Identity Toolkit) + HTTP referrers include your site.'
        ].join('\n');
      }
      if (msg.includes('OPERATION_NOT_ALLOWED')) {
        return [
          'Identity Toolkit returned OPERATION_NOT_ALLOWED.',
          'This usually means the provider you are trying to use is disabled.',
          'Fix: Firebase Console → Authentication → Sign-in method → enable Anonymous.'
        ].join('\n');
      }
      if (msg.includes('API_KEY_INVALID')) {
        return [
          'Identity Toolkit returned API_KEY_INVALID.',
          'Fix: ensure firebase_config.json has the correct apiKey for projectId/authDomain.'
        ].join('\n');
      }
      if (msg.includes('API_KEY_HTTP_REFERRER_BLOCKED')) {
        return [
          'Identity Toolkit returned API_KEY_HTTP_REFERRER_BLOCKED.',
          'Fix: in Google Cloud Console → APIs & Services → Credentials, edit this API key and add your site origin to HTTP referrers (or remove referrer restriction).'
        ].join('\n');
      }
      if (msg.includes('PROJECT_NOT_FOUND')) {
        return [
          'Identity Toolkit returned PROJECT_NOT_FOUND.',
          'Fix: firebase_config.json likely points to a deleted/wrong projectId or mismatched apiKey.'
        ].join('\n');
      }
      return `Identity Toolkit error: ${msg}`;
    }

    async function main() {
      const els = {
        selBot: document.getElementById('selBot'),
        inpUserId: document.getElementById('inpUserId'),
        inpStart: document.getElementById('inpStart'),
        inpEnd: document.getElementById('inpEnd'),
        btnApply: document.getElementById('btnApply'),
        btnReload: document.getElementById('btnReload'),
        messages: document.getElementById('messages')
      };

      const url = new URL(location.href);

      // Populate bot dropdown from URL param 'bots' (comma-separated) or localStorage
      function populateBotDropdown() {
        const urlBots = url.searchParams.get('bots') || '';
        const storedBots = localStorage.getItem('conversations_bots') || '';
        const botsStr = urlBots || storedBots || '';
        if (botsStr) {
          localStorage.setItem('conversations_bots', botsStr);
          const botNames = botsStr.split(',').map(b => b.trim()).filter(Boolean);
          for (const botName of botNames) {
            const opt = document.createElement('option');
            opt.value = botName;
            opt.textContent = botName;
            els.selBot.appendChild(opt);
          }
        }
      }
      populateBotDropdown();
      function buildUrlWithAuth(path, extraParams) {
        const params = new URLSearchParams();
        // Only include context-specific extras; do NOT carry auth params anymore
        Object.entries(extraParams || {}).forEach(([k, v]) => {
          if (v != null && String(v).length > 0) params.set(k, String(v));
        });
        const qs = params.toString();
        return qs ? `${path}?${qs}` : path;
      }
      // update header link
      (function updateHeaderLinks(){
        const l = document.getElementById('lnkInteractions');
        if (l) l.href = buildUrlWithAuth('interactions', {});
      })();

      // Resolve Firebase config
      let cfg = getConfigFromUrlOrCookies();
      const cfgWasMissing = !(cfg && cfg.apiKey && cfg.projectId);
      if (cfgWasMissing) {
        console.warn(TAG, 'Missing Firebase config from URL/cookies; attempting to hydrate from GCS token/bucket...', {
          haveApiKey: !!cfg.apiKey,
          haveAuthDomain: !!cfg.authDomain,
          haveProjectId: !!cfg.projectId,
          origin: location.origin,
          pathname: location.pathname,
          hasGcsToken: hasValidGcsToken(getStoredGcsToken()),
          hasGcsBucket: !!getStoredGcsBucket().bucket
        });
        const hydrated = await tryHydrateFirebaseConfigFromGcs();
        if (hydrated) cfg = hydrated;
        else cfg = getConfigFromUrlOrCookies(); // re-read (maybe cookies were set elsewhere)
      }
      if (!(cfg && cfg.apiKey && cfg.projectId)) {
        const details = JSON.stringify({
          origin: location.origin,
          pathname: location.pathname,
          cfg: { apiKey: !!cfg.apiKey, authDomain: !!cfg.authDomain, projectId: !!cfg.projectId },
          hint: 'Open editor, sign in, open any flow once (to write firebase_config cookies), then reload. Or pass ?apiKey=...&authDomain=...&projectId=... in the URL.'
        }, null, 2);
        console.error(TAG, 'Cannot initialize Firebase: missing config', details);
        renderFatal('Cannot load conversations: missing Firebase configuration.', details);
        return;
      }

      console.log(TAG, 'Firebase config resolved', { projectId: cfg.projectId, authDomain: cfg.authDomain || '(empty)' });
      const app = initializeApp({ apiKey: cfg.apiKey, authDomain: cfg.authDomain, projectId: cfg.projectId });
      const auth = getAuth(app);
      const db = getFirestore(app);

      const initialUserId = url.searchParams.get('user_id') || '';
      if (initialUserId) els.inpUserId.value = initialUserId;
      
      // Set initial bot selection from URL param 'bot'
      const initialBot = url.searchParams.get('bot') || '';
      if (initialBot) {
        // Ensure the bot option exists (add it if not)
        const existingOpt = Array.from(els.selBot.options).find(o => o.value === initialBot);
        if (!existingOpt) {
          const opt = document.createElement('option');
          opt.value = initialBot;
          opt.textContent = initialBot;
          els.selBot.appendChild(opt);
        }
        els.selBot.value = initialBot;
      }

      // default date range: last 7 days
      const today = new Date();
      const startDefault = new Date(today.getTime() - 6 * 24 * 60 * 60 * 1000);
      const toDateInput = (d) => d.toISOString().slice(0, 10);
      els.inpStart.value = toDateInput(startDefault);
      els.inpEnd.value = toDateInput(today);

      // NOTE: chat_id has historically been written as either a number or a string.
      // For main bot: chat_id is plain numeric ID (e.g., "6058404651")
      // For other bots: chat_id is prefixed string (e.g., "otherbot6058404651")
      // This UI queries BOTH representations for main bot and merges results so conversations remain visible.
      let paging = { byKey: Object.create(null), pageSize: 30 };

      /**
       * Build chat_id candidates based on user input and selected bot.
       * Supports:
       * 1. User enters prefixed ID directly (e.g., "otherbot6058404651") - query as-is
       * 2. User selects bot from dropdown + enters plain ID - construct prefixed ID
       * 3. Main bot selected (empty) + numeric ID - query both numeric and string versions (legacy support)
       */
      function chatIdCandidates(userIdRaw, selectedBot) {
        const s = String(userIdRaw || '').trim();
        if (!s) return [];
        const out = [];
        
        // Check if user entered a prefixed ID directly (letters/underscores followed by digits)
        // This pattern matches: botname123456 but NOT plain 123456
        const prefixMatch = s.match(/^([a-zA-Z_][a-zA-Z0-9_]*)(-?\d+)$/);
        if (prefixMatch) {
          // User entered a prefixed format directly - use it as-is (string query only)
          out.push({ key: 'prefixed', value: s });
          return out;
        }
        
        // Otherwise, use dropdown selection to determine chat_id format
        if (selectedBot) {
          // Non-main bot selected: construct prefixed ID (botname + userId)
          out.push({ key: 'str', value: `${selectedBot}${s}` });
        } else {
          // Main bot selected (empty string): query both numeric and string for legacy support
          if (/^-?\d+$/.test(s)) {
            const n = Number(s);
            if (Number.isFinite(n)) out.push({ key: 'num', value: n });
          }
          out.push({ key: 'str', value: s });
        }
        
        // de-dupe by key+type+stringified value
        const seen = new Set();
        return out.filter((c) => {
          const k = `${c.key}:${typeof c.value}:${String(c.value)}`;
          if (seen.has(k)) return false;
          seen.add(k);
          return true;
        });
      }

      function ensurePagingKey(key) {
        if (!paging.byKey[key]) paging.byKey[key] = { last: null, done: false };
        return paging.byKey[key];
      }

      function buildQueryForChatId(chatIdValue, startDate, endDate, pageState) {
        const col = collection(db, 'conversations');
        const constraints = [ where('chat_id', '==', chatIdValue), orderBy('date', 'desc'), limit(paging.pageSize) ];
        // date is timestampValue in server; when loaded via SDK, it is a Firestore Timestamp
        if (startDate) constraints.push(where('date', '>=', Timestamp.fromDate(startDate)));
        if (endDate) {
          const end = new Date(endDate.getTime());
          end.setHours(23,59,59,999);
          constraints.push(where('date', '<=', Timestamp.fromDate(end)));
        }
        if (pageState && pageState.last) constraints.push(startAfter(pageState.last));
        return query(col, ...constraints);
      }

      function tsToMillis(t) {
        try {
          if (!t) return 0;
          if (typeof t.toMillis === 'function') return t.toMillis();
          if (t instanceof Date) return t.getTime();
          const d = new Date(t);
          return isNaN(d.getTime()) ? 0 : d.getTime();
        } catch (_) {
          return 0;
        }
      }

      function clearAndRenderEmpty() {
        els.messages.innerHTML = '<div class="empty">No messages</div>';
      }

      function renderMessagesAsc(docs, { prepend } = { prepend: false }) {
        const frag = document.createDocumentFragment();
        docs.forEach((doc) => {
          const d = doc.data();
          const div = document.createElement('div');
          const from = d.from || 'unknown';
          const cls = from === 'user' ? 'bubble-user' : 'bubble-bot';
          div.className = `msg ${cls}`;
          const ts = d.date && d.date.toDate ? d.date.toDate() : null;
          const meta = document.createElement('div');
          meta.className = 'meta';
          const reqUrl = d.request_id ? buildUrlWithAuth('interactions', { request_id: d.request_id }) : null;
          const req = reqUrl ? `<a href="${reqUrl}">request:${d.request_id}</a>` : '';
          meta.innerHTML = `${ts ? ts.toLocaleString() : ''} · from: ${from}${req ? ' · ' + req : ''}`;
          const body = document.createElement('div');
          if ((d.type === 'photo' || d.type === 'video') && d.media_url) {
            if (d.type === 'video') {
              const video = document.createElement('video');
              video.src = d.media_url;
              video.controls = true;
              video.style.maxWidth = '260px';
              video.style.borderRadius = '8px';
              video.style.display = 'block';
              video.style.marginBottom = '6px';
              body.appendChild(video);
            } else {
              const img = document.createElement('img');
              img.src = d.media_url;
              img.style.maxWidth = '260px';
              img.style.borderRadius = '8px';
              img.style.display = 'block';
              img.style.marginBottom = '6px';
              body.appendChild(img);
            }
            const cap = String(d.contents || '').trim();
            if (cap.length > 0) {
              const caption = document.createElement('div');
              caption.textContent = cap;
              body.appendChild(caption);
            }
          } else {
            body.textContent = d.contents || '';
          }
          div.appendChild(meta);
          div.appendChild(body);
          frag.appendChild(div);
        });
        if (prepend) {
          const prevHeight = els.messages.scrollHeight;
          els.messages.insertBefore(frag, els.messages.firstChild);
          const newHeight = els.messages.scrollHeight;
          els.messages.scrollTop += (newHeight - prevHeight);
        } else {
          els.messages.innerHTML = '';
          els.messages.appendChild(frag);
          els.messages.scrollTop = els.messages.scrollHeight;
        }
      }

      async function fetchMergedBatch(cands, startDate, endDate) {
        const byId = new Map();
        let anyNonEmpty = false;

        for (const c of cands) {
          const st = ensurePagingKey(c.key);
          if (st.done) continue;
          const q = buildQueryForChatId(c.value, startDate, endDate, st);
          const snap = await getDocs(q);
          if (snap.empty) {
            st.done = true;
            continue;
          }
          anyNonEmpty = true;
          const docsDesc = snap.docs;
          st.last = docsDesc[docsDesc.length - 1];
          for (const d of docsDesc) {
            if (!byId.has(d.id)) byId.set(d.id, d);
          }
        }

        const merged = Array.from(byId.values());
        // ASC for rendering; use message_id as tiebreaker when timestamps share the same second
        // (Telegram dates have only second precision, so messages within the same second need secondary ordering)
        merged.sort((a, b) => {
          const diff = tsToMillis(a.data().date) - tsToMillis(b.data().date);
          if (diff !== 0) return diff;
          const aId = parseInt(a.data().message_id, 10) || 0;
          const bId = parseInt(b.data().message_id, 10) || 0;
          return aId - bId;
        });
        return { docsAsc: merged, anyNonEmpty };
      }

      async function loadInitial() {
        const userIdRaw = els.inpUserId.value.trim();
        if (!userIdRaw) { clearAndRenderEmpty(); return; }
        paging = { byKey: Object.create(null), pageSize: 25 };
        const selectedBot = els.selBot.value; // empty string for main bot
        const cands = chatIdCandidates(userIdRaw, selectedBot);
        const s = els.inpStart.value ? new Date(els.inpStart.value) : null;
        const e = els.inpEnd.value ? new Date(els.inpEnd.value) : null;
        const { docsAsc, anyNonEmpty } = await fetchMergedBatch(cands, s, e);
        if (!anyNonEmpty || docsAsc.length === 0) { clearAndRenderEmpty(); return; }
        renderMessagesAsc(docsAsc, { prepend: false });
      }

      async function loadMore() {
        const userIdRaw = els.inpUserId.value.trim();
        if (!userIdRaw) return;
        const selectedBot = els.selBot.value;
        const cands = chatIdCandidates(userIdRaw, selectedBot);
        // if all candidates are done, stop
        if (cands.every((c) => ensurePagingKey(c.key).done)) return;
        const s = els.inpStart.value ? new Date(els.inpStart.value) : null;
        const e = els.inpEnd.value ? new Date(els.inpEnd.value) : null;
        const { docsAsc, anyNonEmpty } = await fetchMergedBatch(cands, s, e);
        if (!anyNonEmpty || docsAsc.length === 0) return;
        renderMessagesAsc(docsAsc, { prepend: true });
      }

      els.messages.addEventListener('scroll', () => {
        if (els.messages.scrollTop < 80) {
          loadMore();
        }
      });

      els.btnApply.addEventListener('click', () => {
        const u = new URL(location.href);
        const id = els.inpUserId.value.trim();
        const bot = els.selBot.value;
        if (id) u.searchParams.set('user_id', id); else u.searchParams.delete('user_id');
        if (bot) u.searchParams.set('bot', bot); else u.searchParams.delete('bot');
        history.replaceState(null, '', u.toString());
        loadInitial();
      });
      els.btnReload.addEventListener('click', loadInitial);

      onAuthStateChanged(auth, async (user) => {
        let authOk = !!user;
        if (!user) {
          try {
            console.log(TAG, 'No Firebase user yet; attempting anonymous sign-in…');
            await signInAnonymously(auth);
            authOk = true;
          } catch (e) {
            const diag = await diagnoseIdentityToolkit(cfg.apiKey);
            const hint = explainIdentityToolkitDiagnosis(diag);
            console.error(TAG, 'Firebase auth/init failed', {
              code: e && e.code ? e.code : undefined,
              message: e && e.message ? e.message : String(e),
              cfg: { projectId: cfg.projectId, authDomain: cfg.authDomain || '(empty)' },
              identityToolkit: diag && diag.body ? diag.body : null
            });
            // Don't hard-stop here: Firestore might still be readable (public rules). Try loading and show both errors if it fails.
            renderFatal('Firebase auth failed (continuing to try loading Firestore)…', JSON.stringify({
              code: e && e.code ? e.code : undefined,
              message: e && e.message ? e.message : String(e),
              projectId: cfg.projectId,
              authDomain: cfg.authDomain || '',
              identityToolkitStatus: diag.status || 0,
              identityToolkitBody: diag.body || null,
              hint
            }, null, 2));
          }
        }
        try {
          await loadInitial();
          if (!authOk) console.warn(TAG, 'Loaded Firestore without Firebase Auth user (rules likely allow reads).');
        } catch (e) {
          console.error(TAG, 'Firestore query failed', { code: e && e.code ? e.code : undefined, message: e && e.message ? e.message : String(e) });
          renderFatal('Failed to load conversations from Firestore.', JSON.stringify({
            code: e && e.code ? e.code : undefined,
            message: e && e.message ? e.message : String(e),
            hint: 'If this is "permission-denied", update Firestore security rules or ensure Firebase Auth works.'
          }, null, 2));
        }
      });
    }

    main().catch((e) => {
      console.error(TAG, 'Unhandled error', e);
      renderFatal('Unexpected error while loading conversations.', e && e.stack ? e.stack : String(e));
    });
  </script>
</body>
</html>


